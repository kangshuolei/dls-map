import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// ../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal3(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length3, i, keys;
        if (Array.isArray(a)) {
          length3 = a.length;
          if (length3 != b.length) return false;
          for (i = length3; i-- !== 0; )
            if (!equal3(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length3 = keys.length;
        if (length3 !== Object.keys(b).length) return false;
        for (i = length3; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length3; i-- !== 0; ) {
          var key = keys[i];
          if (!equal3(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../node_modules/.pnpm/@turf+jsts@2.7.1/node_modules/@turf/jsts/dist/jsts.min.js
var require_jsts_min = __commonJS({
  "../node_modules/.pnpm/@turf+jsts@2.7.1/node_modules/@turf/jsts/dist/jsts.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).jsts = e();
    }(exports, function() {
      "use strict";
      function t(t2, e3) {
        if (!(t2 instanceof e3)) throw new TypeError("Cannot call a class as a function");
      }
      function e(t2, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var i2 = e3[n2];
          i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t2, i2.key, i2);
        }
      }
      function n(t2, n2, i2) {
        return n2 && e(t2.prototype, n2), i2 && e(t2, i2), t2;
      }
      function i(t2, e3) {
        if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e3 && s(t2, e3);
      }
      function r(t2) {
        return r = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        }, r(t2);
      }
      function s(t2, e3) {
        return s = Object.setPrototypeOf || function(t3, e4) {
          return t3.__proto__ = e4, t3;
        }, s(t2, e3);
      }
      function a() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function o(t2, e3, n2) {
        return o = a() ? Reflect.construct : function(t3, e4, n3) {
          var i2 = [null];
          i2.push.apply(i2, e4);
          var r2 = new (Function.bind.apply(t3, i2))();
          return n3 && s(r2, n3.prototype), r2;
        }, o.apply(null, arguments);
      }
      function u4(t2) {
        var e3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return u4 = function(t3) {
          if (null === t3 || (n2 = t3, -1 === Function.toString.call(n2).indexOf("[native code]"))) return t3;
          var n2;
          if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e3) {
            if (e3.has(t3)) return e3.get(t3);
            e3.set(t3, i2);
          }
          function i2() {
            return o(t3, arguments, r(this).constructor);
          }
          return i2.prototype = Object.create(t3.prototype, { constructor: { value: i2, enumerable: false, writable: true, configurable: true } }), s(i2, t3);
        }, u4(t2);
      }
      function l(t2) {
        if (void 0 === t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      function h(t2, e3) {
        if (e3 && ("object" == typeof e3 || "function" == typeof e3)) return e3;
        if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
        return l(t2);
      }
      function c(t2) {
        var e3 = a();
        return function() {
          var n2, i2 = r(t2);
          if (e3) {
            var s2 = r(this).constructor;
            n2 = Reflect.construct(i2, arguments, s2);
          } else n2 = i2.apply(this, arguments);
          return h(this, n2);
        };
      }
      function f(t2, e3, n2) {
        return f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t3, e4, n3) {
          var i2 = function(t4, e6) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e6) && null !== (t4 = r(t4)); ) ;
            return t4;
          }(t3, e4);
          if (i2) {
            var s2 = Object.getOwnPropertyDescriptor(i2, e4);
            return s2.get ? s2.get.call(n3) : s2.value;
          }
        }, f(t2, e3, n2 || t2);
      }
      function v2(t2) {
        return function(t3) {
          if (Array.isArray(t3)) return y2(t3);
        }(t2) || function(t3) {
          if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"]) return Array.from(t3);
        }(t2) || g(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function g(t2, e3) {
        if (t2) {
          if ("string" == typeof t2) return y2(t2, e3);
          var n2 = Object.prototype.toString.call(t2).slice(8, -1);
          return "Object" === n2 && t2.constructor && (n2 = t2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(t2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? y2(t2, e3) : void 0;
        }
      }
      function y2(t2, e3) {
        (null == e3 || e3 > t2.length) && (e3 = t2.length);
        for (var n2 = 0, i2 = new Array(e3); n2 < e3; n2++) i2[n2] = t2[n2];
        return i2;
      }
      function d(t2, e3) {
        var n2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
        if (!n2) {
          if (Array.isArray(t2) || (n2 = g(t2)) || e3 && t2 && "number" == typeof t2.length) {
            n2 && (t2 = n2);
            var i2 = 0, r2 = function() {
            };
            return { s: r2, n: function() {
              return i2 >= t2.length ? { done: true } : { done: false, value: t2[i2++] };
            }, e: function(t3) {
              throw t3;
            }, f: r2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var s2, a2 = true, o2 = false;
        return { s: function() {
          n2 = n2.call(t2);
        }, n: function() {
          var t3 = n2.next();
          return a2 = t3.done, t3;
        }, e: function(t3) {
          o2 = true, s2 = t3;
        }, f: function() {
          try {
            a2 || null == n2.return || n2.return();
          } finally {
            if (o2) throw s2;
          }
        } };
      }
      var _ = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(t2) {
          this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = e3.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = e3.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== e3.JOIN_ROUND && (this._quadrantSegments = e3.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(t2) {
          this._joinStyle = t2;
        } }, { key: "setSimplifyFactor", value: function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(t2) {
          this._endCapStyle = t2;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(t2) {
          this._mitreLimit = t2;
        } }, { key: "setSingleSided", value: function(t2) {
          this._isSingleSided = t2;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = e3.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = e3.CAP_ROUND, this._joinStyle = e3.JOIN_ROUND, this._mitreLimit = e3.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = e3.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setQuadrantSegments(t2);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(s2), this.setJoinStyle(a2), this.setMitreLimit(o2);
          }
        } }, { key: "bufferDistanceError", value: function(t2) {
          var e4 = Math.PI / 2 / t2;
          return 1 - Math.cos(e4 / 2);
        } }]), e3;
      }();
      _.CAP_ROUND = 1, _.CAP_FLAT = 2, _.CAP_SQUARE = 3, _.JOIN_ROUND = 1, _.JOIN_MITRE = 2, _.JOIN_BEVEL = 3, _.DEFAULT_QUADRANT_SEGMENTS = 8, _.DEFAULT_MITRE_LIMIT = 5, _.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var p = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2(e4) {
          var n2;
          return t(this, s2), (n2 = r2.call(this, e4)).name = Object.keys({ Exception: s2 })[0], n2;
        }
        return n(s2, [{ key: "toString", value: function() {
          return this.message;
        } }]), s2;
      }(u4(Error)), m = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ IllegalArgumentException: r2 })[0], i2;
        }
        return r2;
      }(p), k = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "filter", value: function(t2) {
        } }]), e3;
      }();
      function x2() {
      }
      function I() {
      }
      function E() {
      }
      var N, T, S, L, C, R, w, O, b = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "equalsWithTolerance", value: function(t2, e4, n2) {
          return Math.abs(t2 - e4) <= n2;
        } }]), e3;
      }(), M = function() {
        function e3(n2, i2) {
          t(this, e3), this.low = i2 || 0, this.high = n2 || 0;
        }
        return n(e3, null, [{ key: "toBinaryString", value: function(t2) {
          var e4, n2 = "";
          for (e4 = 2147483648; e4 > 0; e4 >>>= 1) n2 += (t2.high & e4) === e4 ? "1" : "0";
          for (e4 = 2147483648; e4 > 0; e4 >>>= 1) n2 += (t2.low & e4) === e4 ? "1" : "0";
          return n2;
        } }]), e3;
      }();
      function A() {
      }
      function P() {
      }
      A.NaN = NaN, A.isNaN = function(t2) {
        return Number.isNaN(t2);
      }, A.isInfinite = function(t2) {
        return !Number.isFinite(t2);
      }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, "function" == typeof Float64Array && "function" == typeof Int32Array ? (R = 2146435072, w = new Float64Array(1), O = new Int32Array(w.buffer), A.doubleToLongBits = function(t2) {
        w[0] = t2;
        var e3 = 0 | O[0], n2 = 0 | O[1];
        return (n2 & R) === R && 0 != (1048575 & n2) && 0 !== e3 && (e3 = 0, n2 = 2146959360), new M(n2, e3);
      }, A.longBitsToDouble = function(t2) {
        return O[0] = t2.low, O[1] = t2.high, w[0];
      }) : (N = 1023, T = Math.log2, S = Math.floor, L = Math.pow, C = function() {
        for (var t2 = 53; t2 > 0; t2--) {
          var e3 = L(2, t2) - 1;
          if (S(T(e3)) + 1 === t2) return e3;
        }
        return 0;
      }(), A.doubleToLongBits = function(t2) {
        var e3, n2, i2, r2, s2, a2, o2, u5, l2;
        if (t2 < 0 || 1 / t2 === Number.NEGATIVE_INFINITY ? (a2 = 1 << 31, t2 = -t2) : a2 = 0, 0 === t2) return new M(u5 = a2, l2 = 0);
        if (t2 === 1 / 0) return new M(u5 = 2146435072 | a2, l2 = 0);
        if (t2 != t2) return new M(u5 = 2146959360, l2 = 0);
        if (r2 = 0, l2 = 0, (e3 = S(t2)) > 1) if (e3 <= C) (r2 = S(T(e3))) <= 20 ? (l2 = 0, u5 = e3 << 20 - r2 & 1048575) : (l2 = e3 % (n2 = L(2, i2 = r2 - 20)) << 32 - i2, u5 = e3 / n2 & 1048575);
        else for (i2 = e3, l2 = 0; 0 !== (i2 = S(n2 = i2 / 2)); ) r2++, l2 >>>= 1, l2 |= (1 & u5) << 31, u5 >>>= 1, n2 !== i2 && (u5 |= 524288);
        if (o2 = r2 + N, s2 = 0 === e3, e3 = t2 - e3, r2 < 52 && 0 !== e3) for (i2 = 0; ; ) {
          if ((n2 = 2 * e3) >= 1 ? (e3 = n2 - 1, s2 ? (o2--, s2 = false) : (i2 <<= 1, i2 |= 1, r2++)) : (e3 = n2, s2 ? 0 == --o2 && (r2++, s2 = false) : (i2 <<= 1, r2++)), 20 === r2) u5 |= i2, i2 = 0;
          else if (52 === r2) {
            l2 |= i2;
            break;
          }
          if (1 === n2) {
            r2 < 20 ? u5 |= i2 << 20 - r2 : r2 < 52 && (l2 |= i2 << 52 - r2);
            break;
          }
        }
        return u5 |= o2 << 20, new M(u5 |= a2, l2);
      }, A.longBitsToDouble = function(t2) {
        var e3, n2, i2, r2, s2 = t2.high, a2 = t2.low, o2 = s2 & 1 << 31 ? -1 : 1;
        for (i2 = ((2146435072 & s2) >> 20) - N, r2 = 0, n2 = 1 << 19, e3 = 1; e3 <= 20; e3++) s2 & n2 && (r2 += L(2, -e3)), n2 >>>= 1;
        for (n2 = 1 << 31, e3 = 21; e3 <= 52; e3++) a2 & n2 && (r2 += L(2, -e3)), n2 >>>= 1;
        if (-1023 === i2) {
          if (0 === r2) return 0 * o2;
          i2 = -1022;
        } else {
          if (1024 === i2) return 0 === r2 ? o2 / 0 : NaN;
          r2 += 1;
        }
        return o2 * r2 * L(2, i2);
      });
      var D2 = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ RuntimeException: r2 })[0], i2;
        }
        return r2;
      }(p), F = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, null, [{ key: "constructor_", value: function() {
          if (0 === arguments.length) D2.constructor_.call(this);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            D2.constructor_.call(this, t2);
          }
        } }]), s2;
      }(D2), G = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "shouldNeverReachHere", value: function() {
          if (0 === arguments.length) e3.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            throw new F("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            e3.isTrue(t2, null);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (!n2) throw null === i2 ? new F() : new F(i2);
          }
        } }, { key: "equals", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], n2 = arguments[1];
            e3.equals(t2, n2, null);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            if (!r2.equals(i2)) throw new F("Expected " + i2 + " but encountered " + r2 + (null !== s2 ? ": " + s2 : ""));
          }
        } }]), e3;
      }(), q = new ArrayBuffer(8), Y = new Float64Array(q), z = new Int32Array(q), X = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getM", value: function() {
          return A.NaN;
        } }, { key: "setOrdinate", value: function(t2, n2) {
          switch (t2) {
            case e3.X:
              this.x = n2;
              break;
            case e3.Y:
              this.y = n2;
              break;
            case e3.Z:
              this.setZ(n2);
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        } }, { key: "equals2D", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            return !!b.equalsWithTolerance(this.x, e4.x, n2) && !!b.equalsWithTolerance(this.y, e4.y, n2);
          }
        } }, { key: "setM", value: function(t2) {
          throw new m("Invalid ordinate index: " + e3.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(t2) {
          switch (t2) {
            case e3.X:
              return this.x;
            case e3.Y:
              return this.y;
            case e3.Z:
              return this.getZ();
          }
          throw new m("Invalid ordinate index: " + t2);
        } }, { key: "equals3D", value: function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.getZ() === t2.getZ() || A.isNaN(this.getZ()) && A.isNaN(t2.getZ()));
        } }, { key: "equals", value: function(t2) {
          return t2 instanceof e3 && this.equals2D(t2);
        } }, { key: "equalInZ", value: function(t2, e4) {
          return b.equalsWithTolerance(this.getZ(), t2.getZ(), e4);
        } }, { key: "setX", value: function(t2) {
          this.x = t2;
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this.x < e4.x ? -1 : this.x > e4.x ? 1 : this.y < e4.y ? -1 : this.y > e4.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(t2) {
          this.z = t2;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (t2) {
            if (t2 instanceof CloneNotSupportedException) return G.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw t2;
          }
        } }, { key: "copy", value: function() {
          return new e3(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(t2) {
          var e4 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.getZ() - t2.getZ();
          return Math.sqrt(e4 * e4 + n2 * n2 + i2 * i2);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(t2) {
          this.y = t2;
        } }, { key: "distance", value: function(t2) {
          var e4 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e4 * e4 + n2 * n2);
        } }, { key: "hashCode", value: function() {
          var t2 = 17;
          return t2 = 37 * (t2 = 37 * t2 + e3.hashCode(this.x)) + e3.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.getZ();
        } }, { key: "interfaces_", get: function() {
          return [x2, I, E];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) e3.constructor_.call(this, 0, 0);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            e3.constructor_.call(this, t2.x, t2.y, t2.getZ());
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            e3.constructor_.call(this, n2, i2, e3.NULL_ORDINATE);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.x = r2, this.y = s2, this.z = a2;
          }
        } }, { key: "hashCode", value: function(t2) {
          return Y[0] = t2, z[0] ^ z[1];
        } }]), e3;
      }(), B3 = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "compare", value: function(t2, n2) {
          var i2 = e3.compare(t2.x, n2.x);
          if (0 !== i2) return i2;
          var r2 = e3.compare(t2.y, n2.y);
          return 0 !== r2 ? r2 : this._dimensionsToTest <= 2 ? 0 : e3.compare(t2.getZ(), n2.getZ());
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, 0 === arguments.length) e3.constructor_.call(this, 2);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            if (2 !== t2 && 3 !== t2) throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = t2;
          }
        } }, { key: "compare", value: function(t2, e4) {
          return t2 < e4 ? -1 : t2 > e4 ? 1 : A.isNaN(t2) ? A.isNaN(e4) ? 0 : -1 : A.isNaN(e4) ? 1 : 0;
        } }]), e3;
      }();
      X.DimensionalComparator = B3, X.NULL_ORDINATE = A.NaN, X.X = 0, X.Y = 1, X.Z = 2, X.M = 3;
      var U = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(t2) {
          if (!(t2 instanceof e3)) return false;
          var n2 = t2;
          return this.isNull() ? n2.isNull() : this._maxx === n2.getMaxX() && this._maxy === n2.getMaxY() && this._minx === n2.getMinX() && this._miny === n2.getMinY();
        } }, { key: "intersection", value: function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2)) return new e3();
          var n2 = this._minx > t2._minx ? this._minx : t2._minx, i2 = this._miny > t2._miny ? this._miny : t2._miny;
          return new e3(n2, this._maxx < t2._maxx ? this._maxx : t2._maxx, i2, this._maxy < t2._maxy ? this._maxy : t2._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              return !this.isNull() && !n2.isNull() && (n2.getMinX() >= this._minx && n2.getMaxX() <= this._maxx && n2.getMinY() >= this._miny && n2.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return !this.isNull() && (i2 >= this._minx && i2 <= this._maxx && r2 >= this._miny && r2 <= this._maxy);
          }
        } }, { key: "intersects", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof e3) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof X) {
              var n2 = arguments[0];
              return this.intersects(n2.x, n2.y);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof X && arguments[1] instanceof X) {
              var i2 = arguments[0], r2 = arguments[1];
              if (this.isNull()) return false;
              var s2 = i2.x < r2.x ? i2.x : r2.x;
              if (s2 > this._maxx) return false;
              var a2 = i2.x > r2.x ? i2.x : r2.x;
              if (a2 < this._minx) return false;
              var o2 = i2.y < r2.y ? i2.y : r2.y;
              if (o2 > this._maxy) return false;
              var u5 = i2.y > r2.y ? i2.y : r2.y;
              return !(u5 < this._miny);
            }
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var l2 = arguments[0], h2 = arguments[1];
              return !this.isNull() && !(l2 > this._maxx || l2 < this._minx || h2 > this._maxy || h2 < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var t2 = this.getWidth(), e4 = this.getHeight();
          return Math.sqrt(t2 * t2 + e4 * e4);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              if (n2.isNull()) return null;
              this.isNull() ? (this._minx = n2.getMinX(), this._maxx = n2.getMaxX(), this._miny = n2.getMinY(), this._maxy = n2.getMaxY()) : (n2._minx < this._minx && (this._minx = n2._minx), n2._maxx > this._maxx && (this._maxx = n2._maxx), n2._miny < this._miny && (this._miny = n2._miny), n2._maxy > this._maxy && (this._maxy = n2._maxy));
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.isNull() ? (this._minx = i2, this._maxx = i2, this._miny = r2, this._maxy = r2) : (i2 < this._minx && (this._minx = i2), i2 > this._maxx && (this._maxx = i2), r2 < this._miny && (this._miny = r2), r2 > this._maxy && (this._maxy = r2));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var t2 = this.getWidth(), e4 = this.getHeight();
          return t2 < e4 ? t2 : e4;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this.isNull() ? e4.isNull() ? 0 : -1 : e4.isNull() ? 1 : this._minx < e4._minx ? -1 : this._minx > e4._minx ? 1 : this._miny < e4._miny ? -1 : this._miny > e4._miny ? 1 : this._maxx < e4._maxx ? -1 : this._maxx > e4._maxx ? 1 : this._maxy < e4._maxy ? -1 : this._maxy > e4._maxy ? 1 : 0;
        } }, { key: "translate", value: function(t2, e4) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e4, this.getMaxY() + e4);
        } }, { key: "copy", value: function() {
          return new e3(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(t2) {
          return !(!this.isNull() && !t2.isNull()) || (t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var t2 = this.getWidth(), e4 = this.getHeight();
          return t2 > e4 ? t2 : e4;
        } }, { key: "expandBy", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            if (this.isNull()) return null;
            this._minx -= e4, this._maxx += e4, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof e3) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof X) {
              var n2 = arguments[0];
              return this.covers(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this.covers(i2, r2);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new X((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (0 === arguments.length) this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              this._minx = n2._minx, this._maxx = n2._maxx, this._miny = n2._miny, this._maxy = n2._maxy;
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = arguments[3];
            s2 < a2 ? (this._minx = s2, this._maxx = a2) : (this._minx = a2, this._maxx = s2), o2 < u5 ? (this._miny = o2, this._maxy = u5) : (this._miny = u5, this._maxy = o2);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(t2) {
          if (this.intersects(t2)) return 0;
          var e4 = 0;
          this._maxx < t2._minx ? e4 = t2._minx - this._maxx : this._minx > t2._maxx && (e4 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e4 ? n2 : 0 === n2 ? e4 : Math.sqrt(e4 * e4 + n2 * n2);
        } }, { key: "hashCode", value: function() {
          var t2 = 17;
          return t2 = 37 * (t2 = 37 * (t2 = 37 * (t2 = 37 * t2 + X.hashCode(this._minx)) + X.hashCode(this._maxx)) + X.hashCode(this._miny)) + X.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [x2, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = arguments[3];
            this.init(s2, a2, o2, u5);
          }
        } }, { key: "intersects", value: function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e4.x ? t2.x : e4.x) && n2.x <= (t2.x > e4.x ? t2.x : e4.x) && n2.y >= (t2.y < e4.y ? t2.y : e4.y) && n2.y <= (t2.y > e4.y ? t2.y : e4.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3], o2 = Math.min(s2.x, a2.x), u5 = Math.max(s2.x, a2.x), l2 = Math.min(i2.x, r2.x), h2 = Math.max(i2.x, r2.x);
            return !(l2 > u5) && (!(h2 < o2) && (o2 = Math.min(s2.y, a2.y), u5 = Math.max(s2.y, a2.y), l2 = Math.min(i2.y, r2.y), h2 = Math.max(i2.y, r2.y), !(l2 > u5) && !(h2 < o2)));
          }
        } }]), e3;
      }(), V = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === e3.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(t2) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return false;
        } }, { key: "equalsExact", value: function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(e3.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(t2) {
          return null !== t2 && this.norm().equalsExact(t2.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var t2;
          if (1 === arguments.length) {
            var e4 = arguments[0];
            return t2 = e4, this.getTypeCode() !== t2.getTypeCode() ? this.getTypeCode() - t2.getTypeCode() : this.isEmpty() && t2.isEmpty() ? 0 : this.isEmpty() ? -1 : t2.isEmpty() ? 1 : this.compareToSameClass(e4);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return t2 = n2, this.getTypeCode() !== t2.getTypeCode() ? this.getTypeCode() - t2.getTypeCode() : this.isEmpty() && t2.isEmpty() ? 0 : this.isEmpty() ? -1 : t2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(t2) {
          if (t2.getTypeCode() === e3.TYPECODE_GEOMETRYCOLLECTION) throw new m("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(t2, e4, n2) {
          return 0 === n2 ? t2.equals(e4) : t2.distance(e4) <= n2;
        } }, { key: "norm", value: function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        } }, { key: "reverse", value: function() {
          var t2 = this.reverseInternal();
          return null != this.envelope && (t2.envelope = this.envelope.copy()), t2.setSRID(this.getSRID()), t2;
        } }, { key: "copy", value: function() {
          var t2 = this.copyInternal();
          return t2.envelope = null == this._envelope ? null : this._envelope.copy(), t2._SRID = this._SRID, t2._userData = this._userData, t2;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope);
        } }, { key: "setSRID", value: function(t2) {
          this._SRID = t2;
        } }, { key: "setUserData", value: function(t2) {
          this._userData = t2;
        } }, { key: "compare", value: function(t2, e4) {
          for (var n2 = t2.iterator(), i2 = e4.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), s2 = i2.next(), a2 = r2.compareTo(s2);
            if (0 !== a2) return a2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(t2) {
          return this.getClass() === t2.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === e3.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === e3.TYPECODE_MULTIPOINT || this.getTypeCode() === e3.TYPECODE_MULTILINESTRING || this.getTypeCode() === e3.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [I, x2, E];
        } }, { key: "getClass", value: function() {
          return e3;
        } }], [{ key: "hasNonEmptyElements", value: function(t2) {
          for (var e4 = 0; e4 < t2.length; e4++) if (!t2[e4].isEmpty()) return true;
          return false;
        } }, { key: "hasNullElements", value: function(t2) {
          for (var e4 = 0; e4 < t2.length; e4++) if (null === t2[e4]) return true;
          return false;
        } }]), e3;
      }();
      V.constructor_ = function(t2) {
        t2 && (this._envelope = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID());
      }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = "Point", V.TYPENAME_MULTIPOINT = "MultiPoint", V.TYPENAME_LINESTRING = "LineString", V.TYPENAME_LINEARRING = "LinearRing", V.TYPENAME_MULTILINESTRING = "MultiLineString", V.TYPENAME_POLYGON = "Polygon", V.TYPENAME_MULTIPOLYGON = "MultiPolygon", V.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", V.geometryChangedFilter = { get interfaces_() {
        return [k];
      }, filter: function(t2) {
        t2.geometryChangedAction();
      } };
      var H = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "toLocationSymbol", value: function(t2) {
          switch (t2) {
            case e3.EXTERIOR:
              return "e";
            case e3.BOUNDARY:
              return "b";
            case e3.INTERIOR:
              return "i";
            case e3.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        } }]), e3;
      }();
      H.INTERIOR = 0, H.BOUNDARY = 1, H.EXTERIOR = 2, H.NONE = -1;
      var Z = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]), e3;
      }(), j = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ NoSuchElementException: r2 })[0], i2;
        }
        return r2;
      }(p), W = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ UnsupportedOperationException: r2 })[0], i2;
        }
        return r2;
      }(p), K = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          return t(this, s2), r2.apply(this, arguments);
        }
        return n(s2, [{ key: "contains", value: function() {
        } }]), s2;
      }(Z), J = function(e3, r2) {
        i(a2, e3);
        var s2 = c(a2);
        function a2(e4) {
          var n2;
          return t(this, a2), (n2 = s2.call(this)).map = /* @__PURE__ */ new Map(), e4 instanceof Z && n2.addAll(e4), n2;
        }
        return n(a2, [{ key: "contains", value: function(t2) {
          var e4 = t2.hashCode ? t2.hashCode() : t2;
          return !!this.map.has(e4);
        } }, { key: "add", value: function(t2) {
          var e4 = t2.hashCode ? t2.hashCode() : t2;
          return !this.map.has(e4) && !!this.map.set(e4, t2);
        } }, { key: "addAll", value: function(t2) {
          var e4, n2 = d(t2);
          try {
            for (n2.s(); !(e4 = n2.n()).done; ) {
              var i2 = e4.value;
              this.add(i2);
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new W();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return 0 === this.map.size;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new Q(this.map);
        } }, { key: r2, value: function() {
          return this.map;
        } }]), a2;
      }(K, Symbol.iterator), Q = function() {
        function e3(n2) {
          t(this, e3), this.iterator = n2.values();
          var i2 = this.iterator.next(), r2 = i2.done, s2 = i2.value;
          this.done = r2, this.value = s2;
        }
        return n(e3, [{ key: "next", value: function() {
          if (this.done) throw new j();
          var t2 = this.value, e4 = this.iterator.next(), n2 = e4.done, i2 = e4.value;
          return this.done = n2, this.value = i2, t2;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new W();
        } }]), e3;
      }(), $ = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "opposite", value: function(t2) {
          return t2 === e3.LEFT ? e3.RIGHT : t2 === e3.RIGHT ? e3.LEFT : t2;
        } }]), e3;
      }();
      $.ON = 0, $.LEFT = 1, $.RIGHT = 2;
      var tt = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ EmptyStackException: r2 })[0], i2;
        }
        return r2;
      }(p), et = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2(e4) {
          var i2;
          return t(this, r2), (i2 = n2.call(this, e4)).name = Object.keys({ IndexOutOfBoundsException: r2 })[0], i2;
        }
        return r2;
      }(p), nt = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          return t(this, s2), r2.apply(this, arguments);
        }
        return n(s2, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]), s2;
      }(Z), it = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), (e4 = r2.call(this)).array = [], e4;
        }
        return n(s2, [{ key: "add", value: function(t2) {
          return this.array.push(t2), true;
        } }, { key: "get", value: function(t2) {
          if (t2 < 0 || t2 >= this.size()) throw new et();
          return this.array[t2];
        } }, { key: "push", value: function(t2) {
          return this.array.push(t2), t2;
        } }, { key: "pop", value: function() {
          if (0 === this.array.length) throw new tt();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (0 === this.array.length) throw new tt();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return 0 === this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(t2) {
          return this.array.indexOf(t2);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]), s2;
      }(nt);
      function rt(t2, e3) {
        return t2.interfaces_ && t2.interfaces_.indexOf(e3) > -1;
      }
      var st = function() {
        function e3(n2) {
          t(this, e3), this.str = n2;
        }
        return n(e3, [{ key: "append", value: function(t2) {
          this.str += t2;
        } }, { key: "setCharAt", value: function(t2, e4) {
          this.str = this.str.substr(0, t2) + e4 + this.str.substr(t2 + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]), e3;
      }(), at = function() {
        function e3(n2) {
          t(this, e3), this.value = n2;
        }
        return n(e3, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        } }], [{ key: "compare", value: function(t2, e4) {
          return t2 < e4 ? -1 : t2 > e4 ? 1 : 0;
        } }, { key: "isNan", value: function(t2) {
          return Number.isNaN(t2);
        } }, { key: "valueOf", value: function(t2) {
          return new e3(t2);
        } }]), e3;
      }(), ot = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "isWhitespace", value: function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        } }, { key: "toUpperCase", value: function(t2) {
          return t2.toUpperCase();
        } }]), e3;
      }(), ut = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "le", value: function(t2) {
          return this._hi < t2._hi || this._hi === t2._hi && this._lo <= t2._lo;
        } }, { key: "extractSignificantDigits", value: function(t2, n2) {
          var i2 = this.abs(), r2 = e3.magnitude(i2._hi), s2 = e3.TEN.pow(r2);
          (i2 = i2.divide(s2)).gt(e3.TEN) ? (i2 = i2.divide(e3.TEN), r2 += 1) : i2.lt(e3.ONE) && (i2 = i2.multiply(e3.TEN), r2 -= 1);
          for (var a2 = r2 + 1, o2 = new st(), u5 = e3.MAX_PRINT_DIGITS - 1, l2 = 0; l2 <= u5; l2++) {
            t2 && l2 === a2 && o2.append(".");
            var h2 = Math.trunc(i2._hi);
            if (h2 < 0) break;
            var c2 = false, f2 = 0;
            h2 > 9 ? (c2 = true, f2 = "9") : f2 = "0" + h2, o2.append(f2), i2 = i2.subtract(e3.valueOf(h2)).multiply(e3.TEN), c2 && i2.selfAdd(e3.TEN);
            var v3 = true, g2 = e3.magnitude(i2._hi);
            if (g2 < 0 && Math.abs(g2) >= u5 - l2 && (v3 = false), !v3) break;
          }
          return n2[0] = r2, o2.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.add(-n2);
          }
        } }, { key: "equals", value: function() {
          if (1 === arguments.length && arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        } }, { key: "isZero", value: function() {
          return 0 === this._hi && 0 === this._lo;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-n2, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(t2) {
          return this.le(t2) ? this : t2;
        } }, { key: "selfDivide", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof e3) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              return this.selfDivide(n2, 0);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = null, a2 = null, o2 = null, u5 = null, l2 = null, h2 = null, c2 = null, f2 = null;
            return l2 = this._hi / i2, f2 = (s2 = (h2 = e3.SPLIT * l2) - (s2 = h2 - l2)) * (o2 = (f2 = e3.SPLIT * i2) - (o2 = f2 - i2)) - (c2 = l2 * i2) + s2 * (u5 = i2 - o2) + (a2 = l2 - s2) * o2 + a2 * u5, f2 = l2 + (h2 = (this._hi - c2 - f2 + this._lo - l2 * r2) / i2), this._hi = f2, this._lo = l2 - f2 + h2, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0], n2 = null, i2 = null, r2 = null, s2 = null, a2 = null, o2 = null, u5 = null, l2 = null;
            i2 = (a2 = this._hi / t2._hi) - (n2 = (o2 = e3.SPLIT * a2) - (n2 = o2 - a2)), l2 = n2 * (r2 = (l2 = e3.SPLIT * t2._hi) - (r2 = l2 - t2._hi)) - (u5 = a2 * t2._hi) + n2 * (s2 = t2._hi - r2) + i2 * r2 + i2 * s2;
            var h2 = l2 = a2 + (o2 = (this._hi - u5 - l2 + this._lo - a2 * t2._lo) / t2._hi), c2 = a2 - l2 + o2;
            return new e3(h2, c2);
          }
          if ("number" == typeof arguments[0]) {
            var f2 = arguments[0];
            return A.isNaN(f2) ? e3.createNaN() : e3.copy(this).selfDivide(f2, 0);
          }
        } }, { key: "ge", value: function(t2) {
          return this._hi > t2._hi || this._hi === t2._hi && this._lo >= t2._lo;
        } }, { key: "pow", value: function(t2) {
          if (0 === t2) return e3.valueOf(1);
          var n2 = new e3(this), i2 = e3.valueOf(1), r2 = Math.abs(t2);
          if (r2 > 1) for (; r2 > 0; ) r2 % 2 == 1 && i2.selfMultiply(n2), (r2 /= 2) > 0 && (n2 = n2.sqr());
          else i2 = n2;
          return t2 < 0 ? i2.reciprocal() : i2;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return e3.NaN;
          var t2 = Math.ceil(this._hi), n2 = 0;
          return t2 === this._hi && (n2 = Math.ceil(this._lo)), new e3(t2, n2);
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this._hi < e4._hi ? -1 : this._hi > e4._hi ? 1 : this._lo < e4._lo ? -1 : this._lo > e4._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.init(n2), this;
          }
        } }, { key: "max", value: function(t2) {
          return this.ge(t2) ? this : t2;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return e3.valueOf(0);
          if (this.isNegative()) return e3.NaN;
          var t2 = 1 / Math.sqrt(this._hi), n2 = this._hi * t2, i2 = e3.valueOf(n2), r2 = this.subtract(i2.sqr())._hi * (0.5 * t2);
          return i2.add(r2);
        } }, { key: "selfAdd", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof e3) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2 = arguments[0], i2 = null, r2 = null, s2 = null, a2 = null, o2 = null, u5 = null;
              return a2 = (s2 = this._hi + n2) - (o2 = s2 - this._hi), r2 = (u5 = (a2 = n2 - o2 + (this._hi - a2)) + this._lo) + (s2 - (i2 = s2 + u5)), this._hi = i2 + r2, this._lo = r2 + (i2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var l2 = arguments[0], h2 = arguments[1], c2 = null, f2 = null, v3 = null, g2 = null, y3 = null, d2 = null, _2 = null;
            g2 = this._hi + l2, f2 = this._lo + h2, y3 = g2 - (d2 = g2 - this._hi), v3 = f2 - (_2 = f2 - this._lo);
            var p2 = (c2 = g2 + (d2 = (y3 = l2 - d2 + (this._hi - y3)) + f2)) + (d2 = (v3 = h2 - _2 + (this._lo - v3)) + (d2 + (g2 - c2))), m2 = d2 + (c2 - p2);
            return this._hi = p2, this._lo = m2, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof e3) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              return this.selfMultiply(n2, 0);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = null, a2 = null, o2 = null, u5 = null, l2 = null, h2 = null;
            s2 = (l2 = e3.SPLIT * this._hi) - this._hi, h2 = e3.SPLIT * i2, s2 = l2 - s2, a2 = this._hi - s2, o2 = h2 - i2;
            var c2 = (l2 = this._hi * i2) + (h2 = s2 * (o2 = h2 - o2) - l2 + s2 * (u5 = i2 - o2) + a2 * o2 + a2 * u5 + (this._hi * r2 + this._lo * i2)), f2 = h2 + (s2 = l2 - c2);
            return this._hi = c2, this._lo = f2, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return e3.NaN;
          var t2 = Math.floor(this._hi), n2 = 0;
          return t2 === this._hi && (n2 = Math.floor(this._lo)), new e3(t2, n2);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new e3(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (t2) {
            if (t2 instanceof CloneNotSupportedException) return null;
            throw t2;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return t2.isNaN() ? e3.createNaN() : e3.copy(this).selfMultiply(t2);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return A.isNaN(n2) ? e3.createNaN() : e3.copy(this).selfMultiply(n2, 0);
          }
        } }, { key: "isNaN", value: function() {
          return A.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var t2 = e3.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var t2 = this.getSpecialNumberString();
          if (null !== t2) return t2;
          var n2 = new Array(1).fill(null), i2 = this.extractSignificantDigits(true, n2), r2 = n2[0] + 1, s2 = i2;
          if ("." === i2.charAt(0)) s2 = "0" + i2;
          else if (r2 < 0) s2 = "0." + e3.stringOfChar("0", -r2) + i2;
          else if (-1 === i2.indexOf(".")) {
            var a2 = r2 - i2.length;
            s2 = i2 + e3.stringOfChar("0", a2) + ".0";
          }
          return this.isNegative() ? "-" + s2 : s2;
        } }, { key: "reciprocal", value: function() {
          var t2, n2, i2, r2, s2 = null, a2 = null, o2 = null, u5 = null;
          t2 = (i2 = 1 / this._hi) - (s2 = (o2 = e3.SPLIT * i2) - (s2 = o2 - i2)), a2 = (u5 = e3.SPLIT * this._hi) - this._hi;
          var l2 = i2 + (o2 = (1 - (r2 = i2 * this._hi) - (u5 = s2 * (a2 = u5 - a2) - r2 + s2 * (n2 = this._hi - a2) + t2 * a2 + t2 * n2) - i2 * this._lo) / this._hi);
          return new e3(l2, i2 - l2 + o2);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return e3.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (null !== t2) return t2;
          var n2 = new Array(1).fill(null), i2 = this.extractSignificantDigits(false, n2), r2 = e3.SCI_NOT_EXPONENT_CHAR + n2[0];
          if ("0" === i2.charAt(0)) throw new IllegalStateException("Found leading zero: " + i2);
          var s2 = "";
          i2.length > 1 && (s2 = i2.substring(1));
          var a2 = i2.charAt(0) + "." + s2;
          return this.isNegative() ? "-" + a2 + r2 : a2 + r2;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? e3.NaN : this.isNegative() ? this.negate() : new e3(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || 0 === this._hi && this._lo > 0;
        } }, { key: "lt", value: function(t2) {
          return this._hi < t2._hi || this._hi === t2._hi && this._lo < t2._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return e3.copy(this).selfAdd(t2);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return e3.copy(this).selfAdd(n2);
          }
        } }, { key: "init", value: function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              this._hi = n2._hi, this._lo = n2._lo;
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this._hi = i2, this._lo = r2;
          }
        } }, { key: "gt", value: function(t2) {
          return this._hi > t2._hi || this._hi === t2._hi && this._lo > t2._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || 0 === this._hi && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? e3.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [E, x2, I];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this.init(t2);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              e3.constructor_.call(this, e3.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1];
            this.init(r2, s2);
          }
        } }, { key: "determinant", value: function() {
          if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            return e3.determinant(e3.valueOf(t2), e3.valueOf(n2), e3.valueOf(i2), e3.valueOf(r2));
          }
          if (arguments[3] instanceof e3 && arguments[2] instanceof e3 && arguments[0] instanceof e3 && arguments[1] instanceof e3) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = arguments[3], l2 = s2.multiply(u5).selfSubtract(a2.multiply(o2));
            return l2;
          }
        } }, { key: "sqr", value: function(t2) {
          return e3.valueOf(t2).selfMultiply(t2);
        } }, { key: "valueOf", value: function() {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            return e3.parse(t2);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return new e3(n2);
          }
        } }, { key: "sqrt", value: function(t2) {
          return e3.valueOf(t2).sqrt();
        } }, { key: "parse", value: function(t2) {
          for (var n2 = 0, i2 = t2.length; ot.isWhitespace(t2.charAt(n2)); ) n2++;
          var r2 = false;
          if (n2 < i2) {
            var s2 = t2.charAt(n2);
            "-" !== s2 && "+" !== s2 || (n2++, "-" === s2 && (r2 = true));
          }
          for (var a2 = new e3(), o2 = 0, u5 = 0, l2 = 0, h2 = false; !(n2 >= i2); ) {
            var c2 = t2.charAt(n2);
            if (n2++, ot.isDigit(c2)) {
              var f2 = c2 - "0";
              a2.selfMultiply(e3.TEN), a2.selfAdd(f2), o2++;
            } else {
              if ("." !== c2) {
                if ("e" === c2 || "E" === c2) {
                  var v3 = t2.substring(n2);
                  try {
                    l2 = at.parseInt(v3);
                  } catch (e4) {
                    throw e4 instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + v3 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + c2 + "' at position " + n2 + " in string " + t2);
              }
              u5 = o2, h2 = true;
            }
          }
          var g2 = a2;
          h2 || (u5 = o2);
          var y3 = o2 - u5 - l2;
          if (0 === y3) g2 = a2;
          else if (y3 > 0) {
            var d2 = e3.TEN.pow(y3);
            g2 = a2.divide(d2);
          } else if (y3 < 0) {
            var _2 = e3.TEN.pow(-y3);
            g2 = a2.multiply(_2);
          }
          return r2 ? g2.negate() : g2;
        } }, { key: "createNaN", value: function() {
          return new e3(A.NaN, A.NaN);
        } }, { key: "copy", value: function(t2) {
          return new e3(t2);
        } }, { key: "magnitude", value: function(t2) {
          var e4 = Math.abs(t2), n2 = Math.log(e4) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e4 && (i2 += 1), i2;
        } }, { key: "stringOfChar", value: function(t2, e4) {
          for (var n2 = new st(), i2 = 0; i2 < e4; i2++) n2.append(t2);
          return n2.toString();
        } }]), e3;
      }();
      ut.PI = new ut(3.141592653589793, 12246467991473532e-32), ut.TWO_PI = new ut(6.283185307179586, 24492935982947064e-32), ut.PI_2 = new ut(1.5707963267948966, 6123233995736766e-32), ut.E = new ut(2.718281828459045, 14456468917292502e-32), ut.NaN = new ut(A.NaN, A.NaN), ut.EPS = 123259516440783e-46, ut.SPLIT = 134217729, ut.MAX_PRINT_DIGITS = 32, ut.TEN = ut.valueOf(10), ut.ONE = ut.valueOf(1), ut.SCI_NOT_EXPONENT_CHAR = "E", ut.SCI_NOT_ZERO = "0.0E0";
      var lt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "orientationIndex", value: function(t2, n2, i2) {
          var r2 = e3.orientationIndexFilter(t2, n2, i2);
          if (r2 <= 1) return r2;
          var s2 = ut.valueOf(n2.x).selfAdd(-t2.x), a2 = ut.valueOf(n2.y).selfAdd(-t2.y), o2 = ut.valueOf(i2.x).selfAdd(-n2.x), u5 = ut.valueOf(i2.y).selfAdd(-n2.y);
          return s2.selfMultiply(u5).selfSubtract(a2.selfMultiply(o2)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof ut && arguments[2] instanceof ut && arguments[0] instanceof ut && arguments[1] instanceof ut) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3], r2 = t2.multiply(i2).selfSubtract(e4.multiply(n2));
            return r2.signum();
          }
          if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = arguments[3], l2 = ut.valueOf(s2), h2 = ut.valueOf(a2), c2 = ut.valueOf(o2), f2 = ut.valueOf(u5), v3 = l2.multiply(f2).selfSubtract(h2.multiply(c2));
            return v3.signum();
          }
        } }, { key: "intersection", value: function(t2, e4, n2, i2) {
          var r2 = new ut(t2.y).selfSubtract(e4.y), s2 = new ut(e4.x).selfSubtract(t2.x), a2 = new ut(t2.x).selfMultiply(e4.y).selfSubtract(new ut(e4.x).selfMultiply(t2.y)), o2 = new ut(n2.y).selfSubtract(i2.y), u5 = new ut(i2.x).selfSubtract(n2.x), l2 = new ut(n2.x).selfMultiply(i2.y).selfSubtract(new ut(i2.x).selfMultiply(n2.y)), h2 = s2.multiply(l2).selfSubtract(u5.multiply(a2)), c2 = o2.multiply(a2).selfSubtract(r2.multiply(l2)), f2 = r2.multiply(u5).selfSubtract(o2.multiply(s2)), v3 = h2.selfDivide(f2).doubleValue(), g2 = c2.selfDivide(f2).doubleValue();
          return A.isNaN(v3) || A.isInfinite(v3) || A.isNaN(g2) || A.isInfinite(g2) ? null : new X(v3, g2);
        } }, { key: "orientationIndexFilter", value: function(t2, n2, i2) {
          var r2 = null, s2 = (t2.x - i2.x) * (n2.y - i2.y), a2 = (t2.y - i2.y) * (n2.x - i2.x), o2 = s2 - a2;
          if (s2 > 0) {
            if (a2 <= 0) return e3.signum(o2);
            r2 = s2 + a2;
          } else {
            if (!(s2 < 0)) return e3.signum(o2);
            if (a2 >= 0) return e3.signum(o2);
            r2 = -s2 - a2;
          }
          var u5 = e3.DP_SAFE_EPSILON * r2;
          return o2 >= u5 || -o2 >= u5 ? e3.signum(o2) : 2;
        } }, { key: "signum", value: function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        } }]), e3;
      }();
      lt.DP_SAFE_EPSILON = 1e-15;
      var ht = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "getM", value: function(t2) {
          if (this.hasM()) {
            var e4 = this.getDimension() - this.getMeasures();
            return this.getOrdinate(t2, e4);
          }
          return A.NaN;
        } }, { key: "setOrdinate", value: function(t2, e4, n2) {
        } }, { key: "getZ", value: function(t2) {
          return this.hasZ() ? this.getOrdinate(t2, 2) : A.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(t2, e4) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(t2) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(t2) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(t2) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(t2) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [I];
        } }]), e3;
      }();
      ht.X = 0, ht.Y = 1, ht.Z = 2, ht.M = 3;
      var ct = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "index", value: function(t2, e4, n2) {
          return lt.orientationIndex(t2, e4, n2);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0], n2 = t2.length - 1;
            if (n2 < 3) throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var i2 = t2[0], r2 = 0, s2 = 1; s2 <= n2; s2++) {
              var a2 = t2[s2];
              a2.y > i2.y && (i2 = a2, r2 = s2);
            }
            var o2 = r2;
            do {
              (o2 -= 1) < 0 && (o2 = n2);
            } while (t2[o2].equals2D(i2) && o2 !== r2);
            var u5 = r2;
            do {
              u5 = (u5 + 1) % n2;
            } while (t2[u5].equals2D(i2) && u5 !== r2);
            var l2 = t2[o2], h2 = t2[u5];
            if (l2.equals2D(i2) || h2.equals2D(i2) || l2.equals2D(h2)) return false;
            var c2 = e3.index(l2, i2, h2), f2 = null;
            return f2 = 0 === c2 ? l2.x > h2.x : c2 > 0, f2;
          }
          if (rt(arguments[0], ht)) {
            var v3 = arguments[0], g2 = v3.size() - 1;
            if (g2 < 3) throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var y3 = v3.getCoordinate(0), d2 = 0, _2 = 1; _2 <= g2; _2++) {
              var p2 = v3.getCoordinate(_2);
              p2.y > y3.y && (y3 = p2, d2 = _2);
            }
            var k2 = null, x3 = d2;
            do {
              (x3 -= 1) < 0 && (x3 = g2), k2 = v3.getCoordinate(x3);
            } while (k2.equals2D(y3) && x3 !== d2);
            var I2 = null, E2 = d2;
            do {
              E2 = (E2 + 1) % g2, I2 = v3.getCoordinate(E2);
            } while (I2.equals2D(y3) && E2 !== d2);
            if (k2.equals2D(y3) || I2.equals2D(y3) || k2.equals2D(I2)) return false;
            var N2 = e3.index(k2, y3, I2);
            return 0 === N2 ? k2.x > I2.x : N2 > 0;
          }
        } }]), e3;
      }();
      ct.CLOCKWISE = -1, ct.RIGHT = ct.CLOCKWISE, ct.COUNTERCLOCKWISE = 1, ct.LEFT = ct.COUNTERCLOCKWISE, ct.COLLINEAR = 0, ct.STRAIGHT = ct.COLLINEAR;
      var ft = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(t2, e4) {
          var n2 = this.getRightmostSideOfSegment(t2, e4);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e4 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          G.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e4 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = ct.index(this._minCoord, n2, e4), r2 = false;
          (e4.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === ct.COUNTERCLOCKWISE || e4.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === ct.CLOCKWISE) && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(t2, e4) {
          var n2 = t2.getEdge().getCoordinates();
          if (e4 < 0 || e4 + 1 >= n2.length) return -1;
          if (n2[e4].y === n2[e4 + 1].y) return -1;
          var i2 = $.LEFT;
          return n2[e4].y < n2[e4 + 1].y && (i2 = $.RIGHT), i2;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(t2) {
          for (var e4 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e4.length - 1; n2++) (null === this._minCoord || e4[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e4[n2]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(t2) {
          for (var e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          G.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === $.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]), e3;
      }(), vt = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2(e4, n2) {
          var i2;
          return t(this, s2), (i2 = r2.call(this, n2 ? e4 + " [ " + n2 + " ]" : e4)).pt = n2 ? new X(n2) : void 0, i2.name = Object.keys({ TopologyException: s2 })[0], i2;
        }
        return n(s2, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]), s2;
      }(D2), gt = function() {
        function e3() {
          t(this, e3), this.array = [];
        }
        return n(e3, [{ key: "addLast", value: function(t2) {
          this.array.push(t2);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }]), e3;
      }(), yt = function(e3, r2) {
        i(a2, e3);
        var s2 = c(a2);
        function a2(e4) {
          var n2;
          return t(this, a2), (n2 = s2.call(this)).array = [], e4 instanceof Z && n2.addAll(e4), n2;
        }
        return n(a2, [{ key: "interfaces_", get: function() {
          return [nt, Z];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(t2) {
          return 1 === arguments.length ? this.array.push(t2) : this.array.splice(arguments[0], 0, arguments[1]), true;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(t2) {
          var e4, n2 = d(t2);
          try {
            for (n2.s(); !(e4 = n2.n()).done; ) {
              var i2 = e4.value;
              this.array.push(i2);
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
        } }, { key: "set", value: function(t2, e4) {
          var n2 = this.array[t2];
          return this.array[t2] = e4, n2;
        } }, { key: "iterator", value: function() {
          return new dt(this);
        } }, { key: "get", value: function(t2) {
          if (t2 < 0 || t2 >= this.size()) throw new et();
          return this.array[t2];
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }, { key: "sort", value: function(t2) {
          t2 ? this.array.sort(function(e4, n2) {
            return t2.compare(e4, n2);
          }) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(t2) {
          for (var e4 = 0, n2 = this.array.length; e4 < n2; e4++) if (this.array[e4] === t2) return !!this.array.splice(e4, 1);
          return false;
        } }, { key: r2, value: function() {
          return this.array.values();
        } }]), a2;
      }(nt, Symbol.iterator), dt = function() {
        function e3(n2) {
          t(this, e3), this.arrayList = n2, this.position = 0;
        }
        return n(e3, [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new j();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(t2) {
          return this.arrayList.set(this.position - 1, t2);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]), e3;
      }(), _t = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "clearVisitedEdges", value: function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(t2) {
          for (var e4 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e4 = i2;
              break;
            }
          }
          if (null === e4) throw new vt("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e4);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            s2.setVisited(true), this.copySymDepths(s2);
          }
        } }, { key: "computeDepth", value: function(t2) {
          this.clearVisitedEdges();
          var e4 = this._finder.getEdge();
          e4.getNode(), e4.getLabel(), e4.setEdgeDepths($.RIGHT, t2), this.copySymDepths(e4), this.computeDepths(e4);
        } }, { key: "create", value: function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e4 = t2.next();
            e4.getDepth($.RIGHT) >= 1 && e4.getDepth($.LEFT) <= 0 && !e4.isInteriorAreaEdge() && e4.setInResult(true);
          }
        } }, { key: "computeDepths", value: function(t2) {
          var e4 = new J(), n2 = new gt(), i2 = t2.getNode();
          for (n2.addLast(i2), e4.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e4.add(r2), this.computeNodeDepth(r2);
            for (var s2 = r2.getEdges().iterator(); s2.hasNext(); ) {
              var a2 = s2.next().getSym();
              if (!a2.isVisited()) {
                var o2 = a2.getNode();
                e4.contains(o2) || (n2.addLast(o2), e4.add(o2));
              }
            }
          }
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this._rightMostCoord.x < e4._rightMostCoord.x ? -1 : this._rightMostCoord.x > e4._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            for (var t2 = new U(), e4 = this._dirEdgeList.iterator(); e4.hasNext(); ) for (var n2 = e4.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++) t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        } }, { key: "addReachable", value: function(t2) {
          var e4 = new it();
          for (e4.add(t2); !e4.empty(); ) {
            var n2 = e4.pop();
            this.add(n2, e4);
          }
        } }, { key: "copySymDepths", value: function(t2) {
          var e4 = t2.getSym();
          e4.setDepth($.LEFT, t2.getDepth($.RIGHT)), e4.setDepth($.RIGHT, t2.getDepth($.LEFT));
        } }, { key: "add", value: function(t2, e4) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e4.push(r2);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new yt(), this._nodes = new yt(), this._rightMostCoord = null, this._env = null, this._finder = new ft();
        } }]), e3;
      }(), pt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "intersection", value: function(t2, e4, n2, i2) {
          var r2 = t2.x < e4.x ? t2.x : e4.x, s2 = t2.y < e4.y ? t2.y : e4.y, a2 = t2.x > e4.x ? t2.x : e4.x, o2 = t2.y > e4.y ? t2.y : e4.y, u5 = n2.x < i2.x ? n2.x : i2.x, l2 = n2.y < i2.y ? n2.y : i2.y, h2 = n2.x > i2.x ? n2.x : i2.x, c2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((r2 > u5 ? r2 : u5) + (a2 < h2 ? a2 : h2)) / 2, v3 = ((s2 > l2 ? s2 : l2) + (o2 < c2 ? o2 : c2)) / 2, g2 = t2.x - f2, y3 = t2.y - v3, d2 = e4.x - f2, _2 = e4.y - v3, p2 = n2.x - f2, m2 = n2.y - v3, k2 = i2.x - f2, x3 = i2.y - v3, I2 = y3 - _2, E2 = d2 - g2, N2 = g2 * _2 - d2 * y3, T2 = m2 - x3, S2 = k2 - p2, L2 = p2 * x3 - k2 * m2, C3 = I2 * S2 - T2 * E2, R2 = (E2 * L2 - S2 * N2) / C3, w2 = (T2 * N2 - I2 * L2) / C3;
          return A.isNaN(R2) || A.isInfinite(R2) || A.isNaN(w2) || A.isInfinite(w2) ? null : new X(R2 + f2, w2 + v3);
        } }]), e3;
      }(), mt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "arraycopy", value: function(t2, e4, n2, i2, r2) {
          for (var s2 = 0, a2 = e4; a2 < e4 + r2; a2++) n2[i2 + s2] = t2[a2], s2++;
        } }, { key: "getProperty", value: function(t2) {
          return { "line.separator": "\n" }[t2];
        } }]), e3;
      }(), kt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "log10", value: function(t2) {
          var n2 = Math.log(t2);
          return A.isInfinite(n2) || A.isNaN(n2) ? n2 : n2 / e3.LOG_10;
        } }, { key: "min", value: function(t2, e4, n2, i2) {
          var r2 = t2;
          return e4 < r2 && (r2 = e4), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        } }, { key: "clamp", value: function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
            return t2 < e4 ? e4 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            return i2 < r2 ? r2 : i2 > s2 ? s2 : i2;
          }
        } }, { key: "wrap", value: function(t2, e4) {
          return t2 < 0 ? e4 - -t2 % e4 : t2 % e4;
        } }, { key: "max", value: function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = t2;
            return e4 > i2 && (i2 = e4), n2 > i2 && (i2 = n2), i2;
          }
          if (4 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3], u5 = r2;
            return s2 > u5 && (u5 = s2), a2 > u5 && (u5 = a2), o2 > u5 && (u5 = o2), u5;
          }
        } }, { key: "average", value: function(t2, e4) {
          return (t2 + e4) / 2;
        } }]), e3;
      }();
      kt.LOG_10 = Math.log(10);
      var xt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "segmentToSegment", value: function(t2, n2, i2, r2) {
          if (t2.equals(n2)) return e3.pointToSegment(t2, i2, r2);
          if (i2.equals(r2)) return e3.pointToSegment(r2, t2, n2);
          var s2 = false;
          if (U.intersects(t2, n2, i2, r2)) {
            var a2 = (n2.x - t2.x) * (r2.y - i2.y) - (n2.y - t2.y) * (r2.x - i2.x);
            if (0 === a2) s2 = true;
            else {
              var o2 = (t2.y - i2.y) * (r2.x - i2.x) - (t2.x - i2.x) * (r2.y - i2.y), u5 = ((t2.y - i2.y) * (n2.x - t2.x) - (t2.x - i2.x) * (n2.y - t2.y)) / a2, l2 = o2 / a2;
              (l2 < 0 || l2 > 1 || u5 < 0 || u5 > 1) && (s2 = true);
            }
          } else s2 = true;
          return s2 ? kt.min(e3.pointToSegment(t2, i2, r2), e3.pointToSegment(n2, i2, r2), e3.pointToSegment(i2, t2, n2), e3.pointToSegment(r2, t2, n2)) : 0;
        } }, { key: "pointToSegment", value: function(t2, e4, n2) {
          if (e4.x === n2.x && e4.y === n2.y) return t2.distance(e4);
          var i2 = (n2.x - e4.x) * (n2.x - e4.x) + (n2.y - e4.y) * (n2.y - e4.y), r2 = ((t2.x - e4.x) * (n2.x - e4.x) + (t2.y - e4.y) * (n2.y - e4.y)) / i2;
          if (r2 <= 0) return t2.distance(e4);
          if (r2 >= 1) return t2.distance(n2);
          var s2 = ((e4.y - t2.y) * (n2.x - e4.x) - (e4.x - t2.x) * (n2.y - e4.y)) / i2;
          return Math.abs(s2) * Math.sqrt(i2);
        } }, { key: "pointToLinePerpendicular", value: function(t2, e4, n2) {
          var i2 = (n2.x - e4.x) * (n2.x - e4.x) + (n2.y - e4.y) * (n2.y - e4.y), r2 = ((e4.y - t2.y) * (n2.x - e4.x) - (e4.x - t2.x) * (n2.y - e4.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        } }, { key: "pointToSegmentString", value: function(t2, n2) {
          if (0 === n2.length) throw new m("Line array must contain at least one vertex");
          for (var i2 = t2.distance(n2[0]), r2 = 0; r2 < n2.length - 1; r2++) {
            var s2 = e3.pointToSegment(t2, n2[r2], n2[r2 + 1]);
            s2 < i2 && (i2 = s2);
          }
          return i2;
        } }]), e3;
      }(), It = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "create", value: function() {
          if (1 === arguments.length) arguments[0] instanceof Array || rt(arguments[0], ht);
          else if (2 === arguments.length) ;
          else if (3 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            return this.create(t2, e4);
          }
        } }]), e3;
      }(), Et = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "filter", value: function(t2) {
        } }]), e3;
      }(), Nt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "ofLine", value: function(t2) {
          var e4 = t2.size();
          if (e4 <= 1) return 0;
          var n2 = 0, i2 = new X();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, s2 = i2.y, a2 = 1; a2 < e4; a2++) {
            t2.getCoordinate(a2, i2);
            var o2 = i2.x, u5 = i2.y, l2 = o2 - r2, h2 = u5 - s2;
            n2 += Math.sqrt(l2 * l2 + h2 * h2), r2 = o2, s2 = u5;
          }
          return n2;
        } }]), e3;
      }(), Tt = function e3() {
        t(this, e3);
      }, St = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "copyCoord", value: function(t2, e4, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), s2 = 0; s2 < r2; s2++) n2.setOrdinate(i2, s2, t2.getOrdinate(e4, s2));
        } }, { key: "isRing", value: function(t2) {
          var e4 = t2.size();
          return 0 === e4 || !(e4 <= 3) && (t2.getOrdinate(0, ht.X) === t2.getOrdinate(e4 - 1, ht.X) && t2.getOrdinate(0, ht.Y) === t2.getOrdinate(e4 - 1, ht.Y));
        } }, { key: "scroll", value: function() {
          if (2 === arguments.length) {
            if (rt(arguments[0], ht) && Number.isInteger(arguments[1])) {
              var t2 = arguments[0], n2 = arguments[1];
              e3.scroll(t2, n2, e3.isRing(t2));
            } else if (rt(arguments[0], ht) && arguments[1] instanceof X) {
              var i2 = arguments[0], r2 = arguments[1], s2 = e3.indexOf(r2, i2);
              if (s2 <= 0) return null;
              e3.scroll(i2, s2);
            }
          } else if (3 === arguments.length) {
            var a2 = arguments[0], o2 = arguments[1], u5 = arguments[2], l2 = o2;
            if (l2 <= 0) return null;
            for (var h2 = a2.copy(), c2 = u5 ? a2.size() - 1 : a2.size(), f2 = 0; f2 < c2; f2++) for (var v3 = 0; v3 < a2.getDimension(); v3++) a2.setOrdinate(f2, v3, h2.getOrdinate((o2 + f2) % c2, v3));
            if (u5) for (var g2 = 0; g2 < a2.getDimension(); g2++) a2.setOrdinate(c2, g2, a2.getOrdinate(0, g2));
          }
        } }, { key: "isEqual", value: function(t2, e4) {
          var n2 = t2.size();
          if (n2 !== e4.size()) return false;
          for (var i2 = Math.min(t2.getDimension(), e4.getDimension()), r2 = 0; r2 < n2; r2++) for (var s2 = 0; s2 < i2; s2++) {
            var a2 = t2.getOrdinate(r2, s2), o2 = e4.getOrdinate(r2, s2);
            if (t2.getOrdinate(r2, s2) !== e4.getOrdinate(r2, s2) && (!A.isNaN(a2) || !A.isNaN(o2))) return false;
          }
          return true;
        } }, { key: "minCoordinateIndex", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return e3.minCoordinateIndex(t2, 0, t2.size() - 1);
          }
          if (3 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s2 = -1, a2 = null, o2 = i2; o2 <= r2; o2++) {
              var u5 = n2.getCoordinate(o2);
              (null === a2 || a2.compareTo(u5) > 0) && (a2 = u5, s2 = o2);
            }
            return s2;
          }
        } }, { key: "extend", value: function(t2, n2, i2) {
          var r2 = t2.create(i2, n2.getDimension()), s2 = n2.size();
          if (e3.copy(n2, 0, r2, 0, s2), s2 > 0) for (var a2 = s2; a2 < i2; a2++) e3.copy(n2, s2 - 1, r2, a2, 1);
          return r2;
        } }, { key: "reverse", value: function(t2) {
          for (var n2 = t2.size() - 1, i2 = Math.trunc(n2 / 2), r2 = 0; r2 <= i2; r2++) e3.swap(t2, r2, n2 - r2);
        } }, { key: "swap", value: function(t2, e4, n2) {
          if (e4 === n2) return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e4, i2);
            t2.setOrdinate(e4, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        } }, { key: "copy", value: function(t2, n2, i2, r2, s2) {
          for (var a2 = 0; a2 < s2; a2++) e3.copyCoord(t2, n2 + a2, i2, r2 + a2);
        } }, { key: "ensureValidRing", value: function(t2, n2) {
          var i2 = n2.size();
          return 0 === i2 ? n2 : i2 <= 3 ? e3.createClosedRing(t2, n2, 4) : n2.getOrdinate(0, ht.X) === n2.getOrdinate(i2 - 1, ht.X) && n2.getOrdinate(0, ht.Y) === n2.getOrdinate(i2 - 1, ht.Y) ? n2 : e3.createClosedRing(t2, n2, i2 + 1);
        } }, { key: "indexOf", value: function(t2, e4) {
          for (var n2 = 0; n2 < e4.size(); n2++) if (t2.x === e4.getOrdinate(n2, ht.X) && t2.y === e4.getOrdinate(n2, ht.Y)) return n2;
          return -1;
        } }, { key: "createClosedRing", value: function(t2, n2, i2) {
          var r2 = t2.create(i2, n2.getDimension()), s2 = n2.size();
          e3.copy(n2, 0, r2, 0, s2);
          for (var a2 = s2; a2 < i2; a2++) e3.copy(n2, 0, r2, a2, 1);
          return r2;
        } }, { key: "minCoordinate", value: function(t2) {
          for (var e4 = null, n2 = 0; n2 < t2.size(); n2++) {
            var i2 = t2.getCoordinate(n2);
            (null === e4 || e4.compareTo(i2) > 0) && (e4 = i2);
          }
          return e4;
        } }]), e3;
      }(), Lt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "toDimensionSymbol", value: function(t2) {
          switch (t2) {
            case e3.FALSE:
              return e3.SYM_FALSE;
            case e3.TRUE:
              return e3.SYM_TRUE;
            case e3.DONTCARE:
              return e3.SYM_DONTCARE;
            case e3.P:
              return e3.SYM_P;
            case e3.L:
              return e3.SYM_L;
            case e3.A:
              return e3.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        } }, { key: "toDimensionValue", value: function(t2) {
          switch (ot.toUpperCase(t2)) {
            case e3.SYM_FALSE:
              return e3.FALSE;
            case e3.SYM_TRUE:
              return e3.TRUE;
            case e3.SYM_DONTCARE:
              return e3.DONTCARE;
            case e3.SYM_P:
              return e3.P;
            case e3.SYM_L:
              return e3.L;
            case e3.SYM_A:
              return e3.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        } }]), e3;
      }();
      Lt.P = 0, Lt.L = 1, Lt.A = 2, Lt.FALSE = -1, Lt.TRUE = -2, Lt.DONTCARE = -3, Lt.SYM_FALSE = "F", Lt.SYM_TRUE = "T", Lt.SYM_DONTCARE = "*", Lt.SYM_P = "0", Lt.SYM_L = "1", Lt.SYM_A = "2";
      var Ct = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "filter", value: function(t2) {
        } }]), e3;
      }(), Rt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "filter", value: function(t2, e4) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]), e3;
      }(), wt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new U() : this._points.expandEnvelope(new U());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new a2(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            if (!this.isEquivalentClass(t2)) return false;
            var n2 = t2;
            if (this._points.size() !== n2._points.size()) return false;
            for (var i2 = 0; i2 < this._points.size(); i2++) if (!this.equal(this._points.getCoordinate(i2), n2._points.getCoordinate(i2), e4)) return false;
            return true;
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var t2 = 0; t2 < Math.trunc(this._points.size() / 2); t2++) {
            var e4 = this._points.size() - 1 - t2;
            if (!this._points.getCoordinate(t2).equals(this._points.getCoordinate(e4))) {
              if (this._points.getCoordinate(t2).compareTo(this._points.getCoordinate(e4)) > 0) {
                var n2 = this._points.copy();
                St.reverse(n2), this._points = n2;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? Lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var t2 = this._points.copy();
          return St.reverse(t2), this.getFactory().createLineString(t2);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Nt.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = t2, n2 = 0, i2 = 0; n2 < this._points.size() && i2 < e4._points.size(); ) {
              var r2 = this._points.getCoordinate(n2).compareTo(e4._points.getCoordinate(i2));
              if (0 !== r2) return r2;
              n2++, i2++;
            }
            return n2 < this._points.size() ? 1 : i2 < e4._points.size() ? -1 : 0;
          }
          if (2 === arguments.length) {
            var s3 = arguments[0], a3 = arguments[1], o2 = s3;
            return a3.compare(this._points, o2._points);
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) for (var t2 = arguments[0], e4 = 0; e4 < this._points.size(); e4++) t2.filter(this._points.getCoordinate(e4));
          else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (0 === this._points.size()) return null;
            for (var i2 = 0; i2 < this._points.size() && (n2.filter(this._points, i2), !n2.isDone()); i2++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            var r2 = arguments[0];
            r2.filter(this);
          } else if (rt(arguments[0], k)) {
            var s3 = arguments[0];
            s3.filter(this);
          }
        } }, { key: "getBoundary", value: function() {
          throw new W();
        } }, { key: "isEquivalentClass", value: function(t2) {
          return t2 instanceof a2;
        } }, { key: "getCoordinateN", value: function(t2) {
          return this._points.getCoordinate(t2);
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return 0 === this._points.size();
        } }, { key: "init", value: function(t2) {
          if (null === t2 && (t2 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t2.size()) throw new m("Invalid number of points in LineString (found " + t2.size() + " - must be 0 or >= 2)");
          this._points = t2;
        } }, { key: "isCoordinate", value: function(t2) {
          for (var e4 = 0; e4 < this._points.size(); e4++) if (this._points.getCoordinate(e4).equals(t2)) return true;
          return false;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(t2) {
          return this.getFactory().createPoint(this._points.getCoordinate(t2));
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            V.constructor_.call(this, e4), this.init(t2);
          }
        } }]), a2;
      }(V), Ot = function e3() {
        t(this, e3);
      }, bt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new U();
          var t2 = new U();
          return t2.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t2;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new a2(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            return !!this.isEquivalentClass(t2) && (!(!this.isEmpty() || !t2.isEmpty()) || this.isEmpty() === t2.isEmpty() && this.equal(t2.getCoordinate(), this.getCoordinate(), e4));
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e4 = t2;
            return this.getCoordinate().compareTo(e4.getCoordinate());
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = n2;
            return i2.compare(this._coordinates, r2._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) {
            var t2 = arguments[0];
            if (this.isEmpty()) return null;
            t2.filter(this.getCoordinate());
          } else if (rt(arguments[0], Rt)) {
            var e4 = arguments[0];
            if (this.isEmpty()) return null;
            e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            var n2 = arguments[0];
            n2.filter(this);
          } else if (rt(arguments[0], k)) {
            var i2 = arguments[0];
            i2.filter(this);
          }
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return 0 === this._coordinates.size();
        } }, { key: "init", value: function(t2) {
          null === t2 && (t2 = this.getFactory().getCoordinateSequenceFactory().create([])), G.isTrue(t2.size() <= 1), this._coordinates = t2;
        } }, { key: "isSimple", value: function() {
          return true;
        } }, { key: "interfaces_", get: function() {
          return [Ot];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var t2 = arguments[0], e4 = arguments[1];
          V.constructor_.call(this, e4), this.init(t2);
        } }]), a2;
      }(V), Mt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return Math.abs(e3.ofRingSigned(t2));
          }
          if (rt(arguments[0], ht)) {
            var n2 = arguments[0];
            return Math.abs(e3.ofRingSigned(n2));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3) return 0;
            for (var e4 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, s2 = t2[i2 + 1].y, a2 = t2[i2 - 1].y;
              e4 += r2 * (a2 - s2);
            }
            return e4 / 2;
          }
          if (rt(arguments[0], ht)) {
            var o2 = arguments[0], u5 = o2.size();
            if (u5 < 3) return 0;
            var l2 = new X(), h2 = new X(), c2 = new X();
            o2.getCoordinate(0, h2), o2.getCoordinate(1, c2);
            var f2 = h2.x;
            c2.x -= f2;
            for (var v3 = 0, g2 = 1; g2 < u5 - 1; g2++) l2.y = h2.y, h2.x = c2.x, h2.y = c2.y, o2.getCoordinate(g2 + 1, c2), c2.x -= f2, v3 += h2.x * (l2.y - c2.y);
            return v3 / 2;
          }
        } }]), e3;
      }(), At = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "sort", value: function() {
          var t2 = arguments, e4 = arguments[0];
          if (1 === arguments.length) e4.sort(function(t3, e6) {
            return t3.compareTo(e6);
          });
          else if (2 === arguments.length) e4.sort(function(e6, n3) {
            return t2[1].compare(e6, n3);
          });
          else if (3 === arguments.length) {
            var n2 = e4.slice(arguments[1], arguments[2]);
            n2.sort();
            var i2 = e4.slice(0, arguments[1]).concat(n2, e4.slice(arguments[2], e4.length));
            e4.splice(0, e4.length);
            var r2, s2 = d(i2);
            try {
              for (s2.s(); !(r2 = s2.n()).done; ) {
                var a2 = r2.value;
                e4.push(a2);
              }
            } catch (t3) {
              s2.e(t3);
            } finally {
              s2.f();
            }
          } else if (4 === arguments.length) {
            var o2 = e4.slice(arguments[1], arguments[2]);
            o2.sort(function(e6, n3) {
              return t2[3].compare(e6, n3);
            });
            var u5 = e4.slice(0, arguments[1]).concat(o2, e4.slice(arguments[2], e4.length));
            e4.splice(0, e4.length);
            var l2, h2 = d(u5);
            try {
              for (h2.s(); !(l2 = h2.n()).done; ) {
                var c2 = l2.value;
                e4.push(c2);
              }
            } catch (t3) {
              h2.e(t3);
            } finally {
              h2.f();
            }
          }
        } }, { key: "asList", value: function(t2) {
          var e4, n2 = new yt(), i2 = d(t2);
          try {
            for (i2.s(); !(e4 = i2.n()).done; ) {
              var r2 = e4.value;
              n2.add(r2);
            }
          } catch (t3) {
            i2.e(t3);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "copyOf", value: function(t2, e4) {
          return t2.slice(0, e4);
        } }]), e3;
      }(), Pt = function e3() {
        t(this, e3);
      }, Dt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var t2 = new Array(this.getNumPoints()).fill(null), e4 = -1, n2 = this._shell.getCoordinates(), i2 = 0; i2 < n2.length; i2++) t2[++e4] = n2[i2];
          for (var r2 = 0; r2 < this._holes.length; r2++) for (var s3 = this._holes[r2].getCoordinates(), a3 = 0; a3 < s3.length; a3++) t2[++e4] = s3[a3];
          return t2;
        } }, { key: "getArea", value: function() {
          var t2 = 0;
          t2 += Mt.ofRing(this._shell.getCoordinateSequence());
          for (var e4 = 0; e4 < this._holes.length; e4++) t2 -= Mt.ofRing(this._holes[e4].getCoordinateSequence());
          return t2;
        } }, { key: "copyInternal", value: function() {
          for (var t2 = this._shell.copy(), e4 = new Array(this._holes.length).fill(null), n2 = 0; n2 < this._holes.length; n2++) e4[n2] = this._holes[n2].copy();
          return new a2(t2, e4, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (0 !== this.getNumInteriorRing()) return false;
          if (null === this._shell) return false;
          if (5 !== this._shell.getNumPoints()) return false;
          for (var t2 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n2 = 0; n2 < 5; n2++) {
            var i2 = t2.getX(n2);
            if (i2 !== e4.getMinX() && i2 !== e4.getMaxX()) return false;
            var r2 = t2.getY(n2);
            if (r2 !== e4.getMinY() && r2 !== e4.getMaxY()) return false;
          }
          for (var s3 = t2.getX(0), a3 = t2.getY(0), o2 = 1; o2 <= 4; o2++) {
            var u5 = t2.getX(o2), l2 = t2.getY(o2);
            if (u5 !== s3 === (l2 !== a3)) return false;
            s3 = u5, a3 = l2;
          }
          return true;
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            if (!this.isEquivalentClass(t2)) return false;
            var n2 = t2, i2 = this._shell, s3 = n2._shell;
            if (!i2.equalsExact(s3, e4)) return false;
            if (this._holes.length !== n2._holes.length) return false;
            for (var o2 = 0; o2 < this._holes.length; o2++) if (!this._holes[o2].equalsExact(n2._holes[o2], e4)) return false;
            return true;
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (0 === arguments.length) {
            this._shell = this.normalized(this._shell, true);
            for (var t2 = 0; t2 < this._holes.length; t2++) this._holes[t2] = this.normalized(this._holes[t2], false);
            At.sort(this._holes);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            if (e4.isEmpty()) return null;
            var i2 = e4.getCoordinateSequence(), r2 = St.minCoordinateIndex(i2, 0, i2.size() - 2);
            St.scroll(i2, r2, true), ct.isCCW(i2) === n2 && St.reverse(i2);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var t2 = this.getExteriorRing().reverse(), e4 = new Array(this.getNumInteriorRing()).fill(null), n2 = 0; n2 < e4.length; n2++) e4[n2] = this.getInteriorRingN(n2).reverse();
          return this.getFactory().createPolygon(t2, e4);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var t2 = 0;
          t2 += this._shell.getLength();
          for (var e4 = 0; e4 < this._holes.length; e4++) t2 += this._holes[e4].getLength();
          return t2;
        } }, { key: "getNumPoints", value: function() {
          for (var t2 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++) t2 += this._holes[e4].getNumPoints();
          return t2;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(t2, e4) {
          var n2 = t2.copy();
          return this.normalize(n2, e4), n2;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e4 = this._shell, n2 = t2._shell;
            return e4.compareToSameClass(n2);
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s3 = i2, a3 = this._shell, o2 = s3._shell, u5 = a3.compareToSameClass(o2, r2);
            if (0 !== u5) return u5;
            for (var l2 = this.getNumInteriorRing(), h2 = s3.getNumInteriorRing(), c2 = 0; c2 < l2 && c2 < h2; ) {
              var f2 = this.getInteriorRingN(c2), v3 = s3.getInteriorRingN(c2), g2 = f2.compareToSameClass(v3, r2);
              if (0 !== g2) return g2;
              c2++;
            }
            return c2 < l2 ? 1 : c2 < h2 ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) {
            var t2 = arguments[0];
            this._shell.apply(t2);
            for (var e4 = 0; e4 < this._holes.length; e4++) this._holes[e4].apply(t2);
          } else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (this._shell.apply(n2), !n2.isDone()) for (var i2 = 0; i2 < this._holes.length && (this._holes[i2].apply(n2), !n2.isDone()); i2++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            var r2 = arguments[0];
            r2.filter(this);
          } else if (rt(arguments[0], k)) {
            var s3 = arguments[0];
            s3.filter(this), this._shell.apply(s3);
            for (var a3 = 0; a3 < this._holes.length; a3++) this._holes[a3].apply(s3);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var t2 = new Array(this._holes.length + 1).fill(null);
          t2[0] = this._shell;
          for (var e4 = 0; e4 < this._holes.length; e4++) t2[e4 + 1] = this._holes[e4];
          return t2.length <= 1 ? this.getFactory().createLinearRing(t2[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t2);
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(t2) {
          return this._holes[t2];
        } }, { key: "interfaces_", get: function() {
          return [Pt];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          if (V.constructor_.call(this, n2), null === t2 && (t2 = this.getFactory().createLinearRing()), null === e4 && (e4 = []), V.hasNullElements(e4)) throw new m("holes must not contain null elements");
          if (t2.isEmpty() && V.hasNonEmptyElements(e4)) throw new m("shell is empty but holes are not");
          this._shell = t2, this._holes = e4;
        } }]), a2;
      }(V), Ft = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2() {
          return t(this, r2), n2.apply(this, arguments);
        }
        return r2;
      }(K), Gt = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2(e4) {
          var n2;
          return t(this, s2), (n2 = r2.call(this)).array = [], e4 instanceof Z && n2.addAll(e4), n2;
        }
        return n(s2, [{ key: "contains", value: function(t2) {
          var e4, n2 = d(this.array);
          try {
            for (n2.s(); !(e4 = n2.n()).done; ) {
              if (0 === e4.value.compareTo(t2)) return true;
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
          return false;
        } }, { key: "add", value: function(t2) {
          if (this.contains(t2)) return false;
          for (var e4 = 0, n2 = this.array.length; e4 < n2; e4++) {
            if (1 === this.array[e4].compareTo(t2)) return !!this.array.splice(e4, 0, t2);
          }
          return this.array.push(t2), true;
        } }, { key: "addAll", value: function(t2) {
          var e4, n2 = d(t2);
          try {
            for (n2.s(); !(e4 = n2.n()).done; ) {
              var i2 = e4.value;
              this.add(i2);
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new W();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new qt(this.array);
        } }]), s2;
      }(Ft), qt = function() {
        function e3(n2) {
          t(this, e3), this.array = n2, this.position = 0;
        }
        return n(e3, [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new j();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new W();
        } }]), e3;
      }(), Yt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "computeEnvelopeInternal", value: function() {
          for (var t2 = new U(), e4 = 0; e4 < this._geometries.length; e4++) t2.expandToInclude(this._geometries[e4].getEnvelopeInternal());
          return t2;
        } }, { key: "getGeometryN", value: function(t2) {
          return this._geometries[t2];
        } }, { key: "getCoordinates", value: function() {
          for (var t2 = new Array(this.getNumPoints()).fill(null), e4 = -1, n2 = 0; n2 < this._geometries.length; n2++) for (var i2 = this._geometries[n2].getCoordinates(), r2 = 0; r2 < i2.length; r2++) t2[++e4] = i2[r2];
          return t2;
        } }, { key: "getArea", value: function() {
          for (var t2 = 0, e4 = 0; e4 < this._geometries.length; e4++) t2 += this._geometries[e4].getArea();
          return t2;
        } }, { key: "copyInternal", value: function() {
          for (var t2 = new Array(this._geometries.length).fill(null), e4 = 0; e4 < t2.length; e4++) t2[e4] = this._geometries[e4].copy();
          return new a2(t2, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            if (!this.isEquivalentClass(t2)) return false;
            var n2 = t2;
            if (this._geometries.length !== n2._geometries.length) return false;
            for (var i2 = 0; i2 < this._geometries.length; i2++) if (!this._geometries[i2].equalsExact(n2._geometries[i2], e4)) return false;
            return true;
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var t2 = 0; t2 < this._geometries.length; t2++) this._geometries[t2].normalize();
          At.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var t2 = Lt.FALSE, e4 = 0; e4 < this._geometries.length; e4++) t2 = Math.max(t2, this._geometries[e4].getBoundaryDimension());
          return t2;
        } }, { key: "reverseInternal", value: function() {
          for (var t2 = this._geometries.length, e4 = new yt(t2), n2 = 0; n2 < t2; n2++) e4.add(this._geometries[n2].reverse());
          return this.getFactory().buildGeometry(e4);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var t2 = Lt.FALSE, e4 = 0; e4 < this._geometries.length; e4++) t2 = Math.max(t2, this._geometries[e4].getDimension());
          return t2;
        } }, { key: "getLength", value: function() {
          for (var t2 = 0, e4 = 0; e4 < this._geometries.length; e4++) t2 += this._geometries[e4].getLength();
          return t2;
        } }, { key: "getNumPoints", value: function() {
          for (var t2 = 0, e4 = 0; e4 < this._geometries.length; e4++) t2 += this._geometries[e4].getNumPoints();
          return t2;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e4 = new Gt(At.asList(this._geometries)), n2 = new Gt(At.asList(t2._geometries));
            return this.compare(e4, n2);
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], s3 = i2, a3 = this.getNumGeometries(), o2 = s3.getNumGeometries(), u5 = 0; u5 < a3 && u5 < o2; ) {
              var l2 = this.getGeometryN(u5), h2 = s3.getGeometryN(u5), c2 = l2.compareToSameClass(h2, r2);
              if (0 !== c2) return c2;
              u5++;
            }
            return u5 < a3 ? 1 : u5 < o2 ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) for (var t2 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++) this._geometries[e4].apply(t2);
          else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (0 === this._geometries.length) return null;
            for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n2), !n2.isDone()); i2++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            var r2 = arguments[0];
            r2.filter(this);
            for (var s3 = 0; s3 < this._geometries.length; s3++) this._geometries[s3].apply(r2);
          } else if (rt(arguments[0], k)) {
            var a3 = arguments[0];
            a3.filter(this);
            for (var o2 = 0; o2 < this._geometries.length; o2++) this._geometries[o2].apply(a3);
          }
        } }, { key: "getBoundary", value: function() {
          return V.checkNotGeometryCollection(this), G.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var t2 = 0; t2 < this._geometries.length; t2++) if (!this._geometries[t2].isEmpty()) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            if (V.constructor_.call(this, e4), null === t2 && (t2 = []), V.hasNullElements(t2)) throw new m("geometries must not contain null elements");
            this._geometries = t2;
          }
        } }]), a2;
      }(V), zt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "copyInternal", value: function() {
          for (var t2 = new Array(this._geometries.length).fill(null), e4 = 0; e4 < t2.length; e4++) t2[e4] = this._geometries[e4].copy();
          return new a2(t2, this._factory);
        } }, { key: "isValid", value: function() {
          return true;
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            return !!this.isEquivalentClass(t2) && f(r(a2.prototype), "equalsExact", this).call(this, t2, e4);
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (1 === arguments.length && Number.isInteger(arguments[0])) {
            var t2 = arguments[0];
            return this._geometries[t2].getCoordinate();
          }
          return f(r(a2.prototype), "getCoordinate", this).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [Ot];
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          Yt.constructor_.call(this, t2, e4);
        } }]), a2;
      }(Yt), Xt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "copyInternal", value: function() {
          return new a2(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || f(r(a2.prototype), "isClosed", this).call(this);
        } }, { key: "reverseInternal", value: function() {
          var t2 = this._points.copy();
          return St.reverse(t2), this.getFactory().createLinearRing(t2);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !f(r(a2.prototype), "isClosed", this).call(this)) throw new m("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < a2.MINIMUM_VALID_SIZE) throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          wt.constructor_.call(this, t2, e4), this.validateConstruction();
        } }]), a2;
      }(wt);
      Xt.MINIMUM_VALID_SIZE = 4;
      var Bt = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "setOrdinate", value: function(t2, e4) {
          switch (t2) {
            case s2.X:
              this.x = e4;
              break;
            case s2.Y:
              this.y = e4;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        } }, { key: "getZ", value: function() {
          return X.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(t2) {
          switch (t2) {
            case s2.X:
              return this.x;
            case s2.Y:
              return this.y;
          }
          throw new m("Invalid ordinate index: " + t2);
        } }, { key: "setZ", value: function(t2) {
          throw new m("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new s2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) X.constructor_.call(this);
          else if (1 === arguments.length) {
            if (arguments[0] instanceof s2) {
              var t2 = arguments[0];
              X.constructor_.call(this, t2.x, t2.y);
            } else if (arguments[0] instanceof X) {
              var e4 = arguments[0];
              X.constructor_.call(this, e4.x, e4.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            X.constructor_.call(this, n2, i2, X.NULL_ORDINATE);
          }
        } }]), s2;
      }(X);
      Bt.X = 0, Bt.Y = 1, Bt.Z = -1, Bt.M = -1;
      var Ut = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(t2, e4) {
          switch (t2) {
            case s2.X:
              this.x = e4;
              break;
            case s2.Y:
              this.y = e4;
              break;
            case s2.M:
              this._m = e4;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        } }, { key: "setM", value: function(t2) {
          this._m = t2;
        } }, { key: "getZ", value: function() {
          return X.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(t2) {
          switch (t2) {
            case s2.X:
              return this.x;
            case s2.Y:
              return this.y;
            case s2.M:
              return this._m;
          }
          throw new m("Invalid ordinate index: " + t2);
        } }, { key: "setZ", value: function(t2) {
          throw new m("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new s2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.getZ(), this._m = t2.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof s2) {
              var t2 = arguments[0];
              X.constructor_.call(this, t2.x, t2.y), this._m = t2._m;
            } else if (arguments[0] instanceof X) {
              var e4 = arguments[0];
              X.constructor_.call(this, e4.x, e4.y), this._m = this.getM();
            }
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r3 = arguments[2];
            X.constructor_.call(this, n2, i2, X.NULL_ORDINATE), this._m = r3;
          }
        } }]), s2;
      }(X);
      Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2;
      var Vt = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(t2, e4) {
          switch (t2) {
            case X.X:
              this.x = e4;
              break;
            case X.Y:
              this.y = e4;
              break;
            case X.Z:
              this.z = e4;
              break;
            case X.M:
              this._m = e4;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        } }, { key: "setM", value: function(t2) {
          this._m = t2;
        } }, { key: "getOrdinate", value: function(t2) {
          switch (t2) {
            case X.X:
              return this.x;
            case X.Y:
              return this.y;
            case X.Z:
              return this.getZ();
            case X.M:
              return this.getM();
          }
          throw new m("Invalid ordinate index: " + t2);
        } }, { key: "copy", value: function() {
          return new s2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.getZ(), this._m = t2.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof s2) {
              var t2 = arguments[0];
              X.constructor_.call(this, t2), this._m = t2._m;
            } else if (arguments[0] instanceof X) {
              var e4 = arguments[0];
              X.constructor_.call(this, e4), this._m = this.getM();
            }
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r3 = arguments[2], a2 = arguments[3];
            X.constructor_.call(this, n2, i2, r3), this._m = a2;
          }
        } }]), s2;
      }(X), Ht = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "measures", value: function(t2) {
          return t2 instanceof Bt ? 0 : t2 instanceof Ut || t2 instanceof Vt ? 1 : 0;
        } }, { key: "dimension", value: function(t2) {
          return t2 instanceof Bt ? 2 : t2 instanceof Ut ? 3 : t2 instanceof Vt ? 4 : 3;
        } }, { key: "create", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return e3.create(t2, 0);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return 2 === n2 ? new Bt() : 3 === n2 && 0 === i2 ? new X() : 3 === n2 && 1 === i2 ? new Ut() : 4 === n2 && 1 === i2 ? new Vt() : new X();
          }
        } }]), e3;
      }(), Zt = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "getCoordinate", value: function(t2) {
          return this.get(t2);
        } }, { key: "addAll", value: function() {
          if (2 === arguments.length && "boolean" == typeof arguments[1] && rt(arguments[0], Z)) {
            for (var t2 = arguments[0], e4 = arguments[1], n2 = false, i2 = t2.iterator(); i2.hasNext(); ) this.add(i2.next(), e4), n2 = true;
            return n2;
          }
          return f(r(a2.prototype), "addAll", this).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var t2 = f(r(a2.prototype), "clone", this).call(this), e4 = 0; e4 < this.size(); e4++) t2.add(e4, this.get(e4).clone());
          return t2;
        } }, { key: "toCoordinateArray", value: function() {
          if (0 === arguments.length) return this.toArray(a2.coordArrayType);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            if (t2) return this.toArray(a2.coordArrayType);
            for (var e4 = this.size(), n2 = new Array(e4).fill(null), i2 = 0; i2 < e4; i2++) n2[i2] = this.get(e4 - i2 - 1);
            return n2;
          }
        } }, { key: "add", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return f(r(a2.prototype), "add", this).call(this, t2);
          }
          if (2 === arguments.length) {
            if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var e4 = arguments[0], n2 = arguments[1];
              return this.add(e4, n2, true), true;
            }
            if (arguments[0] instanceof X && "boolean" == typeof arguments[1]) {
              var i2 = arguments[0], s3 = arguments[1];
              if (!s3 && this.size() >= 1) {
                var o2 = this.get(this.size() - 1);
                if (o2.equals2D(i2)) return null;
              }
              f(r(a2.prototype), "add", this).call(this, i2);
            } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
              var u5 = arguments[0], l2 = arguments[1];
              return this.add(u5, l2), true;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var h2 = arguments[0], c2 = arguments[1], v3 = arguments[2];
              if (v3) for (var g2 = 0; g2 < h2.length; g2++) this.add(h2[g2], c2);
              else for (var y3 = h2.length - 1; y3 >= 0; y3--) this.add(h2[y3], c2);
              return true;
            }
            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof X) {
              var d2 = arguments[0], _2 = arguments[1], p2 = arguments[2];
              if (!p2) {
                var m2 = this.size();
                if (m2 > 0) {
                  if (d2 > 0) {
                    var k2 = this.get(d2 - 1);
                    if (k2.equals2D(_2)) return null;
                  }
                  if (d2 < m2) {
                    var x3 = this.get(d2);
                    if (x3.equals2D(_2)) return null;
                  }
                }
              }
              f(r(a2.prototype), "add", this).call(this, d2, _2);
            }
          } else if (4 === arguments.length) {
            var I2 = arguments[0], E2 = arguments[1], N2 = arguments[2], T2 = arguments[3], S2 = 1;
            N2 > T2 && (S2 = -1);
            for (var L2 = N2; L2 !== T2; L2 += S2) this.add(I2[L2], E2);
            return true;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var t2 = this.get(0).copy();
            this.add(t2, false);
          }
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.ensureCapacity(t2.length), this.add(t2, true);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this.ensureCapacity(e4.length), this.add(e4, n2);
          }
        } }]), a2;
      }(yt);
      Zt.coordArrayType = new Array(0).fill(null);
      var jt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "isRing", value: function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        } }, { key: "ptNotInList", value: function(t2, n2) {
          for (var i2 = 0; i2 < t2.length; i2++) {
            var r2 = t2[i2];
            if (e3.indexOf(r2, n2) < 0) return r2;
          }
          return null;
        } }, { key: "scroll", value: function(t2, n2) {
          var i2 = e3.indexOf(n2, t2);
          if (i2 < 0) return null;
          var r2 = new Array(t2.length).fill(null);
          mt.arraycopy(t2, i2, r2, 0, t2.length - i2), mt.arraycopy(t2, 0, r2, t2.length - i2, i2), mt.arraycopy(r2, 0, t2, 0, t2.length);
        } }, { key: "equals", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            if (t2 === e4) return true;
            if (null === t2 || null === e4) return false;
            if (t2.length !== e4.length) return false;
            for (var n2 = 0; n2 < t2.length; n2++) if (!t2[n2].equals(e4[n2])) return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            if (i2 === r2) return true;
            if (null === i2 || null === r2) return false;
            if (i2.length !== r2.length) return false;
            for (var a2 = 0; a2 < i2.length; a2++) if (0 !== s2.compare(i2[a2], r2[a2])) return false;
            return true;
          }
        } }, { key: "intersection", value: function(t2, e4) {
          for (var n2 = new Zt(), i2 = 0; i2 < t2.length; i2++) e4.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        } }, { key: "measures", value: function(t2) {
          if (null === t2 || 0 === t2.length) return 0;
          var e4, n2 = 0, i2 = d(t2);
          try {
            for (i2.s(); !(e4 = i2.n()).done; ) {
              var r2 = e4.value;
              n2 = Math.max(n2, Ht.measures(r2));
            }
          } catch (t3) {
            i2.e(t3);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "hasRepeatedPoints", value: function(t2) {
          for (var e4 = 1; e4 < t2.length; e4++) if (t2[e4 - 1].equals(t2[e4])) return true;
          return false;
        } }, { key: "removeRepeatedPoints", value: function(t2) {
          return e3.hasRepeatedPoints(t2) ? new Zt(t2, false).toCoordinateArray() : t2;
        } }, { key: "reverse", value: function(t2) {
          for (var e4 = t2.length - 1, n2 = Math.trunc(e4 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e4 - i2], t2[e4 - i2] = r2;
          }
        } }, { key: "removeNull", value: function(t2) {
          for (var e4 = 0, n2 = 0; n2 < t2.length; n2++) null !== t2[n2] && e4++;
          var i2 = new Array(e4).fill(null);
          if (0 === e4) return i2;
          for (var r2 = 0, s2 = 0; s2 < t2.length; s2++) null !== t2[s2] && (i2[r2++] = t2[s2]);
          return i2;
        } }, { key: "copyDeep", value: function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++) e4[n2] = t2[n2].copy();
            return e4;
          }
          if (5 === arguments.length) for (var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3], o2 = arguments[4], u5 = 0; u5 < o2; u5++) s2[a2 + u5] = i2[r2 + u5].copy();
        } }, { key: "isEqualReversed", value: function(t2, e4) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e4[t2.length - n2 - 1];
            if (0 !== i2.compareTo(r2)) return false;
          }
          return true;
        } }, { key: "envelope", value: function(t2) {
          for (var e4 = new U(), n2 = 0; n2 < t2.length; n2++) e4.expandToInclude(t2[n2]);
          return e4;
        } }, { key: "toCoordinateArray", value: function(t2) {
          return t2.toArray(e3.coordArrayType);
        } }, { key: "dimension", value: function(t2) {
          if (null === t2 || 0 === t2.length) return 3;
          var e4, n2 = 0, i2 = d(t2);
          try {
            for (i2.s(); !(e4 = i2.n()).done; ) {
              var r2 = e4.value;
              n2 = Math.max(n2, Ht.dimension(r2));
            }
          } catch (t3) {
            i2.e(t3);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(t2, e4) {
          return e4.length >= t2 ? e4 : [];
        } }, { key: "indexOf", value: function(t2, e4) {
          for (var n2 = 0; n2 < e4.length; n2++) if (t2.equals(e4[n2])) return n2;
          return -1;
        } }, { key: "increasingDirection", value: function(t2) {
          for (var e4 = 0; e4 < Math.trunc(t2.length / 2); e4++) {
            var n2 = t2.length - 1 - e4, i2 = t2[e4].compareTo(t2[n2]);
            if (0 !== i2) return i2;
          }
          return 1;
        } }, { key: "compare", value: function(t2, e4) {
          for (var n2 = 0; n2 < t2.length && n2 < e4.length; ) {
            var i2 = t2[n2].compareTo(e4[n2]);
            if (0 !== i2) return i2;
            n2++;
          }
          return n2 < e4.length ? -1 : n2 < t2.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(t2) {
          for (var e4 = null, n2 = 0; n2 < t2.length; n2++) (null === e4 || e4.compareTo(t2[n2]) > 0) && (e4 = t2[n2]);
          return e4;
        } }, { key: "extract", value: function(t2, e4, n2) {
          e4 = kt.clamp(e4, 0, t2.length);
          var i2 = (n2 = kt.clamp(n2, -1, t2.length)) - e4 + 1;
          n2 < 0 && (i2 = 0), e4 >= t2.length && (i2 = 0), n2 < e4 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2) return r2;
          for (var s2 = 0, a2 = e4; a2 <= n2; a2++) r2[s2++] = t2[a2];
          return r2;
        } }]), e3;
      }(), Wt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "compare", value: function(t2, e4) {
          var n2 = t2, i2 = e4;
          return jt.compare(n2, i2);
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }]), e3;
      }(), Kt = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "compare", value: function(t2, e4) {
          var n2 = t2, i2 = e4;
          if (n2.length < i2.length) return -1;
          if (n2.length > i2.length) return 1;
          if (0 === n2.length) return 0;
          var r2 = jt.compare(n2, i2);
          return jt.isEqualReversed(n2, i2) ? 0 : r2;
        } }, { key: "OLDcompare", value: function(t2, e4) {
          var n2 = t2, i2 = e4;
          if (n2.length < i2.length) return -1;
          if (n2.length > i2.length) return 1;
          if (0 === n2.length) return 0;
          for (var r2 = jt.increasingDirection(n2), s2 = jt.increasingDirection(i2), a2 = r2 > 0 ? 0 : n2.length - 1, o2 = s2 > 0 ? 0 : n2.length - 1, u5 = 0; u5 < n2.length; u5++) {
            var l2 = n2[a2].compareTo(i2[o2]);
            if (0 !== l2) return l2;
            a2 += r2, o2 += s2;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }]), e3;
      }();
      jt.ForwardComparator = Wt, jt.BidirectionalComparator = Kt, jt.coordArrayType = new Array(0).fill(null);
      var Jt = function() {
        function e3(n2) {
          t(this, e3), this.str = n2;
        }
        return n(e3, [{ key: "append", value: function(t2) {
          this.str += t2;
        } }, { key: "setCharAt", value: function(t2, e4) {
          this.str = this.str.substr(0, t2) + e4 + this.str.substr(t2 + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]), e3;
      }(), Qt = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getM", value: function(t2) {
          return this.hasM() ? this._coordinates[t2].getM() : A.NaN;
        } }, { key: "setOrdinate", value: function(t2, e4, n2) {
          switch (e4) {
            case ht.X:
              this._coordinates[t2].x = n2;
              break;
            case ht.Y:
              this._coordinates[t2].y = n2;
              break;
            default:
              this._coordinates[t2].setOrdinate(e4, n2);
          }
        } }, { key: "getZ", value: function(t2) {
          return this.hasZ() ? this._coordinates[t2].getZ() : A.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(t2, e4) {
          switch (e4) {
            case ht.X:
              return this._coordinates[t2].x;
            case ht.Y:
              return this._coordinates[t2].y;
            default:
              return this._coordinates[t2].getOrdinate(e4);
          }
        } }, { key: "getCoordinate", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            n2.setCoordinate(this._coordinates[e4]);
          }
        } }, { key: "getCoordinateCopy", value: function(t2) {
          var e4 = this.createCoordinate();
          return e4.setCoordinate(this._coordinates[t2]), e4;
        } }, { key: "createCoordinate", value: function() {
          return Ht.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(t2) {
          return this._coordinates[t2].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(t2) {
          for (var e4 = 0; e4 < this._coordinates.length; e4++) t2.expandToInclude(this._coordinates[e4]);
          return t2;
        } }, { key: "copy", value: function() {
          for (var t2 = new Array(this.size()).fill(null), n2 = 0; n2 < this._coordinates.length; n2++) {
            var i2 = this.createCoordinate();
            i2.setCoordinate(this._coordinates[n2]), t2[n2] = i2;
          }
          return new e3(t2, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var t2 = new Jt(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e4 = 1; e4 < this._coordinates.length; e4++) t2.append(", "), t2.append(this._coordinates[e4]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        } }, { key: "getY", value: function(t2) {
          return this._coordinates[t2].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [ht, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              e3.constructor_.call(this, t2, jt.dimension(t2), jt.measures(t2));
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this._coordinates = new Array(n2).fill(null);
              for (var i2 = 0; i2 < n2; i2++) this._coordinates[i2] = new X();
            } else if (rt(arguments[0], ht)) {
              var r2 = arguments[0];
              if (null === r2) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = r2.getDimension(), this._measures = r2.getMeasures(), this._coordinates = new Array(r2.size()).fill(null);
              for (var s2 = 0; s2 < this._coordinates.length; s2++) this._coordinates[s2] = r2.getCoordinateCopy(s2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var a2 = arguments[0], o2 = arguments[1];
              e3.constructor_.call(this, a2, o2, jt.measures(a2));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var u5 = arguments[0], l2 = arguments[1];
              this._coordinates = new Array(u5).fill(null), this._dimension = l2;
              for (var h2 = 0; h2 < u5; h2++) this._coordinates[h2] = Ht.create(l2);
            }
          } else if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var c2 = arguments[0], f2 = arguments[1], v3 = arguments[2];
              this._dimension = f2, this._measures = v3, this._coordinates = null === c2 ? new Array(0).fill(null) : c2;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var g2 = arguments[0], y3 = arguments[1], d2 = arguments[2];
              this._coordinates = new Array(g2).fill(null), this._dimension = y3, this._measures = d2;
              for (var _2 = 0; _2 < g2; _2++) this._coordinates[_2] = this.createCoordinate();
            }
          }
        } }]), e3;
      }(), $t = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "readResolve", value: function() {
          return e3.instance();
        } }, { key: "create", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new Qt(t2);
            }
            if (rt(arguments[0], ht)) {
              var e4 = arguments[0];
              return new Qt(e4);
            }
          } else {
            if (2 === arguments.length) {
              var n2 = arguments[0], i2 = arguments[1];
              return i2 > 3 && (i2 = 3), i2 < 2 && (i2 = 2), new Qt(n2, i2);
            }
            if (3 === arguments.length) {
              var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = s2 - a2;
              return a2 > 1 && (a2 = 1), o2 > 3 && (o2 = 3), o2 < 2 && (o2 = 2), new Qt(r2, o2 + a2, a2);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [It, E];
        } }], [{ key: "instance", value: function() {
          return e3.instanceObject;
        } }]), e3;
      }();
      $t.instanceObject = new $t();
      var te = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "copyInternal", value: function() {
          for (var t2 = new Array(this._geometries.length).fill(null), e4 = 0; e4 < t2.length; e4++) t2[e4] = this._geometries[e4].copy();
          return new a2(t2, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            return !!this.isEquivalentClass(t2) && f(r(a2.prototype), "equalsExact", this).call(this, t2, e4);
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var t2 = new yt(), e4 = 0; e4 < this._geometries.length; e4++) for (var n2 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n2.getNumGeometries(); i2++) t2.add(n2.getGeometryN(i2));
          var r2 = new Array(t2.size()).fill(null);
          return this.getFactory().createMultiLineString(t2.toArray(r2));
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [Pt];
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          Yt.constructor_.call(this, t2, e4);
        } }]), a2;
      }(Yt), ee = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]), e3;
      }(), ne = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), (e4 = r2.call(this)).map = /* @__PURE__ */ new Map(), e4;
        }
        return n(s2, [{ key: "get", value: function(t2) {
          return this.map.get(t2) || null;
        } }, { key: "put", value: function(t2, e4) {
          return this.map.set(t2, e4), e4;
        } }, { key: "values", value: function() {
          for (var t2 = new yt(), e4 = this.map.values(), n2 = e4.next(); !n2.done; ) t2.add(n2.value), n2 = e4.next();
          return t2;
        } }, { key: "entrySet", value: function() {
          var t2 = new J();
          return this.map.entries().forEach(function(e4) {
            return t2.add(e4);
          }), t2;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]), s2;
      }(ee), ie = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "equals", value: function(t2) {
          if (!(t2 instanceof e3)) return false;
          var n2 = t2;
          return this._modelType === n2._modelType && this._scale === n2._scale;
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e4.getMaximumSignificantDigits();
          return at.compare(n2, i2);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === e3.FLOATING || this._modelType === e3.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var t2 = "UNKNOWN";
          return this._modelType === e3.FLOATING ? t2 = "Floating" : this._modelType === e3.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === e3.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        } }, { key: "makePrecise", value: function() {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            if (A.isNaN(t2)) return t2;
            if (this._modelType === e3.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === e3.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof X) {
            var n2 = arguments[0];
            if (this._modelType === e3.FLOATING) return null;
            n2.x = this.makePrecise(n2.x), n2.y = this.makePrecise(n2.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var t2 = 16;
          return this._modelType === e3.FLOATING ? t2 = 16 : this._modelType === e3.FLOATING_SINGLE ? t2 = 6 : this._modelType === e3.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        } }, { key: "setScale", value: function(t2) {
          this._scale = Math.abs(t2);
        } }, { key: "interfaces_", get: function() {
          return [E, x2];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = e3.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof re) {
              var t2 = arguments[0];
              this._modelType = t2, t2 === e3.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = e3.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof e3) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(t2, e4) {
          return t2.compareTo(e4) >= 0 ? t2 : e4;
        } }]), e3;
      }(), re = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "readResolve", value: function() {
          return e3.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var t2 = arguments[0];
          this._name = t2, e3.nameToTypeMap.put(t2, this);
        } }]), e3;
      }();
      re.nameToTypeMap = new ne(), ie.Type = re, ie.FIXED = new re("FIXED"), ie.FLOATING = new re("FLOATING"), ie.FLOATING_SINGLE = new re("FLOATING SINGLE"), ie.maximumPreciseValue = 9007199254740992;
      var se = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "copyInternal", value: function() {
          for (var t2 = new Array(this._geometries.length).fill(null), e4 = 0; e4 < t2.length; e4++) t2[e4] = this._geometries[e4].copy();
          return new a2(t2, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t2 = arguments[0], e4 = arguments[1];
            return !!this.isEquivalentClass(t2) && f(r(a2.prototype), "equalsExact", this).call(this, t2, e4);
          }
          return f(r(a2.prototype), "equalsExact", this).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? Lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return false;
          for (var t2 = 0; t2 < this._geometries.length; t2++) if (!this._geometries[t2].isClosed()) return false;
          return true;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new W();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          Yt.constructor_.call(this, t2, e4);
        } }]), a2;
      }(Yt), ae = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "createEmpty", value: function(t2) {
          switch (t2) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new m("Invalid dimension: " + t2);
          }
        } }, { key: "toGeometry", value: function(t2) {
          return t2.isNull() ? this.createPoint() : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new X(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new X(t2.getMinX(), t2.getMinY()), new X(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new X(t2.getMinX(), t2.getMinY()), new X(t2.getMinX(), t2.getMaxY()), new X(t2.getMaxX(), t2.getMaxY()), new X(t2.getMaxX(), t2.getMinY()), new X(t2.getMinX(), t2.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLineString(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (rt(arguments[0], ht)) {
              var e4 = arguments[0];
              return new wt(e4, this);
            }
          }
        } }, { key: "createMultiLineString", value: function() {
          if (0 === arguments.length) return new se(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new se(t2, this);
          }
        } }, { key: "buildGeometry", value: function(t2) {
          for (var n2 = null, i2 = false, r2 = false, s2 = t2.iterator(); s2.hasNext(); ) {
            var a2 = s2.next(), o2 = a2.getTypeCode();
            null === n2 && (n2 = o2), o2 !== n2 && (i2 = true), a2 instanceof Yt && (r2 = true);
          }
          if (null === n2) return this.createGeometryCollection();
          if (i2 || r2) return this.createGeometryCollection(e3.toGeometryArray(t2));
          var u5 = t2.iterator().next();
          if (t2.size() > 1) {
            if (u5 instanceof Dt) return this.createMultiPolygon(e3.toPolygonArray(t2));
            if (u5 instanceof wt) return this.createMultiLineString(e3.toLineStringArray(t2));
            if (u5 instanceof bt) return this.createMultiPoint(e3.toPointArray(t2));
            G.shouldNeverReachHere("Unhandled geometry type: " + u5.getGeometryType());
          }
          return u5;
        } }, { key: "createMultiPointFromCoords", value: function(t2) {
          return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
        } }, { key: "createPoint", value: function() {
          if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t2 = arguments[0];
              return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (rt(arguments[0], ht)) {
              var e4 = arguments[0];
              return new bt(e4, this);
            }
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (0 === arguments.length) return this.createPolygon(null, null);
          if (1 === arguments.length) {
            if (rt(arguments[0], ht)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e4 = arguments[0];
              return this.createPolygon(this.createLinearRing(e4));
            }
            if (arguments[0] instanceof Xt) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return new Dt(i2, r2, this);
          }
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          if (0 === arguments.length) return new Yt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Yt(t2, this);
          }
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (rt(arguments[0], ht)) {
              var e4 = arguments[0];
              return new Xt(e4, this);
            }
          }
        } }, { key: "createMultiPolygon", value: function() {
          if (0 === arguments.length) return new te(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new te(t2, this);
          }
        } }, { key: "createMultiPoint", value: function() {
          if (0 === arguments.length) return new zt(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new zt(t2, this);
            }
            if (rt(arguments[0], ht)) {
              var e4 = arguments[0];
              if (null === e4) return this.createMultiPoint(new Array(0).fill(null));
              for (var n2 = new Array(e4.size()).fill(null), i2 = 0; i2 < e4.size(); i2++) {
                var r2 = this.getCoordinateSequenceFactory().create(1, e4.getDimension(), e4.getMeasures());
                St.copy(e4, i2, r2, 0, 1), n2[i2] = this.createPoint(r2);
              }
              return this.createMultiPoint(n2);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) e3.constructor_.call(this, new ie(), 0);
          else if (1 === arguments.length) {
            if (rt(arguments[0], It)) {
              var t2 = arguments[0];
              e3.constructor_.call(this, new ie(), 0, t2);
            } else if (arguments[0] instanceof ie) {
              var n2 = arguments[0];
              e3.constructor_.call(this, n2, 0, e3.getDefaultCoordinateSequenceFactory());
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            e3.constructor_.call(this, i2, r2, e3.getDefaultCoordinateSequenceFactory());
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this._precisionModel = s2, this._coordinateSequenceFactory = o2, this._SRID = a2;
          }
        } }, { key: "toMultiPolygonArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toGeometryArray", value: function(t2) {
          if (null === t2) return null;
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return $t.instance();
        } }, { key: "toMultiLineStringArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toLineStringArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toMultiPointArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toLinearRingArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toPointArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "toPolygonArray", value: function(t2) {
          var e4 = new Array(t2.size()).fill(null);
          return t2.toArray(e4);
        } }, { key: "createPointFromInternalCoord", value: function(t2, e4) {
          return e4.getPrecisionModel().makePrecise(t2), e4.getFactory().createPoint(t2);
        } }]), e3;
      }(), oe = "XY", ue = "XYZ", le = "XYM", he = "XYZM", ce2 = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, fe = "EMPTY", ve = 1, ge = 2, ye = 3, de2 = 4, _e = 5, pe = 6, me = {};
      for (var ke in ce2) me[ke] = ce2[ke].toUpperCase();
      var xe = function() {
        function e3(n2) {
          t(this, e3), this.wkt = n2, this.index_ = -1;
        }
        return n(e3, [{ key: "isAlpha_", value: function(t2) {
          return t2 >= "a" && t2 <= "z" || t2 >= "A" && t2 <= "Z";
        } }, { key: "isNumeric_", value: function(t2, e4) {
          return t2 >= "0" && t2 <= "9" || "." == t2 && !(void 0 !== e4 && e4);
        } }, { key: "isWhiteSpace_", value: function(t2) {
          return " " == t2 || "	" == t2 || "\r" == t2 || "\n" == t2;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var t2, e4 = this.nextChar_(), n2 = this.index_, i2 = e4;
          if ("(" == e4) t2 = ge;
          else if ("," == e4) t2 = _e;
          else if (")" == e4) t2 = ye;
          else if (this.isNumeric_(e4) || "-" == e4) t2 = de2, i2 = this.readNumber_();
          else if (this.isAlpha_(e4)) t2 = ve, i2 = this.readText_();
          else {
            if (this.isWhiteSpace_(e4)) return this.nextToken();
            if ("" !== e4) throw new Error("Unexpected character: " + e4);
            t2 = pe;
          }
          return { position: n2, value: i2, type: t2 };
        } }, { key: "readNumber_", value: function() {
          var t2, e4 = this.index_, n2 = false, i2 = false;
          do {
            "." == t2 ? n2 = true : "e" != t2 && "E" != t2 || (i2 = true), t2 = this.nextChar_();
          } while (this.isNumeric_(t2, n2) || !i2 && ("e" == t2 || "E" == t2) || i2 && ("-" == t2 || "+" == t2));
          return parseFloat(this.wkt.substring(e4, this.index_--));
        } }, { key: "readText_", value: function() {
          var t2, e4 = this.index_;
          do {
            t2 = this.nextChar_();
          } while (this.isAlpha_(t2));
          return this.wkt.substring(e4, this.index_--).toUpperCase();
        } }]), e3;
      }(), Ie = function() {
        function e3(n2, i2) {
          t(this, e3), this.lexer_ = n2, this.token_, this.layout_ = oe, this.factory = i2;
        }
        return n(e3, [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(t2) {
          return this.token_.type == t2;
        } }, { key: "match", value: function(t2) {
          var e4 = this.isTokenType(t2);
          return e4 && this.consume_(), e4;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var t2 = oe, e4 = this.token_;
          if (this.isTokenType(ve)) {
            var n2 = e4.value;
            "Z" === n2 ? t2 = ue : "M" === n2 ? t2 = le : "ZM" === n2 && (t2 = he), t2 !== oe && this.consume_();
          }
          return t2;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(ge)) {
            var t2 = [];
            do {
              t2.push(this.parseGeometry_());
            } while (this.match(_e));
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(ge)) {
            var t2 = this.parsePoint_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(ge)) {
            var t2 = this.parsePointList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(ge)) {
            var t2 = this.parseLineStringTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var t2;
          if (this.match(ge)) {
            if (t2 = this.token_.type == ge ? this.parsePointTextList_() : this.parsePointList_(), this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(ge)) {
            var t2 = this.parseLineStringTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(ge)) {
            var t2 = this.parsePolygonTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var t2 = [], e4 = this.layout_.length, n2 = 0; n2 < e4; ++n2) {
            var i2 = this.token_;
            if (!this.match(de2)) break;
            t2.push(i2.value);
          }
          if (t2.length == e4) return t2;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var t2 = [this.parsePoint_()]; this.match(_e); ) t2.push(this.parsePoint_());
          return t2;
        } }, { key: "parsePointTextList_", value: function() {
          for (var t2 = [this.parsePointText_()]; this.match(_e); ) t2.push(this.parsePointText_());
          return t2;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var t2 = [this.parseLineStringText_()]; this.match(_e); ) t2.push(this.parseLineStringText_());
          return t2;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var t2 = [this.parsePolygonText_()]; this.match(_e); ) t2.push(this.parsePolygonText_());
          return t2;
        } }, { key: "isEmptyGeometry_", value: function() {
          var t2 = this.isTokenType(ve) && this.token_.value == fe;
          return t2 && this.consume_(), t2;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var t2 = this.factory, e4 = function(t3) {
            return o(X, v2(t3));
          }, n2 = function(n3) {
            var i3 = n3.map(function(n4) {
              return t2.createLinearRing(n4.map(e4));
            });
            return i3.length > 1 ? t2.createPolygon(i3[0], i3.slice(1)) : t2.createPolygon(i3[0]);
          }, i2 = this.token_;
          if (this.match(ve)) {
            var r2 = i2.value;
            if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == r2) {
              var s2 = this.parseGeometryCollectionText_();
              return t2.createGeometryCollection(s2);
            }
            switch (r2) {
              case "POINT":
                var a2 = this.parsePointText_();
                return a2 ? t2.createPoint(o(X, v2(a2))) : t2.createPoint();
              case "LINESTRING":
                var u5 = this.parseLineStringText_().map(e4);
                return t2.createLineString(u5);
              case "LINEARRING":
                var l2 = this.parseLineStringText_().map(e4);
                return t2.createLinearRing(l2);
              case "POLYGON":
                var h2 = this.parsePolygonText_();
                return h2 && 0 !== h2.length ? n2(h2) : t2.createPolygon();
              case "MULTIPOINT":
                var c2 = this.parseMultiPointText_();
                if (!c2 || 0 === c2.length) return t2.createMultiPoint();
                var f2 = c2.map(e4).map(function(e6) {
                  return t2.createPoint(e6);
                });
                return t2.createMultiPoint(f2);
              case "MULTILINESTRING":
                var g2 = this.parseMultiLineStringText_().map(function(n3) {
                  return t2.createLineString(n3.map(e4));
                });
                return t2.createMultiLineString(g2);
              case "MULTIPOLYGON":
                var y3 = this.parseMultiPolygonText_();
                if (!y3 || 0 === y3.length) return t2.createMultiPolygon();
                var d2 = y3.map(n2);
                return t2.createMultiPolygon(d2);
              default:
                throw new Error("Invalid geometry type: " + r2);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]), e3;
      }();
      function Ee(t2) {
        if (t2.isEmpty()) return "";
        var e3 = t2.getCoordinate(), n2 = [e3.x, e3.y];
        return void 0 === e3.z || Number.isNaN(e3.z) || n2.push(e3.z), void 0 === e3.m || Number.isNaN(e3.m) || n2.push(e3.m), n2.join(" ");
      }
      function Ne(t2) {
        for (var e3 = t2.getCoordinates().map(function(t3) {
          var e4 = [t3.x, t3.y];
          return void 0 === t3.z || Number.isNaN(t3.z) || e4.push(t3.z), void 0 === t3.m || Number.isNaN(t3.m) || e4.push(t3.m), e4;
        }), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2) n2.push(e3[i2].join(" "));
        return n2.join(", ");
      }
      function Te(t2) {
        var e3 = [];
        e3.push("(" + Ne(t2.getExteriorRing()) + ")");
        for (var n2 = 0, i2 = t2.getNumInteriorRing(); n2 < i2; ++n2) e3.push("(" + Ne(t2.getInteriorRingN(n2)) + ")");
        return e3.join(", ");
      }
      var Se = { Point: Ee, LineString: Ne, LinearRing: Ne, Polygon: Te, MultiPoint: function(t2) {
        for (var e3 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e3.push("(" + Ee(t2.getGeometryN(n2)) + ")");
        return e3.join(", ");
      }, MultiLineString: function(t2) {
        for (var e3 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e3.push("(" + Ne(t2.getGeometryN(n2)) + ")");
        return e3.join(", ");
      }, MultiPolygon: function(t2) {
        for (var e3 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e3.push("(" + Te(t2.getGeometryN(n2)) + ")");
        return e3.join(", ");
      }, GeometryCollection: function(t2) {
        for (var e3 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e3.push(Le(t2.getGeometryN(n2)));
        return e3.join(", ");
      } };
      function Le(t2) {
        var e3 = t2.getGeometryType(), n2 = Se[e3];
        e3 = e3.toUpperCase();
        var i2 = function(t3) {
          var e4 = "";
          if (t3.isEmpty()) return e4;
          var n3 = t3.getCoordinate();
          return void 0 === n3.z || Number.isNaN(n3.z) || (e4 += "Z"), void 0 === n3.m || Number.isNaN(n3.m) || (e4 += "M"), e4;
        }(t2);
        return i2.length > 0 && (e3 += " " + i2), t2.isEmpty() ? e3 + " " + fe : e3 + " (" + n2(t2) + ")";
      }
      var Ce = function() {
        function e3(n2) {
          t(this, e3), this.geometryFactory = n2 || new ae(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }
        return n(e3, [{ key: "read", value: function(t2) {
          var e4 = new xe(t2);
          return new Ie(e4, this.geometryFactory).parse();
        } }, { key: "write", value: function(t2) {
          return Le(t2);
        } }]), e3;
      }(), Re = function() {
        function e3(n2) {
          t(this, e3), this.parser = new Ce(n2);
        }
        return n(e3, [{ key: "write", value: function(t2) {
          return this.parser.write(t2);
        } }], [{ key: "toLineString", value: function(t2, e4) {
          if (2 !== arguments.length) throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e4.x + " " + e4.y + " )";
        } }]), e3;
      }(), we = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getIndexAlongSegment", value: function(t2, e4) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e4];
        } }, { key: "getTopologySummary", value: function() {
          var t2 = new Jt();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        } }, { key: "computeIntersection", value: function(t2, e4, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e4, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e4, n2, i2);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t2 = arguments[0], e4 = this.getEdgeDistance(t2, 0), n2 = this.getEdgeDistance(t2, 1);
            e4 > n2 ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(t2) {
          this._precisionModel = t2;
        } }, { key: "isInteriorIntersection", value: function() {
          if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = 0; e4 < this._result; e4++) if (!this._intPt[e4].equals2D(this._inputLines[t2][0]) && !this._intPt[e4].equals2D(this._inputLines[t2][1])) return true;
            return false;
          }
        } }, { key: "getIntersection", value: function(t2) {
          return this._intPt[t2];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== e3.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(t2, n2) {
          return e3.computeEdgeDistance(this._intPt[n2], this._inputLines[t2][0], this._inputLines[t2][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === e3.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Re.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Re.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(t2, e4) {
          return this._inputLines[t2][e4];
        } }, { key: "isIntersection", value: function(t2) {
          for (var e4 = 0; e4 < this._result; e4++) if (this._intPt[e4].equals2D(t2)) return true;
          return false;
        } }, { key: "getIntersectionAlongSegment", value: function(t2, e4) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e4]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new X(), this._intPt[1] = new X(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(t2, e4, n2) {
          var i2 = Math.abs(n2.x - e4.x), r2 = Math.abs(n2.y - e4.y), s2 = -1;
          if (t2.equals(e4)) s2 = 0;
          else if (t2.equals(n2)) s2 = i2 > r2 ? i2 : r2;
          else {
            var a2 = Math.abs(t2.x - e4.x), o2 = Math.abs(t2.y - e4.y);
            0 !== (s2 = i2 > r2 ? a2 : o2) || t2.equals(e4) || (s2 = Math.max(a2, o2));
          }
          return G.isTrue(!(0 === s2 && !t2.equals(e4)), "Bad distance calculation"), s2;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(t2, e4, n2) {
          var i2 = t2.x - e4.x, r2 = t2.y - e4.y, s2 = Math.sqrt(i2 * i2 + r2 * r2);
          return G.isTrue(!(0 === s2 && !t2.equals(e4)), "Invalid distance calculation"), s2;
        } }]), e3;
      }();
      we.DONT_INTERSECT = 0, we.DO_INTERSECT = 1, we.COLLINEAR = 2, we.NO_INTERSECTION = 0, we.POINT_INTERSECTION = 1, we.COLLINEAR_INTERSECTION = 2;
      var Oe = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          return t(this, a2), s2.call(this);
        }
        return n(a2, [{ key: "isInSegmentEnvelopes", value: function(t2) {
          var e4 = new U(this._inputLines[0][0], this._inputLines[0][1]), n2 = new U(this._inputLines[1][0], this._inputLines[1][1]);
          return e4.contains(t2) && n2.contains(t2);
        } }, { key: "computeIntersection", value: function() {
          if (3 !== arguments.length) return f(r(a2.prototype), "computeIntersection", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          if (this._isProper = false, U.intersects(e4, n2, t2) && 0 === ct.index(e4, n2, t2) && 0 === ct.index(n2, e4, t2)) return this._isProper = true, (t2.equals(e4) || t2.equals(n2)) && (this._isProper = false), this._result = we.POINT_INTERSECTION, null;
          this._result = we.NO_INTERSECTION;
        } }, { key: "intersection", value: function(t2, e4, n2, i2) {
          var r2 = this.intersectionSafe(t2, e4, n2, i2);
          return this.isInSegmentEnvelopes(r2) || (r2 = new X(a2.nearestEndpoint(t2, e4, n2, i2))), null !== this._precisionModel && this._precisionModel.makePrecise(r2), r2;
        } }, { key: "checkDD", value: function(t2, e4, n2, i2, r2) {
          var s3 = lt.intersection(t2, e4, n2, i2), a3 = this.isInSegmentEnvelopes(s3);
          mt.out.println("DD in env = " + a3 + "  --------------------- " + s3), r2.distance(s3) > 1e-4 && mt.out.println("Distance = " + r2.distance(s3));
        } }, { key: "intersectionSafe", value: function(t2, e4, n2, i2) {
          var r2 = pt.intersection(t2, e4, n2, i2);
          return null === r2 && (r2 = a2.nearestEndpoint(t2, e4, n2, i2)), r2;
        } }, { key: "computeCollinearIntersection", value: function(t2, e4, n2, i2) {
          var r2 = U.intersects(t2, e4, n2), s3 = U.intersects(t2, e4, i2), a3 = U.intersects(n2, i2, t2), o2 = U.intersects(n2, i2, e4);
          return r2 && s3 ? (this._intPt[0] = n2, this._intPt[1] = i2, we.COLLINEAR_INTERSECTION) : a3 && o2 ? (this._intPt[0] = t2, this._intPt[1] = e4, we.COLLINEAR_INTERSECTION) : r2 && a3 ? (this._intPt[0] = n2, this._intPt[1] = t2, !n2.equals(t2) || s3 || o2 ? we.COLLINEAR_INTERSECTION : we.POINT_INTERSECTION) : r2 && o2 ? (this._intPt[0] = n2, this._intPt[1] = e4, !n2.equals(e4) || s3 || a3 ? we.COLLINEAR_INTERSECTION : we.POINT_INTERSECTION) : s3 && a3 ? (this._intPt[0] = i2, this._intPt[1] = t2, !i2.equals(t2) || r2 || o2 ? we.COLLINEAR_INTERSECTION : we.POINT_INTERSECTION) : s3 && o2 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || r2 || a3 ? we.COLLINEAR_INTERSECTION : we.POINT_INTERSECTION) : we.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(t2, e4, n2, i2) {
          if (this._isProper = false, !U.intersects(t2, e4, n2, i2)) return we.NO_INTERSECTION;
          var r2 = ct.index(t2, e4, n2), s3 = ct.index(t2, e4, i2);
          if (r2 > 0 && s3 > 0 || r2 < 0 && s3 < 0) return we.NO_INTERSECTION;
          var a3 = ct.index(n2, i2, t2), o2 = ct.index(n2, i2, e4);
          return a3 > 0 && o2 > 0 || a3 < 0 && o2 < 0 ? we.NO_INTERSECTION : 0 === r2 && 0 === s3 && 0 === a3 && 0 === o2 ? this.computeCollinearIntersection(t2, e4, n2, i2) : (0 === r2 || 0 === s3 || 0 === a3 || 0 === o2 ? (this._isProper = false, t2.equals2D(n2) || t2.equals2D(i2) ? this._intPt[0] = t2 : e4.equals2D(n2) || e4.equals2D(i2) ? this._intPt[0] = e4 : 0 === r2 ? this._intPt[0] = new X(n2) : 0 === s3 ? this._intPt[0] = new X(i2) : 0 === a3 ? this._intPt[0] = new X(t2) : 0 === o2 && (this._intPt[0] = new X(e4))) : (this._isProper = true, this._intPt[0] = this.intersection(t2, e4, n2, i2)), we.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(t2, e4, n2, i2) {
          var r2 = t2, s3 = xt.pointToSegment(t2, n2, i2), a3 = xt.pointToSegment(e4, n2, i2);
          return a3 < s3 && (s3 = a3, r2 = e4), (a3 = xt.pointToSegment(n2, t2, e4)) < s3 && (s3 = a3, r2 = n2), (a3 = xt.pointToSegment(i2, t2, e4)) < s3 && (s3 = a3, r2 = i2), r2;
        } }]), a2;
      }(we), be = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "countSegment", value: function(t2, e4) {
          if (t2.x < this._p.x && e4.x < this._p.x) return null;
          if (this._p.x === e4.x && this._p.y === e4.y) return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e4.y === this._p.y) {
            var n2 = t2.x, i2 = e4.x;
            return n2 > i2 && (n2 = e4.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e4.y <= this._p.y || e4.y > this._p.y && t2.y <= this._p.y) {
            var r2 = ct.index(t2, e4, this._p);
            if (r2 === ct.COLLINEAR) return this._isPointOnSegment = true, null;
            e4.y < t2.y && (r2 = -r2), r2 === ct.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== H.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? H.BOUNDARY : this._crossingCount % 2 == 1 ? H.INTERIOR : H.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof X && rt(arguments[1], ht)) {
            for (var t2 = arguments[0], n2 = arguments[1], i2 = new e3(t2), r2 = new X(), s2 = new X(), a2 = 1; a2 < n2.size(); a2++) if (n2.getCoordinate(a2, r2), n2.getCoordinate(a2 - 1, s2), i2.countSegment(r2, s2), i2.isOnSegment()) return i2.getLocation();
            return i2.getLocation();
          }
          if (arguments[0] instanceof X && arguments[1] instanceof Array) {
            for (var o2 = arguments[0], u5 = arguments[1], l2 = new e3(o2), h2 = 1; h2 < u5.length; h2++) {
              var c2 = u5[h2], f2 = u5[h2 - 1];
              if (l2.countSegment(c2, f2), l2.isOnSegment()) return l2.getLocation();
            }
            return l2.getLocation();
          }
        } }]), e3;
      }(), Me = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof X && rt(arguments[1], ht)) {
            for (var t2 = arguments[0], e4 = arguments[1], n2 = new Oe(), i2 = new X(), r2 = new X(), s2 = e4.size(), a2 = 1; a2 < s2; a2++) if (e4.getCoordinate(a2 - 1, i2), e4.getCoordinate(a2, r2), n2.computeIntersection(t2, i2, r2), n2.hasIntersection()) return true;
            return false;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof Array) {
            for (var o2 = arguments[0], u5 = arguments[1], l2 = new Oe(), h2 = 1; h2 < u5.length; h2++) {
              var c2 = u5[h2 - 1], f2 = u5[h2];
              if (l2.computeIntersection(o2, c2, f2), l2.hasIntersection()) return true;
            }
            return false;
          }
        } }, { key: "locateInRing", value: function(t2, e4) {
          return be.locatePointInRing(t2, e4);
        } }, { key: "isInRing", value: function(t2, n2) {
          return e3.locateInRing(t2, n2) !== H.EXTERIOR;
        } }]), e3;
      }(), Ae = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "setAllLocations", value: function(t2) {
          for (var e4 = 0; e4 < this.location.length; e4++) this.location[e4] = t2;
        } }, { key: "isNull", value: function() {
          for (var t2 = 0; t2 < this.location.length; t2++) if (this.location[t2] !== H.NONE) return false;
          return true;
        } }, { key: "setAllLocationsIfNull", value: function(t2) {
          for (var e4 = 0; e4 < this.location.length; e4++) this.location[e4] === H.NONE && (this.location[e4] = t2);
        } }, { key: "isLine", value: function() {
          return 1 === this.location.length;
        } }, { key: "merge", value: function(t2) {
          if (t2.location.length > this.location.length) {
            var e4 = new Array(3).fill(null);
            e4[$.ON] = this.location[$.ON], e4[$.LEFT] = H.NONE, e4[$.RIGHT] = H.NONE, this.location = e4;
          }
          for (var n2 = 0; n2 < this.location.length; n2++) this.location[n2] === H.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var t2 = this.location[$.LEFT];
          this.location[$.LEFT] = this.location[$.RIGHT], this.location[$.RIGHT] = t2;
        } }, { key: "toString", value: function() {
          var t2 = new st();
          return this.location.length > 1 && t2.append(H.toLocationSymbol(this.location[$.LEFT])), t2.append(H.toLocationSymbol(this.location[$.ON])), this.location.length > 1 && t2.append(H.toLocationSymbol(this.location[$.RIGHT])), t2.toString();
        } }, { key: "setLocations", value: function(t2, e4, n2) {
          this.location[$.ON] = t2, this.location[$.LEFT] = e4, this.location[$.RIGHT] = n2;
        } }, { key: "get", value: function(t2) {
          return t2 < this.location.length ? this.location[t2] : H.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var t2 = 0; t2 < this.location.length; t2++) if (this.location[t2] === H.NONE) return true;
          return false;
        } }, { key: "setLocation", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setLocation($.ON, t2);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this.location[e4] = n2;
          }
        } }, { key: "init", value: function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(H.NONE);
        } }, { key: "isEqualOnSide", value: function(t2, e4) {
          return this.location[e4] === t2.location[e4];
        } }, { key: "allPositionsEqual", value: function(t2) {
          for (var e4 = 0; e4 < this.location.length; e4++) if (this.location[e4] !== t2) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              this.init(t2.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[$.ON] = n2;
            } else if (arguments[0] instanceof e3) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2) for (var r2 = 0; r2 < this.location.length; r2++) this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this.init(3), this.location[$.ON] = s2, this.location[$.LEFT] = a2, this.location[$.RIGHT] = o2;
          }
        } }]), e3;
      }(), Pe = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getGeometryCount", value: function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        } }, { key: "setAllLocations", value: function(t2, e4) {
          this.elt[t2].setAllLocations(e4);
        } }, { key: "isNull", value: function(t2) {
          return this.elt[t2].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this.elt[e4].setAllLocationsIfNull(n2);
          }
        } }, { key: "isLine", value: function(t2) {
          return this.elt[t2].isLine();
        } }, { key: "merge", value: function(t2) {
          for (var e4 = 0; e4 < 2; e4++) null === this.elt[e4] && null !== t2.elt[e4] ? this.elt[e4] = new Ae(t2.elt[e4]) : this.elt[e4].merge(t2.elt[e4]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].get($.ON);
          }
          if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            return this.elt[e4].get(n2);
          }
        } }, { key: "toString", value: function() {
          var t2 = new st();
          return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        } }, { key: "isArea", value: function() {
          if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        } }, { key: "isAnyNull", value: function(t2) {
          return this.elt[t2].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            this.elt[t2].setLocation($.ON, e4);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        } }, { key: "isEqualOnSide", value: function(t2, e4) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e4) && this.elt[1].isEqualOnSide(t2.elt[1], e4);
        } }, { key: "allPositionsEqual", value: function(t2, e4) {
          return this.elt[t2].allPositionsEqual(e4);
        } }, { key: "toLine", value: function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Ae(this.elt[t2].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this.elt[0] = new Ae(t2), this.elt[1] = new Ae(t2);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              this.elt[0] = new Ae(n2.elt[0]), this.elt[1] = new Ae(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Ae(H.NONE), this.elt[1] = new Ae(H.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this.elt[0] = new Ae(s2, a2, o2), this.elt[1] = new Ae(s2, a2, o2);
          } else if (4 === arguments.length) {
            var u5 = arguments[0], l2 = arguments[1], h2 = arguments[2], c2 = arguments[3];
            this.elt[0] = new Ae(H.NONE, H.NONE, H.NONE), this.elt[1] = new Ae(H.NONE, H.NONE, H.NONE), this.elt[u5].setLocations(l2, h2, c2);
          }
        } }, { key: "toLineLabel", value: function(t2) {
          for (var n2 = new e3(H.NONE), i2 = 0; i2 < 2; i2++) n2.setLocation(i2, t2.getLocation(i2));
          return n2;
        } }]), e3;
      }(), De = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "computeRing", value: function() {
          if (null !== this._ring) return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e4 = 0; e4 < this._pts.size(); e4++) t2[e4] = this._pts.get(e4);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = ct.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return 1 === this._label.getGeometryCount();
        } }, { key: "computePoints", value: function(t2) {
          this._startDe = t2;
          var e4 = t2, n2 = true;
          do {
            if (null === e4) throw new vt("Found null DirectedEdge");
            if (e4.getEdgeRing() === this) throw new vt("Directed Edge visited twice during ring-building at " + e4.getCoordinate());
            this._edges.add(e4);
            var i2 = e4.getLabel();
            G.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e4.getEdge(), e4.isForward(), n2), n2 = false, this.setEdgeRing(e4, this), e4 = this.getNext(e4);
          } while (e4 !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(t2) {
          return this._pts.get(t2);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e4 = t2.getNode().getEdges().getOutgoingDegree(this);
            e4 > this._maxNodeDegree && (this._maxNodeDegree = e4), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(t2, e4, n2) {
          var i2 = t2.getCoordinates();
          if (e4) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var s2 = r2; s2 < i2.length; s2++) this._pts.add(i2[s2]);
          } else {
            var a2 = i2.length - 2;
            n2 && (a2 = i2.length - 1);
            for (var o2 = a2; o2 >= 0; o2--) this._pts.add(i2[o2]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        } }, { key: "containsPoint", value: function(t2) {
          var e4 = this.getLinearRing();
          if (!e4.getEnvelopeInternal().contains(t2)) return false;
          if (!Me.isInRing(t2, e4.getCoordinates())) return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2)) return false;
          }
          return true;
        } }, { key: "addHole", value: function(t2) {
          this._holes.add(t2);
        } }, { key: "isShell", value: function() {
          return null === this._shell;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getLocation(n2, $.RIGHT);
            if (i2 === H.NONE) return null;
            if (this._label.getLocation(n2) === H.NONE) return this._label.setLocation(n2, i2), null;
          }
        } }, { key: "setShell", value: function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        } }, { key: "toPolygon", value: function(t2) {
          for (var e4 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++) e4[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e4);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new yt(), this._pts = new yt(), this._label = new Pe(H.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new yt(), this._geometryFactory = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            this._geometryFactory = e4, this.computePoints(t2), this.computeRing();
          }
        } }]), e3;
      }(), Fe = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "setEdgeRing", value: function(t2, e4) {
          t2.setMinEdgeRing(e4);
        } }, { key: "getNext", value: function(t2) {
          return t2.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          De.constructor_.call(this, t2, e4);
        } }]), s2;
      }(De), Ge = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "buildMinimalRings", value: function() {
          var t2 = new yt(), e4 = this._startDe;
          do {
            if (null === e4.getMinEdgeRing()) {
              var n2 = new Fe(e4, this._geometryFactory);
              t2.add(n2);
            }
            e4 = e4.getNext();
          } while (e4 !== this._startDe);
          return t2;
        } }, { key: "setEdgeRing", value: function(t2, e4) {
          t2.setEdgeRing(e4);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var t2 = this._startDe;
          do {
            t2.getNode().getEdges().linkMinimalDirectedEdges(this), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        } }, { key: "getNext", value: function(t2) {
          return t2.getNext();
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0], e4 = arguments[1];
          De.constructor_.call(this, t2, e4);
        } }]), s2;
      }(De), qe = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "setVisited", value: function(t2) {
          this._isVisited = t2;
        } }, { key: "setInResult", value: function(t2) {
          this._isInResult = t2;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(t2) {
          this._label = t2;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        } }, { key: "updateIM", value: function(t2) {
          G.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        } }]), e3;
      }(), Ye = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var t2 = this.getEdges().getEdges().iterator(); t2.hasNext(); ) {
            if (t2.next().getEdge().isInResult()) return true;
          }
          return false;
        } }, { key: "isIsolated", value: function() {
          return 1 === this._label.getGeometryCount();
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(t2) {
          t2.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(t2) {
        } }, { key: "computeMergedLocation", value: function(t2, e4) {
          var n2 = H.NONE;
          if (n2 = this._label.getLocation(e4), !t2.isNull(e4)) {
            var i2 = t2.getLocation(e4);
            n2 !== H.BOUNDARY && (n2 = i2);
          }
          return n2;
        } }, { key: "setLabel", value: function() {
          if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return f(r(a2.prototype), "setLabel", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1];
          null === this._label ? this._label = new Pe(t2, e4) : this._label.setLocation(t2, e4);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof a2) {
            var t2 = arguments[0];
            this.mergeLabel(t2._label);
          } else if (arguments[0] instanceof Pe) for (var e4 = arguments[0], n2 = 0; n2 < 2; n2++) {
            var i2 = this.computeMergedLocation(e4, n2), r2 = this._label.getLocation(n2);
            r2 === H.NONE && this._label.setLocation(n2, i2);
          }
        } }, { key: "add", value: function(t2) {
          this._edges.insert(t2), t2.setNode(this);
        } }, { key: "setLabelBoundary", value: function(t2) {
          if (null === this._label) return null;
          var e4 = H.NONE;
          null !== this._label && (e4 = this._label.getLocation(t2));
          var n2 = null;
          switch (e4) {
            case H.BOUNDARY:
              n2 = H.INTERIOR;
              break;
            case H.INTERIOR:
            default:
              n2 = H.BOUNDARY;
          }
          this._label.setLocation(t2, n2);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var t2 = arguments[0], e4 = arguments[1];
          this._coord = t2, this._edges = e4, this._label = new Pe(0, H.NONE);
        } }]), a2;
      }(qe), ze = function(e3) {
        i(r2, e3);
        var n2 = c(r2);
        function r2() {
          return t(this, r2), n2.apply(this, arguments);
        }
        return r2;
      }(ee);
      function Xe(t2) {
        return null == t2 ? 0 : t2.color;
      }
      function Be(t2) {
        return null == t2 ? null : t2.parent;
      }
      function Ue(t2, e3) {
        null !== t2 && (t2.color = e3);
      }
      function Ve(t2) {
        return null == t2 ? null : t2.left;
      }
      function He(t2) {
        return null == t2 ? null : t2.right;
      }
      var Ze = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), (e4 = r2.call(this)).root_ = null, e4.size_ = 0, e4;
        }
        return n(s2, [{ key: "get", value: function(t2) {
          for (var e4 = this.root_; null !== e4; ) {
            var n2 = t2.compareTo(e4.key);
            if (n2 < 0) e4 = e4.left;
            else {
              if (!(n2 > 0)) return e4.value;
              e4 = e4.right;
            }
          }
          return null;
        } }, { key: "put", value: function(t2, e4) {
          if (null === this.root_) return this.root_ = { key: t2, value: e4, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var n2, i2, r3 = this.root_;
          do {
            if (n2 = r3, (i2 = t2.compareTo(r3.key)) < 0) r3 = r3.left;
            else {
              if (!(i2 > 0)) {
                var s3 = r3.value;
                return r3.value = e4, s3;
              }
              r3 = r3.right;
            }
          } while (null !== r3);
          var a2 = { key: t2, left: null, right: null, value: e4, parent: n2, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = a2 : n2.right = a2, this.fixAfterInsertion(a2), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(t2) {
          var e4;
          for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; ) Be(t2) === Ve(Be(Be(t2))) ? 1 === Xe(e4 = He(Be(Be(t2)))) ? (Ue(Be(t2), 0), Ue(e4, 0), Ue(Be(Be(t2)), 1), t2 = Be(Be(t2))) : (t2 === He(Be(t2)) && (t2 = Be(t2), this.rotateLeft(t2)), Ue(Be(t2), 0), Ue(Be(Be(t2)), 1), this.rotateRight(Be(Be(t2)))) : 1 === Xe(e4 = Ve(Be(Be(t2)))) ? (Ue(Be(t2), 0), Ue(e4, 0), Ue(Be(Be(t2)), 1), t2 = Be(Be(t2))) : (t2 === Ve(Be(t2)) && (t2 = Be(t2), this.rotateRight(t2)), Ue(Be(t2), 0), Ue(Be(Be(t2)), 1), this.rotateLeft(Be(Be(t2))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var t2 = new yt(), e4 = this.getFirstEntry();
          if (null !== e4) for (t2.add(e4.value); null !== (e4 = s2.successor(e4)); ) t2.add(e4.value);
          return t2;
        } }, { key: "entrySet", value: function() {
          var t2 = new J(), e4 = this.getFirstEntry();
          if (null !== e4) for (t2.add(e4); null !== (e4 = s2.successor(e4)); ) t2.add(e4);
          return t2;
        } }, { key: "rotateLeft", value: function(t2) {
          if (null != t2) {
            var e4 = t2.right;
            t2.right = e4.left, null != e4.left && (e4.left.parent = t2), e4.parent = t2.parent, null == t2.parent ? this.root_ = e4 : t2.parent.left === t2 ? t2.parent.left = e4 : t2.parent.right = e4, e4.left = t2, t2.parent = e4;
          }
        } }, { key: "rotateRight", value: function(t2) {
          if (null != t2) {
            var e4 = t2.left;
            t2.left = e4.right, null != e4.right && (e4.right.parent = t2), e4.parent = t2.parent, null == t2.parent ? this.root_ = e4 : t2.parent.right === t2 ? t2.parent.right = e4 : t2.parent.left = e4, e4.right = t2, t2.parent = e4;
          }
        } }, { key: "getFirstEntry", value: function() {
          var t2 = this.root_;
          if (null != t2) for (; null != t2.left; ) t2 = t2.left;
          return t2;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(t2) {
          for (var e4 = this.root_; null !== e4; ) {
            var n2 = t2.compareTo(e4.key);
            if (n2 < 0) e4 = e4.left;
            else {
              if (!(n2 > 0)) return true;
              e4 = e4.right;
            }
          }
          return false;
        } }], [{ key: "successor", value: function(t2) {
          var e4;
          if (null === t2) return null;
          if (null !== t2.right) {
            for (e4 = t2.right; null !== e4.left; ) e4 = e4.left;
            return e4;
          }
          e4 = t2.parent;
          for (var n2 = t2; null !== e4 && n2 === e4.right; ) n2 = e4, e4 = e4.parent;
          return e4;
        } }]), s2;
      }(ze), je = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "find", value: function(t2) {
          return this.nodeMap.get(t2);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof X) {
            var t2 = arguments[0], e4 = this.nodeMap.get(t2);
            return null === e4 && (e4 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e4)), e4;
          }
          if (arguments[0] instanceof Ye) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        } }, { key: "print", value: function(t2) {
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            e4.next().print(t2);
          }
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(t2) {
          for (var e4 = new yt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === H.BOUNDARY && e4.add(i2);
          }
          return e4;
        } }, { key: "add", value: function(t2) {
          var e4 = t2.getCoordinate();
          this.addNode(e4).add(t2);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new Ze(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        } }]), e3;
      }(), We = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "isNorthern", value: function(t2) {
          return t2 === e3.NE || t2 === e3.NW;
        } }, { key: "isOpposite", value: function(t2, e4) {
          return t2 !== e4 && 2 === (t2 - e4 + 4) % 4;
        } }, { key: "commonHalfPlane", value: function(t2, e4) {
          if (t2 === e4) return t2;
          if (2 === (t2 - e4 + 4) % 4) return -1;
          var n2 = t2 < e4 ? t2 : e4;
          return 0 === n2 && 3 === (t2 > e4 ? t2 : e4) ? 3 : n2;
        } }, { key: "isInHalfPlane", value: function(t2, n2) {
          return n2 === e3.SE ? t2 === e3.SE || t2 === e3.SW : t2 === n2 || t2 === n2 + 1;
        } }, { key: "quadrant", value: function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], n2 = arguments[1];
            if (0 === t2 && 0 === n2) throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + n2 + " )");
            return t2 >= 0 ? n2 >= 0 ? e3.NE : e3.SE : n2 >= 0 ? e3.NW : e3.SW;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof X) {
            var i2 = arguments[0], r2 = arguments[1];
            if (r2.x === i2.x && r2.y === i2.y) throw new m("Cannot compute the quadrant for two identical points " + i2);
            return r2.x >= i2.x ? r2.y >= i2.y ? e3.NE : e3.SE : r2.y >= i2.y ? e3.NW : e3.SW;
          }
        } }]), e3;
      }();
      We.NE = 0, We.NW = 1, We.SW = 2, We.SE = 3;
      var Ke = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "compareDirection", value: function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : ct.index(t2._p0, t2._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(t2) {
          this._node = t2;
        } }, { key: "print", value: function(t2) {
          var e4 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e4 + "   " + this._label);
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this.compareDirection(e4);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var t2 = Math.atan2(this._dy, this._dx), e4 = this.getClass().getName(), n2 = e4.lastIndexOf(".");
          return "  " + e4.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        } }, { key: "computeLabel", value: function(t2) {
        } }, { key: "init", value: function(t2, e4) {
          this._p0 = t2, this._p1 = e4, this._dx = e4.x - t2.x, this._dy = e4.y - t2.y, this._quadrant = We.quadrant(this._dx, this._dy), G.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            e3.constructor_.call(this, n2, i2, r2, null);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = arguments[3];
            e3.constructor_.call(this, s2), this.init(a2, o2), this._label = u5;
          }
        } }]), e3;
      }(), Je = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(t2) {
          return this._depth[t2];
        } }, { key: "setVisited", value: function(t2) {
          this._isVisited = t2;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(t2, e4) {
          if (-999 !== this._depth[t2] && this._depth[t2] !== e4) throw new vt("assigned depths do not match", this.getCoordinate());
          this._depth[t2] = e4;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var t2 = true, e4 = 0; e4 < 2; e4++) this._label.isArea(e4) && this._label.getLocation(e4, $.LEFT) === H.INTERIOR && this._label.getLocation(e4, $.RIGHT) === H.INTERIOR || (t2 = false);
          return t2;
        } }, { key: "setNextMin", value: function(t2) {
          this._nextMin = t2;
        } }, { key: "print", value: function(t2) {
          f(r(a2.prototype), "print", this).call(this, t2), t2.print(" " + this._depth[$.LEFT] + "/" + this._depth[$.RIGHT]), t2.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t2.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(t2) {
          this._minEdgeRing = t2;
        } }, { key: "isLineEdge", value: function() {
          var t2 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, H.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, H.EXTERIOR);
          return t2 && e4 && n2;
        } }, { key: "setEdgeRing", value: function(t2) {
          this._edgeRing = t2;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var t2 = this._edge.getDepthDelta();
          return this._isForward || (t2 = -t2), t2;
        } }, { key: "setInResult", value: function(t2) {
          this._isInResult = t2;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(t2) {
          this.print(t2), t2.print(" "), this._isForward ? this._edge.print(t2) : this._edge.printReverse(t2);
        } }, { key: "setSym", value: function(t2) {
          this._sym = t2;
        } }, { key: "setVisitedEdge", value: function(t2) {
          this.setVisited(t2), this._sym.setVisited(t2);
        } }, { key: "setEdgeDepths", value: function(t2, e4) {
          var n2 = this.getEdge().getDepthDelta();
          this._isForward || (n2 = -n2);
          var i2 = 1;
          t2 === $.LEFT && (i2 = -1);
          var r2 = $.opposite(t2), s3 = e4 + n2 * i2;
          this.setDepth(t2, e4), this.setDepth(r2, s3);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(t2) {
          this._next = t2;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var t2 = arguments[0], e4 = arguments[1];
          if (Ke.constructor_.call(this, t2), this._isForward = e4, e4) this.init(t2.getCoordinate(0), t2.getCoordinate(1));
          else {
            var n2 = t2.getNumPoints() - 1;
            this.init(t2.getCoordinate(n2), t2.getCoordinate(n2 - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(t2, e4) {
          return t2 === H.EXTERIOR && e4 === H.INTERIOR ? 1 : t2 === H.INTERIOR && e4 === H.EXTERIOR ? -1 : 0;
        } }]), a2;
      }(Ke), Qe = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "createNode", value: function(t2) {
          return new Ye(t2, null);
        } }]), e3;
      }(), $e = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "printEdges", value: function(t2) {
          t2.println("Edges:");
          for (var e4 = 0; e4 < this._edges.size(); e4++) {
            t2.println("edge " + e4 + ":");
            var n2 = this._edges.get(e4);
            n2.print(t2), n2.eiList.print(t2);
          }
        } }, { key: "find", value: function(t2) {
          return this._nodes.find(t2);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof Ye) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof X) {
            var e4 = arguments[0];
            return this._nodes.addNode(e4);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        } }, { key: "debugPrintln", value: function(t2) {
          mt.out.println(t2);
        } }, { key: "isBoundaryNode", value: function(t2, e4) {
          var n2 = this._nodes.find(e4);
          if (null === n2) return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === H.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        } }, { key: "matchInSameDirection", value: function(t2, e4, n2, i2) {
          return !!t2.equals(n2) && (ct.index(t2, e4, i2) === ct.COLLINEAR && We.quadrant(t2, e4) === We.quadrant(n2, i2));
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(t2) {
          mt.out.print(t2);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(t2, e4) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e4, r2[0], r2[1])) return i2;
            if (this.matchInSameDirection(t2, e4, r2[r2.length - 1], r2[r2.length - 2])) return i2;
          }
          return null;
        } }, { key: "insertEdge", value: function(t2) {
          this._edges.add(t2);
        } }, { key: "findEdgeEnd", value: function(t2) {
          for (var e4 = this.getEdgeEnds().iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            if (n2.getEdge() === t2) return n2;
          }
          return null;
        } }, { key: "addEdges", value: function(t2) {
          for (var e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            this._edges.add(n2);
            var i2 = new Je(n2, true), r2 = new Je(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        } }, { key: "add", value: function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(t2, e4) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e4.equals(r2[1])) return i2;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new yt(), this._nodes = null, this._edgeEndList = new yt(), 0 === arguments.length) this._nodes = new je(new Qe());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new je(t2);
          }
        } }, { key: "linkResultDirectedEdges", value: function(t2) {
          for (var e4 = t2.iterator(); e4.hasNext(); ) {
            e4.next().getEdges().linkResultDirectedEdges();
          }
        } }]), e3;
      }(), tn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "sortShellsAndHoles", value: function(t2, e4, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e4.add(r2);
          }
        } }, { key: "computePolygons", value: function(t2) {
          for (var e4 = new yt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e4.add(i2);
          }
          return e4;
        } }, { key: "placeFreeHoles", value: function(t2, n2) {
          for (var i2 = n2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            if (null === r2.getShell()) {
              var s2 = e3.findEdgeRingContaining(r2, t2);
              if (null === s2) throw new vt("unable to assign hole to a shell", r2.getCoordinate(0));
              r2.setShell(s2);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(t2, e4, n2) {
          for (var i2 = new yt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            if (s2.getMaxNodeDegree() > 2) {
              s2.linkDirectedEdgesForMinimalEdgeRings();
              var a2 = s2.buildMinimalRings(), o2 = this.findShell(a2);
              null !== o2 ? (this.placePolygonHoles(o2, a2), e4.add(o2)) : n2.addAll(a2);
            } else i2.add(s2);
          }
          return i2;
        } }, { key: "buildMaximalEdgeRings", value: function(t2) {
          for (var e4 = new yt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Ge(i2, this._geometryFactory);
              e4.add(r2), r2.setInResult();
            }
          }
          return e4;
        } }, { key: "placePolygonHoles", value: function(t2, e4) {
          for (var n2 = e4.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(t2) {
          for (var e4 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e4++);
          }
          return G.isTrue(e4 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        } }, { key: "add", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            $e.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e4), r2 = new yt(), s2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(s2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new yt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        } }, { key: "findEdgeRingContaining", value: function(t2, e4) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), s2 = null, a2 = null, o2 = e4.iterator(); o2.hasNext(); ) {
            var u5 = o2.next(), l2 = u5.getLinearRing(), h2 = l2.getEnvelopeInternal();
            if (!h2.equals(i2) && h2.contains(i2)) {
              r2 = jt.ptNotInList(n2.getCoordinates(), l2.getCoordinates());
              var c2 = false;
              Me.isInRing(r2, l2.getCoordinates()) && (c2 = true), c2 && (null === s2 || a2.contains(h2)) && (a2 = (s2 = u5).getLinearRing().getEnvelopeInternal());
            }
          }
          return s2;
        } }]), e3;
      }(), en = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "getBounds", value: function() {
        } }]), e3;
      }(), nn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [en, E];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e4 = arguments[1];
          this._bounds = t2, this._item = e4;
        } }]), e3;
      }(), rn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(t2) {
          for (var e4 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e4 = 2 * t2) !== this._size && this._items.get(e4 + 1).compareTo(this._items.get(e4)) < 0 && e4++, this._items.get(e4).compareTo(n2) < 0); t2 = e4) this._items.set(t2, this._items.get(e4));
          this._items.set(t2, n2);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return 0 === this._size;
        } }, { key: "add", value: function(t2) {
          this._items.add(null), this._size += 1;
          var e4 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e4 / 2))) < 0; e4 /= 2) this._items.set(e4, this._items.get(Math.trunc(e4 / 2)));
          this._items.set(e4, t2);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new yt(), this._items.add(null);
        } }]), e3;
      }(), sn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "insert", value: function(t2, e4) {
        } }, { key: "remove", value: function(t2, e4) {
        } }, { key: "query", value: function() {
        } }]), e3;
      }(), an = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(t2) {
          G.isTrue(null === this._bounds), this._childBoundables.add(t2);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [en, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new yt(), this._bounds = null, this._level = null, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        } }]), e3;
      }(), on = { reverseOrder: function() {
        return { compare: function(t2, e3) {
          return e3.compareTo(t2);
        } };
      }, min: function(t2) {
        return on.sort(t2), t2.get(0);
      }, sort: function(t2, e3) {
        var n2 = t2.toArray();
        e3 ? At.sort(n2, e3) : At.sort(n2);
        for (var i2 = t2.iterator(), r2 = 0, s2 = n2.length; r2 < s2; r2++) i2.next(), i2.set(n2[r2]);
      }, singletonList: function(t2) {
        var e3 = new yt();
        return e3.add(t2), e3;
      } }, un = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "maxDistance", value: function(t2, n2, i2, r2, s2, a2, o2, u5) {
          var l2 = e3.distance(t2, n2, s2, a2);
          return l2 = Math.max(l2, e3.distance(t2, n2, o2, u5)), l2 = Math.max(l2, e3.distance(i2, r2, s2, a2)), l2 = Math.max(l2, e3.distance(i2, r2, o2, u5));
        } }, { key: "distance", value: function(t2, e4, n2, i2) {
          var r2 = n2 - t2, s2 = i2 - e4;
          return Math.sqrt(r2 * r2 + s2 * s2);
        } }, { key: "maximumDistance", value: function(t2, n2) {
          var i2 = Math.min(t2.getMinX(), n2.getMinX()), r2 = Math.min(t2.getMinY(), n2.getMinY()), s2 = Math.max(t2.getMaxX(), n2.getMaxX()), a2 = Math.max(t2.getMaxY(), n2.getMaxY());
          return e3.distance(i2, r2, s2, a2);
        } }, { key: "minMaxDistance", value: function(t2, n2) {
          var i2 = t2.getMinX(), r2 = t2.getMinY(), s2 = t2.getMaxX(), a2 = t2.getMaxY(), o2 = n2.getMinX(), u5 = n2.getMinY(), l2 = n2.getMaxX(), h2 = n2.getMaxY(), c2 = e3.maxDistance(i2, r2, i2, a2, o2, u5, o2, h2);
          return c2 = Math.min(c2, e3.maxDistance(i2, r2, i2, a2, o2, u5, l2, u5)), c2 = Math.min(c2, e3.maxDistance(i2, r2, i2, a2, l2, h2, o2, h2)), c2 = Math.min(c2, e3.maxDistance(i2, r2, i2, a2, l2, h2, l2, u5)), c2 = Math.min(c2, e3.maxDistance(i2, r2, s2, r2, o2, u5, o2, h2)), c2 = Math.min(c2, e3.maxDistance(i2, r2, s2, r2, o2, u5, l2, u5)), c2 = Math.min(c2, e3.maxDistance(i2, r2, s2, r2, l2, h2, o2, h2)), c2 = Math.min(c2, e3.maxDistance(i2, r2, s2, r2, l2, h2, l2, u5)), c2 = Math.min(c2, e3.maxDistance(s2, a2, i2, a2, o2, u5, o2, h2)), c2 = Math.min(c2, e3.maxDistance(s2, a2, i2, a2, o2, u5, l2, u5)), c2 = Math.min(c2, e3.maxDistance(s2, a2, i2, a2, l2, h2, o2, h2)), c2 = Math.min(c2, e3.maxDistance(s2, a2, i2, a2, l2, h2, l2, u5)), c2 = Math.min(c2, e3.maxDistance(s2, a2, s2, r2, o2, u5, o2, h2)), c2 = Math.min(c2, e3.maxDistance(s2, a2, s2, r2, o2, u5, l2, u5)), c2 = Math.min(c2, e3.maxDistance(s2, a2, s2, r2, l2, h2, o2, h2)), c2 = Math.min(c2, e3.maxDistance(s2, a2, s2, r2, l2, h2, l2, u5));
        } }]), e3;
      }(), ln = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "maximumDistance", value: function() {
          return un.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(t2, n2) {
          var i2 = e3.isComposite(this._boundable1), r2 = e3.isComposite(this._boundable2);
          if (i2 && r2) return e3.area(this._boundable1) > e3.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, false, t2, n2), null) : (this.expand(this._boundable2, this._boundable1, true, t2, n2), null);
          if (i2) return this.expand(this._boundable1, this._boundable2, false, t2, n2), null;
          if (r2) return this.expand(this._boundable2, this._boundable1, true, t2, n2), null;
          throw new m("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(e3.isComposite(this._boundable1) || e3.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this._distance < e4._distance ? -1 : this._distance > e4._distance ? 1 : 0;
        } }, { key: "expand", value: function(t2, n2, i2, r2, s2) {
          for (var a2 = t2.getChildBoundables().iterator(); a2.hasNext(); ) {
            var o2 = a2.next(), u5 = null;
            (u5 = i2 ? new e3(n2, o2, this._itemDistance) : new e3(o2, n2, this._itemDistance)).getDistance() < s2 && r2.add(u5);
          }
        } }, { key: "getBoundable", value: function(t2) {
          return 0 === t2 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e4, this._itemDistance = n2, this._distance = this.distance();
        } }, { key: "area", value: function(t2) {
          return t2.getBounds().getArea();
        } }, { key: "isComposite", value: function(t2) {
          return t2 instanceof an;
        } }]), e3;
      }(), hn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "visitItem", value: function(t2) {
        } }]), e3;
      }(), cn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "queryInternal", value: function() {
          if (rt(arguments[2], hn) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = e4.getChildBoundables(), r2 = 0; r2 < i2.size(); r2++) {
            var s2 = i2.get(r2);
            this.getIntersectsOp().intersects(s2.getBounds(), t2) && (s2 instanceof an ? this.queryInternal(t2, s2, n2) : s2 instanceof nn ? n2.visitItem(s2.getItem()) : G.shouldNeverReachHere());
          }
          else if (rt(arguments[2], nt) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var a2 = arguments[0], o2 = arguments[1], u5 = arguments[2], l2 = o2.getChildBoundables(), h2 = 0; h2 < l2.size(); h2++) {
            var c2 = l2.get(h2);
            this.getIntersectsOp().intersects(c2.getBounds(), a2) && (c2 instanceof an ? this.queryInternal(a2, c2, u5) : c2 instanceof nn ? u5.add(c2.getItem()) : G.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(t2) {
          return t2.get(t2.size() - 1);
        } }, { key: "size", value: function() {
          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = 0, n2 = t2.getChildBoundables().iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              i2 instanceof an ? e4 += this.size(i2) : i2 instanceof nn && (e4 += 1);
            }
            return e4;
          }
        } }, { key: "removeItem", value: function(t2, e4) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof nn && r2.getItem() === e4 && (n2 = r2);
          }
          return null !== n2 && (t2.getChildBoundables().remove(n2), true);
        } }, { key: "itemsTree", value: function() {
          if (0 === arguments.length) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return null === t2 ? new yt() : t2;
          }
          if (1 === arguments.length) {
            for (var e4 = arguments[0], n2 = new yt(), i2 = e4.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof an) {
                var s2 = this.itemsTree(r2);
                null !== s2 && n2.add(s2);
              } else r2 instanceof nn ? n2.add(r2.getItem()) : G.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        } }, { key: "insert", value: function(t2, e4) {
          G.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new nn(t2, e4));
        } }, { key: "boundablesAtLevel", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e4 = new yt();
            return this.boundablesAtLevel(t2, this._root, e4), e4;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (G.isTrue(n2 > -2), i2.getLevel() === n2) return r2.add(i2), null;
            for (var s2 = i2.getChildBoundables().iterator(); s2.hasNext(); ) {
              var a2 = s2.next();
              a2 instanceof an ? this.boundablesAtLevel(n2, a2, r2) : (G.isTrue(a2 instanceof nn), -1 === n2 && r2.add(a2));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.build();
            var e4 = new yt();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.queryInternal(t2, this._root, e4), e4;
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.queryInternal(n2, this._root, i2);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e4);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s2 = this.removeItem(i2, r2);
            if (s2) return true;
            for (var a2 = null, o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var u5 = o2.next();
              if (this.getIntersectsOp().intersects(u5.getBounds(), n2) && (u5 instanceof an && (s2 = this.remove(n2, u5, r2)))) {
                a2 = u5;
                break;
              }
            }
            return null !== a2 && a2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(a2), s2;
          }
        } }, { key: "createHigherLevels", value: function(t2, e4) {
          G.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e4 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e4 + 1);
        } }, { key: "depth", value: function() {
          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = 0, n2 = t2.getChildBoundables().iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 instanceof an) {
                var r2 = this.depth(i2);
                r2 > e4 && (e4 = r2);
              }
            }
            return e4 + 1;
          }
        } }, { key: "createParentBoundables", value: function(t2, e4) {
          G.isTrue(!t2.isEmpty());
          var n2 = new yt();
          n2.add(this.createNode(e4));
          var i2 = new yt(t2);
          on.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e4)), this.lastNode(n2).addChildBoundable(s2);
          }
          return n2;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = false, this._itemBoundables = new yt(), this._nodeCapacity = null, 0 === arguments.length) e3.constructor_.call(this, e3.DEFAULT_NODE_CAPACITY);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            G.isTrue(t2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t2;
          }
        } }, { key: "compareDoubles", value: function(t2, e4) {
          return t2 > e4 ? 1 : t2 < e4 ? -1 : 0;
        } }]), e3;
      }();
      cn.IntersectsOp = function() {
      }, cn.DEFAULT_NODE_CAPACITY = 10;
      var fn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "distance", value: function(t2, e4) {
        } }]), e3;
      }(), vn = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "createParentBoundablesFromVerticalSlices", value: function(t2, e4) {
          G.isTrue(t2.length > 0);
          for (var n2 = new yt(), i2 = 0; i2 < t2.length; i2++) n2.addAll(this.createParentBoundablesFromVerticalSlice(t2[i2], e4));
          return n2;
        } }, { key: "nearestNeighbourK", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            return this.nearestNeighbourK(t2, A.POSITIVE_INFINITY, e4);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s3 = i2, o2 = new rn();
            o2.add(n2);
            for (var u5 = new rn(); !o2.isEmpty() && s3 >= 0; ) {
              var l2 = o2.poll(), h2 = l2.getDistance();
              if (h2 >= s3) break;
              if (l2.isLeaves()) if (u5.size() < r2) u5.add(l2);
              else {
                var c2 = u5.peek();
                c2.getDistance() > h2 && (u5.poll(), u5.add(l2));
                var f2 = u5.peek();
                s3 = f2.getDistance();
              }
              else l2.expandToQueue(o2, s3);
            }
            return a2.getItems(u5);
          }
        } }, { key: "createNode", value: function(t2) {
          return new gn(t2);
        } }, { key: "size", value: function() {
          return 0 === arguments.length ? f(r(a2.prototype), "size", this).call(this) : f(r(a2.prototype), "size", this).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return f(r(a2.prototype), "insert", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1];
          if (t2.isNull()) return null;
          f(r(a2.prototype), "insert", this).call(this, t2, e4);
        } }, { key: "getIntersectsOp", value: function() {
          return a2.intersectsOp;
        } }, { key: "verticalSlices", value: function(t2, e4) {
          for (var n2 = Math.trunc(Math.ceil(t2.size() / e4)), i2 = new Array(e4).fill(null), r2 = t2.iterator(), s3 = 0; s3 < e4; s3++) {
            i2[s3] = new yt();
            for (var a3 = 0; r2.hasNext() && a3 < n2; ) {
              var o2 = r2.next();
              i2[s3].add(o2), a3++;
            }
          }
          return i2;
        } }, { key: "query", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return f(r(a2.prototype), "query", this).call(this, t2);
          }
          if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            f(r(a2.prototype), "query", this).call(this, e4, n2);
          }
        } }, { key: "getComparator", value: function() {
          return a2.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(t2, e4) {
          return f(r(a2.prototype), "createParentBoundables", this).call(this, t2, e4);
        } }, { key: "remove", value: function() {
          if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {
            var t2 = arguments[0], e4 = arguments[1];
            return f(r(a2.prototype), "remove", this).call(this, t2, e4);
          }
          return f(r(a2.prototype), "remove", this).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return 0 === arguments.length ? f(r(a2.prototype), "depth", this).call(this) : f(r(a2.prototype), "depth", this).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(t2, e4) {
          G.isTrue(!t2.isEmpty());
          var n2 = Math.trunc(Math.ceil(t2.size() / this.getNodeCapacity())), i2 = new yt(t2);
          on.sort(i2, a2.xComparator);
          var r2 = this.verticalSlices(i2, Math.trunc(Math.ceil(Math.sqrt(n2))));
          return this.createParentBoundablesFromVerticalSlices(r2, e4);
        } }, { key: "nearestNeighbour", value: function() {
          if (1 === arguments.length) {
            if (rt(arguments[0], fn)) {
              var t2 = arguments[0];
              if (this.isEmpty()) return null;
              var e4 = new ln(this.getRoot(), this.getRoot(), t2);
              return this.nearestNeighbour(e4);
            }
            if (arguments[0] instanceof ln) {
              var n2 = arguments[0], i2 = A.POSITIVE_INFINITY, r2 = null, s3 = new rn();
              for (s3.add(n2); !s3.isEmpty() && i2 > 0; ) {
                var a3 = s3.poll(), o2 = a3.getDistance();
                if (o2 >= i2) break;
                a3.isLeaves() ? (i2 = o2, r2 = a3) : a3.expandToQueue(s3, i2);
              }
              return null === r2 ? null : [r2.getBoundable(0).getItem(), r2.getBoundable(1).getItem()];
            }
          } else {
            if (2 === arguments.length) {
              var u5 = arguments[0], l2 = arguments[1];
              if (this.isEmpty() || u5.isEmpty()) return null;
              var h2 = new ln(this.getRoot(), u5.getRoot(), l2);
              return this.nearestNeighbour(h2);
            }
            if (3 === arguments.length) {
              var c2 = arguments[0], f2 = arguments[1], v3 = arguments[2], g2 = new nn(c2, f2), y3 = new ln(this.getRoot(), g2, v3);
              return this.nearestNeighbour(y3)[0];
            }
            if (4 === arguments.length) {
              var d2 = arguments[0], _2 = arguments[1], p2 = arguments[2], m2 = arguments[3], k2 = new nn(d2, _2), x3 = new ln(this.getRoot(), k2, p2);
              return this.nearestNeighbourK(x3, m2);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1], n2 = A.POSITIVE_INFINITY, i2 = new rn();
            for (i2.add(t2); !i2.isEmpty(); ) {
              var r2 = i2.poll(), s3 = r2.getDistance();
              if (s3 > e4) return false;
              if (r2.maximumDistance() <= e4) return true;
              if (r2.isLeaves()) {
                if ((n2 = s3) <= e4) return true;
              } else r2.expandToQueue(i2, n2);
            }
            return false;
          }
          if (3 === arguments.length) {
            var a3 = arguments[0], o2 = arguments[1], u5 = arguments[2], l2 = new ln(this.getRoot(), a3.getRoot(), o2);
            return this.isWithinDistance(l2, u5);
          }
        } }, { key: "interfaces_", get: function() {
          return [sn, E];
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) a2.constructor_.call(this, a2.DEFAULT_NODE_CAPACITY);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            cn.constructor_.call(this, t2);
          }
        } }, { key: "centreX", value: function(t2) {
          return a2.avg(t2.getMinX(), t2.getMaxX());
        } }, { key: "avg", value: function(t2, e4) {
          return (t2 + e4) / 2;
        } }, { key: "getItems", value: function(t2) {
          for (var e4 = new Array(t2.size()).fill(null), n2 = 0; !t2.isEmpty(); ) {
            var i2 = t2.poll();
            e4[n2] = i2.getBoundable(0).getItem(), n2++;
          }
          return e4;
        } }, { key: "centreY", value: function(t2) {
          return a2.avg(t2.getMinY(), t2.getMaxY());
        } }]), a2;
      }(cn), gn = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "computeBounds", value: function() {
          for (var t2 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            null === t2 ? t2 = new U(n2.getBounds()) : t2.expandToInclude(n2.getBounds());
          }
          return t2;
        } }], [{ key: "constructor_", value: function() {
          var t2 = arguments[0];
          an.constructor_.call(this, t2);
        } }]), s2;
      }(an);
      vn.STRtreeNode = gn, vn.xComparator = new (function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "interfaces_", get: function() {
          return [P];
        } }, { key: "compare", value: function(t2, e4) {
          return cn.compareDoubles(vn.centreX(t2.getBounds()), vn.centreX(e4.getBounds()));
        } }]), e3;
      }())(), vn.yComparator = new (function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "interfaces_", get: function() {
          return [P];
        } }, { key: "compare", value: function(t2, e4) {
          return cn.compareDoubles(vn.centreY(t2.getBounds()), vn.centreY(e4.getBounds()));
        } }]), e3;
      }())(), vn.intersectsOp = new (function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(t2, e4) {
          return t2.intersects(e4);
        } }]), e3;
      }())(), vn.DEFAULT_NODE_CAPACITY = 10;
      var yn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "relativeSign", value: function(t2, e4) {
          return t2 < e4 ? -1 : t2 > e4 ? 1 : 0;
        } }, { key: "compare", value: function(t2, n2, i2) {
          if (n2.equals2D(i2)) return 0;
          var r2 = e3.relativeSign(n2.x, i2.x), s2 = e3.relativeSign(n2.y, i2.y);
          switch (t2) {
            case 0:
              return e3.compareValue(r2, s2);
            case 1:
              return e3.compareValue(s2, r2);
            case 2:
              return e3.compareValue(s2, -r2);
            case 3:
              return e3.compareValue(-r2, s2);
            case 4:
              return e3.compareValue(-r2, -s2);
            case 5:
              return e3.compareValue(-s2, -r2);
            case 6:
              return e3.compareValue(-s2, r2);
            case 7:
              return e3.compareValue(r2, -s2);
          }
          return G.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(t2, e4) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e4 < 0 ? -1 : e4 > 0 ? 1 : 0;
        } }]), e3;
      }(), dn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this.segmentIndex < e4.segmentIndex ? -1 : this.segmentIndex > e4.segmentIndex ? 1 : this.coord.equals2D(e4.coord) ? 0 : this._isInterior ? e4._isInterior ? yn.compare(this._segmentOctant, this.coord, e4.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new X(e4), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e4.equals2D(t2.getCoordinate(n2));
        } }]), e3;
      }(), _n = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]), e3;
      }(), pn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getSplitCoordinates", value: function() {
          var t2 = new Zt();
          this.addEndpoints();
          for (var e4 = this.iterator(), n2 = e4.next(); e4.hasNext(); ) {
            var i2 = e4.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var t2 = new yt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        } }, { key: "createSplitEdgePts", value: function(t2, e4) {
          var n2 = e4.segmentIndex - t2.segmentIndex + 2;
          if (2 === n2) return [new X(t2.coord), new X(e4.coord)];
          var i2 = this._edge.getCoordinate(e4.segmentIndex), r2 = e4.isInterior() || !e4.coord.equals2D(i2);
          r2 || n2--;
          var s2 = new Array(n2).fill(null), a2 = 0;
          s2[a2++] = new X(t2.coord);
          for (var o2 = t2.segmentIndex + 1; o2 <= e4.segmentIndex; o2++) s2[a2++] = this._edge.getCoordinate(o2);
          return r2 && (s2[a2] = new X(e4.coord)), s2;
        } }, { key: "print", value: function(t2) {
          t2.println("Intersections:");
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            e4.next().print(t2);
          }
        } }, { key: "findCollapsesFromExistingVertices", value: function(t2) {
          for (var e4 = 0; e4 < this._edge.size() - 2; e4++) {
            var n2 = this._edge.getCoordinate(e4);
            this._edge.getCoordinate(e4 + 1);
            var i2 = this._edge.getCoordinate(e4 + 2);
            n2.equals2D(i2) && t2.add(at.valueOf(e4 + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(t2, e4, n2) {
          var i2 = this.createSplitEdgePts(t2, e4);
          n2.add(i2, false);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e4 = this.iterator(), n2 = e4.next(); e4.hasNext(); ) {
            var i2 = e4.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        } }, { key: "findCollapseIndex", value: function(t2, e4, n2) {
          if (!t2.coord.equals2D(e4.coord)) return false;
          var i2 = e4.segmentIndex - t2.segmentIndex;
          return e4.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(t2) {
          for (var e4 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e4) && t2.add(at.valueOf(e4[0])), i2 = r2;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        } }, { key: "createSplitEdge", value: function(t2, e4) {
          var n2 = this.createSplitEdgePts(t2, e4);
          return new In(n2, this._edge.getData());
        } }, { key: "add", value: function(t2, e4) {
          var n2 = new dn(this._edge, t2, e4, this._edge.getSegmentOctant(e4)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (G.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        } }, { key: "checkSplitEdgesCorrectness", value: function(t2) {
          var e4 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e4[0])) throw new D2("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e4[e4.length - 1])) throw new D2("bad split edge end point at " + r2);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ze(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        } }]), e3;
      }(), mn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "octant", value: function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], n2 = arguments[1];
            if (0 === t2 && 0 === n2) throw new m("Cannot compute the octant for point ( " + t2 + ", " + n2 + " )");
            var i2 = Math.abs(t2), r2 = Math.abs(n2);
            return t2 >= 0 ? n2 >= 0 ? i2 >= r2 ? 0 : 1 : i2 >= r2 ? 7 : 6 : n2 >= 0 ? i2 >= r2 ? 3 : 2 : i2 >= r2 ? 4 : 5;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof X) {
            var s2 = arguments[0], a2 = arguments[1], o2 = a2.x - s2.x, u5 = a2.y - s2.y;
            if (0 === o2 && 0 === u5) throw new m("Cannot compute the octant for two identical points " + s2);
            return e3.octant(o2, u5);
          }
        } }]), e3;
      }(), kn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(t2) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(t2) {
        } }, { key: "getData", value: function() {
        } }]), e3;
      }(), xn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "addIntersection", value: function(t2, e4) {
        } }, { key: "interfaces_", get: function() {
          return [kn];
        } }]), e3;
      }(), In = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(t2) {
          return this._pts[t2];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        } }, { key: "setData", value: function(t2) {
          this._data = t2;
        } }, { key: "safeOctant", value: function(t2, e4) {
          return t2.equals2D(e4) ? 0 : mn.octant(t2, e4);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            this.addIntersectionNode(t2, e4);
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], s2 = new X(n2.getIntersection(r2));
            this.addIntersection(s2, i2);
          }
        } }, { key: "toString", value: function() {
          return Re.toLineString(new Qt(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(t2, e4) {
          var n2 = e4, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        } }, { key: "addIntersections", value: function(t2, e4, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) this.addIntersection(t2, e4, n2, i2);
        } }, { key: "interfaces_", get: function() {
          return [xn];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new pn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e4 = arguments[1];
          this._pts = t2, this._data = e4;
        } }, { key: "getNodedSubstrings", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], n2 = new yt();
            return e3.getNodedSubstrings(t2, n2), n2;
          }
          if (2 === arguments.length) for (var i2 = arguments[0], r2 = arguments[1], s2 = i2.iterator(); s2.hasNext(); ) {
            var a2 = s2.next();
            a2.getNodeList().addSplitEdges(r2);
          }
        } }]), e3;
      }(), En = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0], n2 = ct.index(this.p0, this.p1, t2.p0), i2 = ct.index(this.p0, this.p1, t2.p1);
            return n2 >= 0 && i2 >= 0 || n2 <= 0 && i2 <= 0 ? Math.max(n2, i2) : 0;
          }
          if (arguments[0] instanceof X) {
            var r2 = arguments[0];
            return ct.index(this.p0, this.p1, r2);
          }
        } }, { key: "toGeometry", value: function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(t2) {
          if (!(t2 instanceof e3)) return false;
          var n2 = t2;
          return this.p0.equals(n2.p0) && this.p1.equals(n2.p1);
        } }, { key: "intersection", value: function(t2) {
          var e4 = new Oe();
          return e4.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e4.hasIntersection() ? e4.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof X) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1)) return new X(t2);
            var n2 = this.projectionFactor(t2), i2 = new X();
            return i2.x = this.p0.x + n2 * (this.p1.x - this.p0.x), i2.y = this.p0.y + n2 * (this.p1.y - this.p0.y), i2;
          }
          if (arguments[0] instanceof e3) {
            var r2 = arguments[0], s2 = this.projectionFactor(r2.p0), a2 = this.projectionFactor(r2.p1);
            if (s2 >= 1 && a2 >= 1) return null;
            if (s2 <= 0 && a2 <= 0) return null;
            var o2 = this.project(r2.p0);
            s2 < 0 && (o2 = this.p0), s2 > 1 && (o2 = this.p1);
            var u5 = this.project(r2.p1);
            return a2 < 0 && (u5 = this.p0), a2 > 1 && (u5 = this.p1), new e3(o2, u5);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(t2) {
          return 0 === t2 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(t2) {
          return xt.pointToLinePerpendicular(t2, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return e3.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(t2) {
          if (t2.equals(this.p0)) return 0;
          if (t2.equals(this.p1)) return 1;
          var e4 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e4 * e4 + n2 * n2;
          return i2 <= 0 ? A.NaN : ((t2.x - this.p0.x) * e4 + (t2.y - this.p0.y) * n2) / i2;
        } }, { key: "closestPoints", value: function(t2) {
          var e4 = this.intersection(t2);
          if (null !== e4) return [e4, e4];
          var n2 = new Array(2).fill(null), i2 = A.MAX_VALUE, r2 = null, s2 = this.closestPoint(t2.p0);
          i2 = s2.distance(t2.p0), n2[0] = s2, n2[1] = t2.p0;
          var a2 = this.closestPoint(t2.p1);
          (r2 = a2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = a2, n2[1] = t2.p1);
          var o2 = t2.closestPoint(this.p0);
          (r2 = o2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = o2);
          var u5 = t2.closestPoint(this.p1);
          return (r2 = u5.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u5), n2;
        } }, { key: "closestPoint", value: function(t2) {
          var e4 = this.projectionFactor(t2);
          return e4 > 0 && e4 < 1 ? this.project(t2) : this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2, n2 = this.p0.compareTo(e4.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e4.p1);
        } }, { key: "reverse", value: function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        } }, { key: "equalsTopo", value: function(t2) {
          return this.p0.equals(t2.p0) && this.p1.equals(t2.p1) || this.p0.equals(t2.p1) && this.p1.equals(t2.p0);
        } }, { key: "lineIntersection", value: function(t2) {
          return pt.intersection(this.p0, this.p1, t2.p0, t2.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(t2, e4) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, s2 = this.p1.y - this.p0.y, a2 = Math.sqrt(r2 * r2 + s2 * s2), o2 = 0, u5 = 0;
          if (0 !== e4) {
            if (a2 <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            o2 = e4 * r2 / a2, u5 = e4 * s2 / a2;
          }
          return new X(n2 - u5, i2 + o2);
        } }, { key: "setCoordinates", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this.p0.x = e4.x, this.p0.y = e4.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        } }, { key: "segmentFraction", value: function(t2) {
          var e4 = this.projectionFactor(t2);
          return e4 < 0 ? e4 = 0 : (e4 > 1 || A.isNaN(e4)) && (e4 = 1), e4;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(t2) {
          var e4 = this.p1.getY() - this.p0.getY(), n2 = this.p0.getX() - this.p1.getX(), i2 = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), r2 = e4 * e4 + n2 * n2, s2 = e4 * e4 - n2 * n2, a2 = t2.getX(), o2 = t2.getY();
          return new X((-s2 * a2 - 2 * e4 * n2 * o2 - 2 * e4 * i2) / r2, (s2 * o2 - 2 * e4 * n2 * a2 - 2 * n2 * i2) / r2);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof e3) {
            var t2 = arguments[0];
            return xt.segmentToSegment(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof X) {
            var n2 = arguments[0];
            return xt.pointToSegment(n2, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(t2) {
          var e4 = new X();
          return e4.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e4.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e4;
        } }, { key: "hashCode", value: function() {
          var t2 = A.doubleToLongBits(this.p0.x);
          t2 ^= 31 * A.doubleToLongBits(this.p0.y);
          var e4 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = A.doubleToLongBits(this.p1.x);
          return n2 ^= 31 * A.doubleToLongBits(this.p1.y), e4 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        } }, { key: "interfaces_", get: function() {
          return [x2, E];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length) e3.constructor_.call(this, new X(), new X());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            e3.constructor_.call(this, t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.p0 = n2, this.p1 = i2;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3];
            e3.constructor_.call(this, new X(r2, s2), new X(a2, o2));
          }
        } }, { key: "midPoint", value: function(t2, e4) {
          return new X((t2.x + e4.x) / 2, (t2.y + e4.y) / 2);
        } }]), e3;
      }(), Nn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "overlap", value: function() {
          if (2 === arguments.length) ;
          else if (4 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e4, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new En(), this._overlapSeg2 = new En();
        } }]), e3;
      }(), Tn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getLineSegment", value: function(t2, e4) {
          e4.p0 = this._pts[t2], e4.p1 = this._pts[t2 + 1];
        } }, { key: "computeSelect", value: function(t2, e4, n2, i2) {
          var r2 = this._pts[e4], s2 = this._pts[n2];
          if (n2 - e4 == 1) return i2.select(this, e4), null;
          if (!t2.intersects(r2, s2)) return null;
          var a2 = Math.trunc((e4 + n2) / 2);
          e4 < a2 && this.computeSelect(t2, e4, a2, i2), a2 < n2 && this.computeSelect(t2, a2, n2, i2);
        } }, { key: "getCoordinates", value: function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e4 = 0, n2 = this._start; n2 <= this._end; n2++) t2[e4++] = this._pts[n2];
          return t2;
        } }, { key: "computeOverlaps", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            this.computeOverlaps(this._start, this._end, t2, t2._start, t2._end, e4);
          } else if (6 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s2 = arguments[3], a2 = arguments[4], o2 = arguments[5];
            if (i2 - n2 == 1 && a2 - s2 == 1) return o2.overlap(this, n2, r2, s2), null;
            if (!this.overlaps(n2, i2, r2, s2, a2)) return null;
            var u5 = Math.trunc((n2 + i2) / 2), l2 = Math.trunc((s2 + a2) / 2);
            n2 < u5 && (s2 < l2 && this.computeOverlaps(n2, u5, r2, s2, l2, o2), l2 < a2 && this.computeOverlaps(n2, u5, r2, l2, a2, o2)), u5 < i2 && (s2 < l2 && this.computeOverlaps(u5, i2, r2, s2, l2, o2), l2 < a2 && this.computeOverlaps(u5, i2, r2, l2, a2, o2));
          }
        } }, { key: "setId", value: function(t2) {
          this._id = t2;
        } }, { key: "select", value: function(t2, e4) {
          this.computeSelect(t2, this._start, this._end, e4);
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e4 = this._pts[this._end];
            this._env = new U(t2, e4);
          }
          return this._env;
        } }, { key: "overlaps", value: function(t2, e4, n2, i2, r2) {
          return U.intersects(this._pts[t2], this._pts[e4], n2._pts[i2], n2._pts[r2]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e4, this._end = n2, this._context = i2;
        } }]), e3;
      }(), Sn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "findChainEnd", value: function(t2, e4) {
          for (var n2 = e4; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); ) n2++;
          if (n2 >= t2.length - 1) return t2.length - 1;
          for (var i2 = We.quadrant(t2[n2], t2[n2 + 1]), r2 = e4 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (We.quadrant(t2[r2 - 1], t2[r2]) !== i2) break;
            }
            r2++;
          }
          return r2 - 1;
        } }, { key: "getChains", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return e3.getChains(t2, null);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = new yt(), s2 = 0;
            do {
              var a2 = e3.findChainEnd(n2, s2), o2 = new Tn(n2, s2, a2, i2);
              r2.add(o2), s2 = a2;
            } while (s2 < n2.length - 1);
            return r2;
          }
        } }]), e3;
      }(), Ln = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "computeNodes", value: function(t2) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]), e3;
      }(), Cn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "setSegmentIntersector", value: function(t2) {
          this._segInt = t2;
        } }, { key: "interfaces_", get: function() {
          return [Ln];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        } }]), e3;
      }(), Rn = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return In.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(t2) {
          for (var e4 = Sn.getChains(t2.getCoordinates(), t2).iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            n2.setId(this._idCounter++), this._index.insert(n2.getEnvelope(), n2), this._monoChains.add(n2);
          }
        } }, { key: "computeNodes", value: function(t2) {
          this._nodedSegStrings = t2;
          for (var e4 = t2.iterator(); e4.hasNext(); ) this.add(e4.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var t2 = new wn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); ) for (var n2 = e4.next(), i2 = this._index.query(n2.getEnvelope()).iterator(); i2.hasNext(); ) {
            var r3 = i2.next();
            if (r3.getId() > n2.getId() && (n2.computeOverlaps(r3, t2), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new yt(), this._index = new vn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            Cn.constructor_.call(this, t2);
          }
        } }]), s2;
      }(Cn), wn = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "overlap", value: function() {
          if (4 !== arguments.length) return f(r(a2.prototype), "overlap", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3], s3 = t2.getContext(), o2 = n2.getContext();
          this._si.processIntersections(s3, e4, o2, i2);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var t2 = arguments[0];
          this._si = t2;
        } }]), a2;
      }(Nn);
      Rn.SegmentOverlapAction = wn;
      var On = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "isDeletable", value: function(t2, e4, n2, i2) {
          var r2 = this._inputLine[t2], s2 = this._inputLine[e4], a2 = this._inputLine[n2];
          return !!this.isConcave(r2, s2, a2) && (!!this.isShallow(r2, s2, a2, i2) && this.isShallowSampled(r2, s2, t2, n2, i2));
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var t2 = 1, n2 = this.findNextNonDeletedIndex(t2), i2 = this.findNextNonDeletedIndex(n2), r2 = false; i2 < this._inputLine.length; ) {
            var s2 = false;
            this.isDeletable(t2, n2, i2, this._distanceTol) && (this._isDeleted[n2] = e3.DELETE, s2 = true, r2 = true), t2 = s2 ? i2 : n2, n2 = this.findNextNonDeletedIndex(t2), i2 = this.findNextNonDeletedIndex(n2);
          }
          return r2;
        } }, { key: "isShallowConcavity", value: function(t2, e4, n2, i2) {
          return ct.index(t2, e4, n2) === this._angleOrientation && xt.pointToSegment(e4, t2, n2) < i2;
        } }, { key: "isShallowSampled", value: function(t2, n2, i2, r2, s2) {
          var a2 = Math.trunc((r2 - i2) / e3.NUM_PTS_TO_CHECK);
          a2 <= 0 && (a2 = 1);
          for (var o2 = i2; o2 < r2; o2 += a2) if (!this.isShallow(t2, n2, this._inputLine[o2], s2)) return false;
          return true;
        } }, { key: "isConcave", value: function(t2, e4, n2) {
          var i2 = ct.index(t2, e4, n2) === this._angleOrientation;
          return i2;
        } }, { key: "simplify", value: function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = ct.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e4 = false;
          do {
            e4 = this.deleteShallowConcavities();
          } while (e4);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(t2) {
          for (var n2 = t2 + 1; n2 < this._inputLine.length && this._isDeleted[n2] === e3.DELETE; ) n2++;
          return n2;
        } }, { key: "isShallow", value: function(t2, e4, n2, i2) {
          return xt.pointToSegment(e4, t2, n2) < i2;
        } }, { key: "collapseLine", value: function() {
          for (var t2 = new Zt(), n2 = 0; n2 < this._inputLine.length; n2++) this._isDeleted[n2] !== e3.DELETE && t2.add(this._inputLine[n2]);
          return t2.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ct.COUNTERCLOCKWISE;
          var t2 = arguments[0];
          this._inputLine = t2;
        } }, { key: "simplify", value: function(t2, n2) {
          return new e3(t2).simplify(n2);
        } }]), e3;
      }();
      On.INIT = 0, On.DELETE = 1, On.KEEP = 1, On.NUM_PTS_TO_CHECK = 10;
      var bn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(e3.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(t2) {
          this._precisionModel = t2;
        } }, { key: "addPt", value: function(t2) {
          var e4 = new X(t2);
          if (this._precisionModel.makePrecise(e4), this.isRedundant(e4)) return null;
          this._ptList.add(e4);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(t2, e4) {
          if (e4) for (var n2 = 0; n2 < t2.length; n2++) this.addPt(t2[n2]);
          else for (var i2 = t2.length - 1; i2 >= 0; i2--) this.addPt(t2[i2]);
        } }, { key: "isRedundant", value: function(t2) {
          if (this._ptList.size() < 1) return false;
          var e4 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e4) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new ae().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var t2 = new X(this._ptList.get(0)), e4 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e4)) return null;
          this._ptList.add(t2);
        } }, { key: "setMinimumVertexDistance", value: function(t2) {
          this._minimimVertexDistance = t2;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new yt();
        } }]), e3;
      }();
      bn.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var Mn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, null, [{ key: "toDegrees", value: function(t2) {
          return 180 * t2 / Math.PI;
        } }, { key: "normalize", value: function(t2) {
          for (; t2 > Math.PI; ) t2 -= e3.PI_TIMES_2;
          for (; t2 <= -Math.PI; ) t2 += e3.PI_TIMES_2;
          return t2;
        } }, { key: "angle", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1], i2 = n2.x - e4.x, r2 = n2.y - e4.y;
            return Math.atan2(r2, i2);
          }
        } }, { key: "isAcute", value: function(t2, e4, n2) {
          var i2 = t2.x - e4.x, r2 = t2.y - e4.y;
          return i2 * (n2.x - e4.x) + r2 * (n2.y - e4.y) > 0;
        } }, { key: "isObtuse", value: function(t2, e4, n2) {
          var i2 = t2.x - e4.x, r2 = t2.y - e4.y;
          return i2 * (n2.x - e4.x) + r2 * (n2.y - e4.y) < 0;
        } }, { key: "interiorAngle", value: function(t2, n2, i2) {
          var r2 = e3.angle(n2, t2), s2 = e3.angle(n2, i2);
          return Math.abs(s2 - r2);
        } }, { key: "normalizePositive", value: function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; ) t2 += e3.PI_TIMES_2;
            t2 >= e3.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= e3.PI_TIMES_2; ) t2 -= e3.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        } }, { key: "angleBetween", value: function(t2, n2, i2) {
          var r2 = e3.angle(n2, t2), s2 = e3.angle(n2, i2);
          return e3.diff(r2, s2);
        } }, { key: "diff", value: function(t2, e4) {
          var n2 = null;
          return (n2 = t2 < e4 ? e4 - t2 : t2 - e4) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        } }, { key: "toRadians", value: function(t2) {
          return t2 * Math.PI / 180;
        } }, { key: "getTurn", value: function(t2, n2) {
          var i2 = Math.sin(n2 - t2);
          return i2 > 0 ? e3.COUNTERCLOCKWISE : i2 < 0 ? e3.CLOCKWISE : e3.NONE;
        } }, { key: "angleBetweenOriented", value: function(t2, n2, i2) {
          var r2 = e3.angle(n2, t2), s2 = e3.angle(n2, i2) - r2;
          return s2 <= -Math.PI ? s2 + e3.PI_TIMES_2 : s2 > Math.PI ? s2 - e3.PI_TIMES_2 : s2;
        } }]), e3;
      }();
      Mn.PI_TIMES_2 = 2 * Math.PI, Mn.PI_OVER_2 = Math.PI / 2, Mn.PI_OVER_4 = Math.PI / 4, Mn.COUNTERCLOCKWISE = ct.COUNTERCLOCKWISE, Mn.CLOCKWISE = ct.CLOCKWISE, Mn.NONE = ct.COLLINEAR;
      var An = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "addNextSegment", value: function(t2, e4) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var n2 = ct.index(this._s0, this._s1, this._s2), i2 = n2 === ct.CLOCKWISE && this._side === $.LEFT || n2 === ct.COUNTERCLOCKWISE && this._side === $.RIGHT;
          0 === n2 ? this.addCollinear(e4) : i2 ? this.addOutsideTurn(n2, e4) : this.addInsideTurn(n2, e4);
        } }, { key: "addLineEndCap", value: function(t2, e4) {
          var n2 = new En(t2, e4), i2 = new En();
          this.computeOffsetSegment(n2, $.LEFT, this._distance, i2);
          var r2 = new En();
          this.computeOffsetSegment(n2, $.RIGHT, this._distance, r2);
          var s2 = e4.x - t2.x, a2 = e4.y - t2.y, o2 = Math.atan2(a2, s2);
          switch (this._bufParams.getEndCapStyle()) {
            case _.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addDirectedFillet(e4, o2 + Math.PI / 2, o2 - Math.PI / 2, ct.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case _.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case _.CAP_SQUARE:
              var u5 = new X();
              u5.x = Math.abs(this._distance) * Math.cos(o2), u5.y = Math.abs(this._distance) * Math.sin(o2);
              var l2 = new X(i2.p1.x + u5.x, i2.p1.y + u5.y), h2 = new X(r2.p1.x + u5.x, r2.p1.y + u5.y);
              this._segList.addPt(l2), this._segList.addPt(h2);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(t2, e4, n2, i2) {
          var r2 = pt.intersection(e4.p0, e4.p1, n2.p0, n2.p1);
          if (null !== r2 && (i2 <= 0 ? 1 : r2.distance(t2) / Math.abs(i2)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r2), null;
          this.addLimitedMitreJoin(e4, n2, i2, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(t2, n2) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * e3.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === _.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === _.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n2 && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(t2) {
          this._segList.addPt(new X(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new X(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new X(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new X(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(t2, e4) {
          this._segList.addPts(t2, e4);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(t2, e4, n2, i2, r2) {
          var s2 = e4.x - t2.x, a2 = e4.y - t2.y, o2 = Math.atan2(a2, s2), u5 = n2.x - t2.x, l2 = n2.y - t2.y, h2 = Math.atan2(l2, u5);
          i2 === ct.CLOCKWISE ? o2 <= h2 && (o2 += 2 * Math.PI) : o2 >= h2 && (o2 -= 2 * Math.PI), this._segList.addPt(e4), this.addDirectedFillet(t2, o2, h2, i2, r2), this._segList.addPt(n2);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(t2, e4, n2) {
          this._s1 = t2, this._s2 = e4, this._side = n2, this._seg1.setCoordinates(t2, e4), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(t2, e4, n2, i2) {
          var r2 = this._seg0.p1, s2 = Mn.angle(r2, this._seg0.p0), a2 = Mn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, o2 = Mn.normalize(s2 + a2), u5 = Mn.normalize(o2 + Math.PI), l2 = i2 * n2, h2 = n2 - l2 * Math.abs(Math.sin(a2)), c2 = r2.x + l2 * Math.cos(u5), f2 = r2.y + l2 * Math.sin(u5), v3 = new X(c2, f2), g2 = new En(r2, v3), y3 = g2.pointAlongOffset(1, h2), d2 = g2.pointAlongOffset(1, -h2);
          this._side === $.LEFT ? (this._segList.addPt(y3), this._segList.addPt(d2)) : (this._segList.addPt(d2), this._segList.addPt(y3));
        } }, { key: "addDirectedFillet", value: function(t2, e4, n2, i2, r2) {
          var s2 = i2 === ct.CLOCKWISE ? -1 : 1, a2 = Math.abs(e4 - n2), o2 = Math.trunc(a2 / this._filletAngleQuantum + 0.5);
          if (o2 < 1) return null;
          for (var u5 = a2 / o2, l2 = new X(), h2 = 0; h2 < o2; h2++) {
            var c2 = e4 + s2 * h2 * u5;
            l2.x = t2.x + r2 * Math.cos(c2), l2.y = t2.y + r2 * Math.sin(c2), this._segList.addPt(l2);
          }
        } }, { key: "computeOffsetSegment", value: function(t2, e4, n2, i2) {
          var r2 = e4 === $.LEFT ? 1 : -1, s2 = t2.p1.x - t2.p0.x, a2 = t2.p1.y - t2.p0.y, o2 = Math.sqrt(s2 * s2 + a2 * a2), u5 = r2 * n2 * s2 / o2, l2 = r2 * n2 * a2 / o2;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u5, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u5;
        } }, { key: "addInsideTurn", value: function(t2, n2) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * e3.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var i2 = new X((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
              var r2 = new X((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(r2);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(t2) {
          var e4 = new X(t2.x + this._distance, t2.y);
          this._segList.addPt(e4), this.addDirectedFillet(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(t2, e4) {
          this._segList.addPt(t2.p1), this._segList.addPt(e4.p0);
        } }, { key: "init", value: function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new bn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * e3.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === _.JOIN_BEVEL || this._bufParams.getJoinStyle() === _.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ct.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new En(), this._seg1 = new En(), this._offset0 = new En(), this._offset1 = new En(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var t2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = t2, this._bufParams = n2, this._li = new Oe(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === _.JOIN_ROUND && (this._closingSegLengthFactor = e3.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        } }]), e3;
      }();
      An.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, An.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, An.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, An.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var Pn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getOffsetCurve", value: function(t2, e4) {
          if (this._distance = e4, 0 === e4) return null;
          var n2 = e4 < 0, i2 = Math.abs(e4), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var s2 = r2.getCoordinates();
          return n2 && jt.reverse(s2), s2;
        } }, { key: "computeSingleSidedBufferCurve", value: function(t2, e4, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e4) {
            n2.addSegments(t2, true);
            var r2 = On.simplify(t2, -i2), s2 = r2.length - 1;
            n2.initSideSegments(r2[s2], r2[s2 - 1], $.LEFT), n2.addFirstSegment();
            for (var a2 = s2 - 2; a2 >= 0; a2--) n2.addNextSegment(r2[a2], true);
          } else {
            n2.addSegments(t2, false);
            var o2 = On.simplify(t2, i2), u5 = o2.length - 1;
            n2.initSideSegments(o2[0], o2[1], $.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u5; l2++) n2.addNextSegment(o2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(t2, e4, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e4 === $.RIGHT && (i2 = -i2);
          var r2 = On.simplify(t2, i2), s2 = r2.length - 1;
          n2.initSideSegments(r2[s2 - 1], r2[0], e4);
          for (var a2 = 1; a2 <= s2; a2++) {
            var o2 = 1 !== a2;
            n2.addNextSegment(r2[a2], o2);
          }
          n2.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(t2, e4) {
          var n2 = this.simplifyTolerance(this._distance), i2 = On.simplify(t2, n2), r2 = i2.length - 1;
          e4.initSideSegments(i2[0], i2[1], $.LEFT);
          for (var s2 = 2; s2 <= r2; s2++) e4.addNextSegment(i2[s2], true);
          e4.addLastSegment(), e4.addLineEndCap(i2[r2 - 1], i2[r2]);
          var a2 = On.simplify(t2, -n2), o2 = a2.length - 1;
          e4.initSideSegments(a2[o2], a2[o2 - 1], $.LEFT);
          for (var u5 = o2 - 2; u5 >= 0; u5--) e4.addNextSegment(a2[u5], true);
          e4.addLastSegment(), e4.addLineEndCap(a2[1], a2[0]), e4.closeRing();
        } }, { key: "computePointCurve", value: function(t2, e4) {
          switch (this._bufParams.getEndCapStyle()) {
            case _.CAP_ROUND:
              e4.createCircle(t2);
              break;
            case _.CAP_SQUARE:
              e4.createSquare(t2);
          }
        } }, { key: "getLineCurve", value: function(t2, e4) {
          if (this._distance = e4, this.isLineOffsetEmpty(e4)) return null;
          var n2 = Math.abs(e4), i2 = this.getSegGen(n2);
          if (t2.length <= 1) this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e4 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(t2, n2, i2) {
          if (this._distance = i2, t2.length <= 2) return this.getLineCurve(t2, i2);
          if (0 === i2) return e3.copyCoordinates(t2);
          var r2 = this.getSegGen(i2);
          return this.computeRingBufferCurve(t2, n2, r2), r2.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(t2, e4, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e4) {
            var r2 = On.simplify(t2, -i2), s2 = r2.length - 1;
            n2.initSideSegments(r2[s2], r2[s2 - 1], $.LEFT), n2.addFirstSegment();
            for (var a2 = s2 - 2; a2 >= 0; a2--) n2.addNextSegment(r2[a2], true);
          } else {
            var o2 = On.simplify(t2, i2), u5 = o2.length - 1;
            n2.initSideSegments(o2[0], o2[1], $.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u5; l2++) n2.addNextSegment(o2[l2], true);
          }
          n2.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(t2) {
          return 0 === t2 || t2 < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(t2) {
          return new An(this._precisionModel, this._bufParams, t2);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e4 = arguments[1];
          this._precisionModel = t2, this._bufParams = e4;
        } }, { key: "copyCoordinates", value: function(t2) {
          for (var e4 = new Array(t2.length).fill(null), n2 = 0; n2 < e4.length; n2++) e4[n2] = new X(t2[n2]);
          return e4;
        } }]), e3;
      }(), Dn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "findStabbedSegments", value: function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e4 = new yt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e4);
            }
            return e4;
          }
          if (3 === arguments.length) {
            if (rt(arguments[2], nt) && arguments[0] instanceof X && arguments[1] instanceof Je) for (var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = a2.getEdge().getCoordinates(), l2 = 0; l2 < u5.length - 1; l2++) {
              this._seg.p0 = u5[l2], this._seg.p1 = u5[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
              var h2 = Math.max(this._seg.p0.x, this._seg.p1.x);
              if (!(h2 < s2.x) && !(this._seg.isHorizontal() || s2.y < this._seg.p0.y || s2.y > this._seg.p1.y || ct.index(this._seg.p0, this._seg.p1, s2) === ct.RIGHT)) {
                var c2 = a2.getDepth($.LEFT);
                this._seg.p0.equals(u5[l2]) || (c2 = a2.getDepth($.RIGHT));
                var f2 = new Fn(this._seg, c2);
                o2.add(f2);
              }
            }
            else if (rt(arguments[2], nt) && arguments[0] instanceof X && rt(arguments[1], nt)) for (var v3 = arguments[0], g2 = arguments[1], y3 = arguments[2], d2 = g2.iterator(); d2.hasNext(); ) {
              var _2 = d2.next();
              _2.isForward() && this.findStabbedSegments(v3, _2, y3);
            }
          }
        } }, { key: "getDepth", value: function(t2) {
          var e4 = this.findStabbedSegments(t2);
          return 0 === e4.size() ? 0 : on.min(e4)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new En();
          var t2 = arguments[0];
          this._subgraphs = t2;
        } }]), e3;
      }(), Fn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "compareTo", value: function(t2) {
          var e4 = t2;
          if (this._upwardSeg.minX() >= e4._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= e4._upwardSeg.minX()) return -1;
          var n2 = this._upwardSeg.orientationIndex(e4._upwardSeg);
          return 0 !== n2 || 0 !== (n2 = -1 * e4._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e4._upwardSeg);
        } }, { key: "compareX", value: function(t2, e4) {
          var n2 = t2.p0.compareTo(e4.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e4.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e4 = arguments[1];
          this._upwardSeg = new En(t2), this._leftDepth = e4;
        } }]), e3;
      }();
      Dn.DepthSegment = Fn;
      var Gn = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          var e4;
          return t(this, s2), e4 = r2.call(this), s2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(s2, null, [{ key: "constructor_", value: function() {
          p.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]), s2;
      }(p), qn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getY", value: function() {
          var t2 = this.y / this.w;
          if (A.isNaN(t2) || A.isInfinite(t2)) throw new Gn();
          return t2;
        } }, { key: "getX", value: function() {
          var t2 = this.x / this.w;
          if (A.isNaN(t2) || A.isInfinite(t2)) throw new Gn();
          return t2;
        } }, { key: "getCoordinate", value: function() {
          var t2 = new X();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.x = t2.x, this.y = t2.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof e3 && arguments[1] instanceof e3) {
              var r2 = arguments[0], s2 = arguments[1];
              this.x = r2.y * s2.w - s2.y * r2.w, this.y = s2.x * r2.w - r2.x * s2.w, this.w = r2.x * s2.y - s2.x * r2.y;
            } else if (arguments[0] instanceof X && arguments[1] instanceof X) {
              var a2 = arguments[0], o2 = arguments[1];
              this.x = a2.y - o2.y, this.y = o2.x - a2.x, this.w = a2.x * o2.y - o2.x * a2.y;
            }
          } else if (3 === arguments.length) {
            var u5 = arguments[0], l2 = arguments[1], h2 = arguments[2];
            this.x = u5, this.y = l2, this.w = h2;
          } else if (4 === arguments.length) {
            var c2 = arguments[0], f2 = arguments[1], v3 = arguments[2], g2 = arguments[3], y3 = c2.y - f2.y, d2 = f2.x - c2.x, _2 = c2.x * f2.y - f2.x * c2.y, p2 = v3.y - g2.y, m2 = g2.x - v3.x, k2 = v3.x * g2.y - g2.x * v3.y;
            this.x = d2 * k2 - m2 * _2, this.y = p2 * _2 - y3 * k2, this.w = y3 * m2 - p2 * d2;
          }
        } }]), e3;
      }(), Yn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "area", value: function() {
          return e3.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return e3.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(t2) {
          if (null === t2) throw new m("Supplied point is null.");
          return e3.interpolateZ(t2, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return e3.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return e3.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return e3.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return e3.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return e3.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return e3.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          this.p0 = t2, this.p1 = e4, this.p2 = n2;
        } }, { key: "area", value: function(t2, e4, n2) {
          return Math.abs(((n2.x - t2.x) * (e4.y - t2.y) - (e4.x - t2.x) * (n2.y - t2.y)) / 2);
        } }, { key: "signedArea", value: function(t2, e4, n2) {
          return ((n2.x - t2.x) * (e4.y - t2.y) - (e4.x - t2.x) * (n2.y - t2.y)) / 2;
        } }, { key: "det", value: function(t2, e4, n2, i2) {
          return t2 * i2 - e4 * n2;
        } }, { key: "interpolateZ", value: function(t2, e4, n2, i2) {
          var r2 = e4.x, s2 = e4.y, a2 = n2.x - r2, o2 = i2.x - r2, u5 = n2.y - s2, l2 = i2.y - s2, h2 = a2 * l2 - o2 * u5, c2 = t2.x - r2, f2 = t2.y - s2, v3 = (l2 * c2 - o2 * f2) / h2, g2 = (-u5 * c2 + a2 * f2) / h2;
          return e4.getZ() + v3 * (n2.getZ() - e4.getZ()) + g2 * (i2.getZ() - e4.getZ());
        } }, { key: "longestSideLength", value: function(t2, e4, n2) {
          var i2 = t2.distance(e4), r2 = e4.distance(n2), s2 = n2.distance(t2), a2 = i2;
          return r2 > a2 && (a2 = r2), s2 > a2 && (a2 = s2), a2;
        } }, { key: "circumcentreDD", value: function(t2, e4, n2) {
          var i2 = ut.valueOf(t2.x).subtract(n2.x), r2 = ut.valueOf(t2.y).subtract(n2.y), s2 = ut.valueOf(e4.x).subtract(n2.x), a2 = ut.valueOf(e4.y).subtract(n2.y), o2 = ut.determinant(i2, r2, s2, a2).multiply(2), u5 = i2.sqr().add(r2.sqr()), l2 = s2.sqr().add(a2.sqr()), h2 = ut.determinant(r2, u5, a2, l2), c2 = ut.determinant(i2, u5, s2, l2), f2 = ut.valueOf(n2.x).subtract(h2.divide(o2)).doubleValue(), v3 = ut.valueOf(n2.y).add(c2.divide(o2)).doubleValue();
          return new X(f2, v3);
        } }, { key: "isAcute", value: function(t2, e4, n2) {
          return !!Mn.isAcute(t2, e4, n2) && (!!Mn.isAcute(e4, n2, t2) && !!Mn.isAcute(n2, t2, e4));
        } }, { key: "circumcentre", value: function(t2, n2, i2) {
          var r2 = i2.x, s2 = i2.y, a2 = t2.x - r2, o2 = t2.y - s2, u5 = n2.x - r2, l2 = n2.y - s2, h2 = 2 * e3.det(a2, o2, u5, l2), c2 = e3.det(o2, a2 * a2 + o2 * o2, l2, u5 * u5 + l2 * l2), f2 = e3.det(a2, a2 * a2 + o2 * o2, u5, u5 * u5 + l2 * l2);
          return new X(r2 - c2 / h2, s2 + f2 / h2);
        } }, { key: "perpendicularBisector", value: function(t2, e4) {
          var n2 = e4.x - t2.x, i2 = e4.y - t2.y, r2 = new qn(t2.x + n2 / 2, t2.y + i2 / 2, 1), s2 = new qn(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new qn(r2, s2);
        } }, { key: "angleBisector", value: function(t2, e4, n2) {
          var i2 = e4.distance(t2), r2 = i2 / (i2 + e4.distance(n2)), s2 = n2.x - t2.x, a2 = n2.y - t2.y;
          return new X(t2.x + r2 * s2, t2.y + r2 * a2);
        } }, { key: "area3D", value: function(t2, e4, n2) {
          var i2 = e4.x - t2.x, r2 = e4.y - t2.y, s2 = e4.getZ() - t2.getZ(), a2 = n2.x - t2.x, o2 = n2.y - t2.y, u5 = n2.getZ() - t2.getZ(), l2 = r2 * u5 - s2 * o2, h2 = s2 * a2 - i2 * u5, c2 = i2 * o2 - r2 * a2, f2 = l2 * l2 + h2 * h2 + c2 * c2, v3 = Math.sqrt(f2) / 2;
          return v3;
        } }, { key: "centroid", value: function(t2, e4, n2) {
          var i2 = (t2.x + e4.x + n2.x) / 3, r2 = (t2.y + e4.y + n2.y) / 3;
          return new X(i2, r2);
        } }, { key: "inCentre", value: function(t2, e4, n2) {
          var i2 = e4.distance(n2), r2 = t2.distance(n2), s2 = t2.distance(e4), a2 = i2 + r2 + s2, o2 = (i2 * t2.x + r2 * e4.x + s2 * n2.x) / a2, u5 = (i2 * t2.y + r2 * e4.y + s2 * n2.y) / a2;
          return new X(o2, u5);
        } }]), e3;
      }(), zn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "addRingSide", value: function(t2, e4, n2, i2, r2) {
          if (0 === e4 && t2.length < Xt.MINIMUM_VALID_SIZE) return null;
          var s2 = i2, a2 = r2;
          t2.length >= Xt.MINIMUM_VALID_SIZE && ct.isCCW(t2) && (s2 = r2, a2 = i2, n2 = $.opposite(n2));
          var o2 = this._curveBuilder.getRingCurve(t2, n2, e4);
          this.addCurve(o2, s2, a2);
        } }, { key: "addRingBothSides", value: function(t2, e4) {
          this.addRingSide(t2, e4, $.LEFT, H.EXTERIOR, H.INTERIOR), this.addRingSide(t2, e4, $.RIGHT, H.INTERIOR, H.EXTERIOR);
        } }, { key: "addPoint", value: function(t2) {
          if (this._distance <= 0) return null;
          var e4 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e4, this._distance);
          this.addCurve(n2, H.EXTERIOR, H.INTERIOR);
        } }, { key: "addPolygon", value: function(t2) {
          var e4 = this._distance, n2 = $.LEFT;
          this._distance < 0 && (e4 = -this._distance, n2 = $.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = jt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance)) return null;
          if (this._distance <= 0 && r2.length < 3) return null;
          this.addRingSide(r2, e4, n2, H.EXTERIOR, H.INTERIOR);
          for (var s2 = 0; s2 < t2.getNumInteriorRing(); s2++) {
            var a2 = t2.getInteriorRingN(s2), o2 = jt.removeRepeatedPoints(a2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(a2, -this._distance) || this.addRingSide(o2, e4, $.opposite(n2), H.INTERIOR, H.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(t2, e4) {
          var n2 = new Yn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return xt.pointToSegment(i2, n2.p0, n2.p1) < Math.abs(e4);
        } }, { key: "addLineString", value: function(t2) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var e4 = jt.removeRepeatedPoints(t2.getCoordinates());
          if (jt.isRing(e4) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e4, this._distance);
          else {
            var n2 = this._curveBuilder.getLineCurve(e4, this._distance);
            this.addCurve(n2, H.EXTERIOR, H.INTERIOR);
          }
        } }, { key: "addCurve", value: function(t2, e4, n2) {
          if (null === t2 || t2.length < 2) return null;
          var i2 = new In(t2, new Pe(0, H.BOUNDARY, e4, n2));
          this._curveList.add(i2);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(t2) {
          if (t2.isEmpty()) return null;
          if (t2 instanceof Dt) this.addPolygon(t2);
          else if (t2 instanceof wt) this.addLineString(t2);
          else if (t2 instanceof bt) this.addPoint(t2);
          else if (t2 instanceof zt) this.addCollection(t2);
          else if (t2 instanceof se) this.addCollection(t2);
          else if (t2 instanceof te) this.addCollection(t2);
          else {
            if (!(t2 instanceof Yt)) throw new W(t2.getGeometryType());
            this.addCollection(t2);
          }
        } }, { key: "isErodedCompletely", value: function(t2, e4) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4) return e4 < 0;
          if (4 === n2.length) return this.isTriangleErodedCompletely(n2, e4);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e4 < 0 && 2 * Math.abs(e4) > r2;
        } }, { key: "addCollection", value: function(t2) {
          for (var e4 = 0; e4 < t2.getNumGeometries(); e4++) {
            var n2 = t2.getGeometryN(e4);
            this.add(n2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new yt();
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e4, this._curveBuilder = n2;
        } }]), e3;
      }(), Xn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "locate", value: function(t2) {
        } }]), e3;
      }(), Bn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = false, e3.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new j();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof Yt ? (this._subcollectionIterator = new e3(t2), this._subcollectionIterator.next()) : t2;
        } }, { key: "remove", value: function() {
          throw new W(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [_n];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        } }, { key: "isAtomic", value: function(t2) {
          return !(t2 instanceof Yt);
        } }]), e3;
      }(), Un = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "locate", value: function(t2) {
          return e3.locate(t2, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [Xn];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        } }, { key: "locatePointInPolygon", value: function(t2, n2) {
          if (n2.isEmpty()) return H.EXTERIOR;
          var i2 = n2.getExteriorRing(), r2 = e3.locatePointInRing(t2, i2);
          if (r2 !== H.INTERIOR) return r2;
          for (var s2 = 0; s2 < n2.getNumInteriorRing(); s2++) {
            var a2 = n2.getInteriorRingN(s2), o2 = e3.locatePointInRing(t2, a2);
            if (o2 === H.BOUNDARY) return H.BOUNDARY;
            if (o2 === H.INTERIOR) return H.EXTERIOR;
          }
          return H.INTERIOR;
        } }, { key: "locatePointInRing", value: function(t2, e4) {
          return e4.getEnvelopeInternal().intersects(t2) ? Me.locateInRing(t2, e4.getCoordinates()) : H.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(t2, n2) {
          return H.EXTERIOR !== e3.locatePointInPolygon(t2, n2);
        } }, { key: "locateInGeometry", value: function(t2, n2) {
          if (n2 instanceof Dt) return e3.locatePointInPolygon(t2, n2);
          if (n2 instanceof Yt) for (var i2 = new Bn(n2); i2.hasNext(); ) {
            var r2 = i2.next();
            if (r2 !== n2) {
              var s2 = e3.locateInGeometry(t2, r2);
              if (s2 !== H.EXTERIOR) return s2;
            }
          }
          return H.EXTERIOR;
        } }, { key: "isContained", value: function(t2, n2) {
          return H.EXTERIOR !== e3.locate(t2, n2);
        } }, { key: "locate", value: function(t2, n2) {
          return n2.isEmpty() ? H.EXTERIOR : n2.getEnvelopeInternal().intersects(t2) ? e3.locateInGeometry(t2, n2) : H.EXTERIOR;
        } }]), e3;
      }(), Vn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getNextCW", value: function(t2) {
          this.getEdges();
          var e4 = this._edgeList.indexOf(t2), n2 = e4 - 1;
          return 0 === e4 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        } }, { key: "propagateSideLabels", value: function(t2) {
          for (var e4 = H.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, $.LEFT) !== H.NONE && (e4 = i2.getLocation(t2, $.LEFT));
          }
          if (e4 === H.NONE) return null;
          for (var r2 = e4, s2 = this.iterator(); s2.hasNext(); ) {
            var a2 = s2.next(), o2 = a2.getLabel();
            if (o2.getLocation(t2, $.ON) === H.NONE && o2.setLocation(t2, $.ON, r2), o2.isArea(t2)) {
              var u5 = o2.getLocation(t2, $.LEFT), l2 = o2.getLocation(t2, $.RIGHT);
              if (l2 !== H.NONE) {
                if (l2 !== r2) throw new vt("side location conflict", a2.getCoordinate());
                u5 === H.NONE && G.shouldNeverReachHere("found single null side (at " + a2.getCoordinate() + ")"), r2 = u5;
              } else G.isTrue(o2.getLocation(t2, $.LEFT) === H.NONE, "found single null side"), o2.setLocation(t2, $.RIGHT, r2), o2.setLocation(t2, $.LEFT, r2);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var t2 = this.iterator();
          return t2.hasNext() ? t2.next().getCoordinate() : null;
        } }, { key: "print", value: function(t2) {
          mt.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            e4.next().print(t2);
          }
        } }, { key: "isAreaLabelsConsistent", value: function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(t2) {
          var e4 = this.getEdges();
          if (e4.size() <= 0) return true;
          var n2 = e4.size() - 1, i2 = e4.get(n2).getLabel().getLocation(t2, $.LEFT);
          G.isTrue(i2 !== H.NONE, "Found unlabelled area edge");
          for (var r2 = i2, s2 = this.iterator(); s2.hasNext(); ) {
            var a2 = s2.next().getLabel();
            G.isTrue(a2.isArea(t2), "Found non-area edge");
            var o2 = a2.getLocation(t2, $.LEFT), u5 = a2.getLocation(t2, $.RIGHT);
            if (o2 === u5) return false;
            if (u5 !== r2) return false;
            r2 = o2;
          }
          return true;
        } }, { key: "findIndex", value: function(t2) {
          this.iterator();
          for (var e4 = 0; e4 < this._edgeList.size(); e4++) {
            if (this._edgeList.get(e4) === t2) return e4;
          }
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return null === this._edgeList && (this._edgeList = new yt(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(t2, e4, n2) {
          return this._ptInAreaLocation[t2] === H.NONE && (this._ptInAreaLocation[t2] = Un.locate(e4, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        } }, { key: "toString", value: function() {
          var t2 = new st();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        } }, { key: "computeEdgeEndLabels", value: function(t2) {
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            e4.next().computeLabel(t2);
          }
        } }, { key: "computeLabelling", value: function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e4 = [false, false], n2 = this.iterator(); n2.hasNext(); ) for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++) i2.isLine(r2) && i2.getLocation(r2) === H.BOUNDARY && (e4[r2] = true);
          for (var s2 = this.iterator(); s2.hasNext(); ) for (var a2 = s2.next(), o2 = a2.getLabel(), u5 = 0; u5 < 2; u5++) if (o2.isAnyNull(u5)) {
            var l2 = H.NONE;
            if (e4[u5]) l2 = H.EXTERIOR;
            else {
              var h2 = a2.getCoordinate();
              l2 = this.getLocation(u5, h2, t2);
            }
            o2.setAllLocationsIfNull(u5, l2);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(t2, e4) {
          this._edgeMap.put(t2, e4), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new Ze(), this._edgeList = null, this._ptInAreaLocation = [H.NONE, H.NONE];
        } }]), e3;
      }(), Hn = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var t2 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
            var r2 = this._resultAreaEdgeList.get(i2), s3 = r2.getSym();
            if (r2.getLabel().isArea()) switch (null === t2 && r2.isInResult() && (t2 = r2), n2) {
              case this._SCANNING_FOR_INCOMING:
                if (!s3.isInResult()) continue;
                e4 = s3, n2 = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!r2.isInResult()) continue;
                e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
            }
          }
          if (n2 === this._LINKING_TO_OUTGOING) {
            if (null === t2) throw new vt("no outgoing dirEdge found", this.getCoordinate());
            G.isTrue(t2.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t2);
          }
        } }, { key: "insert", value: function(t2) {
          var e4 = t2;
          this.insertEdgeEnd(e4, e4);
        } }, { key: "getRightmostEdge", value: function() {
          var t2 = this.getEdges(), e4 = t2.size();
          if (e4 < 1) return null;
          var n2 = t2.get(0);
          if (1 === e4) return n2;
          var i2 = t2.get(e4 - 1), r2 = n2.getQuadrant(), s3 = i2.getQuadrant();
          return We.isNorthern(r2) && We.isNorthern(s3) ? n2 : We.isNorthern(r2) || We.isNorthern(s3) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (G.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
        } }, { key: "print", value: function(t2) {
          mt.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            t2.print("out "), n2.print(t2), t2.println(), t2.print("in "), n2.getSym().print(t2), t2.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new yt();
          for (var t2 = this.iterator(); t2.hasNext(); ) {
            var e4 = t2.next();
            (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(t2) {
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            var n2 = e4.next().getLabel();
            n2.setAllLocationsIfNull(0, t2.getLocation(0)), n2.setAllLocationsIfNull(1, t2.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var t2 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
            var i2 = this._edgeList.get(n2), r2 = i2.getSym();
            null === e4 && (e4 = r2), null !== t2 && r2.setNext(t2), t2 = i2;
          }
          e4.setNext(t2);
        } }, { key: "computeDepths", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e4 = this.findIndex(t2), n2 = t2.getDepth($.LEFT), i2 = t2.getDepth($.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2), s3 = this.computeDepths(0, e4, r2);
            if (s3 !== i2) throw new vt("depth mismatch at " + t2.getCoordinate());
          } else if (3 === arguments.length) {
            for (var a3 = arguments[0], o2 = arguments[1], u5 = arguments[2], l2 = u5, h2 = a3; h2 < o2; h2++) {
              var c2 = this._edgeList.get(h2);
              c2.setEdgeDepths($.RIGHT, l2), l2 = c2.getDepth($.LEFT);
            }
            return l2;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var t2 = this.iterator(); t2.hasNext(); ) {
            var e4 = t2.next();
            e4.getLabel().merge(e4.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(t2) {
          for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
            var s3 = this._resultAreaEdgeList.get(r2), a3 = s3.getSym();
            switch (null === e4 && s3.getEdgeRing() === t2 && (e4 = s3), i2) {
              case this._SCANNING_FOR_INCOMING:
                if (a3.getEdgeRing() !== t2) continue;
                n2 = a3, i2 = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (s3.getEdgeRing() !== t2) continue;
                n2.setNextMin(s3), i2 = this._SCANNING_FOR_INCOMING;
            }
          }
          i2 === this._LINKING_TO_OUTGOING && (G.isTrue(null !== e4, "found null for first outgoing dirEdge"), G.isTrue(e4.getEdgeRing() === t2, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
        } }, { key: "getOutgoingDegree", value: function() {
          if (0 === arguments.length) {
            for (var t2 = 0, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isInResult() && t2++;
            }
            return t2;
          }
          if (1 === arguments.length) {
            for (var i2 = arguments[0], r2 = 0, s3 = this.iterator(); s3.hasNext(); ) {
              var a3 = s3.next();
              a3.getEdgeRing() === i2 && r2++;
            }
            return r2;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var t2 = H.NONE, e4 = this.iterator(); e4.hasNext(); ) {
            var n2 = e4.next(), i2 = n2.getSym();
            if (!n2.isLineEdge()) {
              if (n2.isInResult()) {
                t2 = H.INTERIOR;
                break;
              }
              if (i2.isInResult()) {
                t2 = H.EXTERIOR;
                break;
              }
            }
          }
          if (t2 === H.NONE) return null;
          for (var r2 = t2, s3 = this.iterator(); s3.hasNext(); ) {
            var a3 = s3.next(), o2 = a3.getSym();
            a3.isLineEdge() ? a3.getEdge().setCovered(r2 === H.INTERIOR) : (a3.isInResult() && (r2 = H.EXTERIOR), o2.isInResult() && (r2 = H.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(t2) {
          f(r(a2.prototype), "computeLabelling", this).call(this, t2), this._label = new Pe(H.NONE);
          for (var e4 = this.iterator(); e4.hasNext(); ) for (var n2 = e4.next().getEdge().getLabel(), i2 = 0; i2 < 2; i2++) {
            var s3 = n2.getLocation(i2);
            s3 !== H.INTERIOR && s3 !== H.BOUNDARY || this._label.setLocation(i2, H.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]), a2;
      }(Vn), Zn = function(e3) {
        i(s2, e3);
        var r2 = c(s2);
        function s2() {
          return t(this, s2), r2.call(this);
        }
        return n(s2, [{ key: "createNode", value: function(t2) {
          return new Ye(t2, new Hn());
        } }]), s2;
      }(Qe), jn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "compareTo", value: function(t2) {
          var n2 = t2;
          return e3.compareOriented(this._pts, this._orientation, n2._pts, n2._orientation);
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var t2 = arguments[0];
          this._pts = t2, this._orientation = e3.orientation(t2);
        } }, { key: "orientation", value: function(t2) {
          return 1 === jt.increasingDirection(t2);
        } }, { key: "compareOriented", value: function(t2, e4, n2, i2) {
          for (var r2 = e4 ? 1 : -1, s2 = i2 ? 1 : -1, a2 = e4 ? t2.length : -1, o2 = i2 ? n2.length : -1, u5 = e4 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var h2 = t2[u5].compareTo(n2[l2]);
            if (0 !== h2) return h2;
            var c2 = (u5 += r2) === a2, f2 = (l2 += s2) === o2;
            if (c2 && !f2) return -1;
            if (!c2 && f2) return 1;
            if (c2 && f2) return 0;
          }
        } }]), e3;
      }(), Wn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "print", value: function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e4 = 0; e4 < this._edges.size(); e4++) {
            var n2 = this._edges.get(e4);
            e4 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        } }, { key: "addAll", value: function(t2) {
          for (var e4 = t2.iterator(); e4.hasNext(); ) this.add(e4.next());
        } }, { key: "findEdgeIndex", value: function(t2) {
          for (var e4 = 0; e4 < this._edges.size(); e4++) if (this._edges.get(e4).equals(t2)) return e4;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(t2) {
          return this._edges.get(t2);
        } }, { key: "findEqualEdge", value: function(t2) {
          var e4 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e4);
        } }, { key: "add", value: function(t2) {
          this._edges.add(t2);
          var e4 = new jn(t2.getCoordinates());
          this._ocaMap.put(e4, t2);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new yt(), this._ocaMap = new Ze();
        } }]), e3;
      }(), Kn = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "processIntersections", value: function(t2, e4, n2, i2) {
        } }, { key: "isDone", value: function() {
        } }]), e3;
      }(), Jn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "isTrivialIntersection", value: function(t2, n2, i2, r2) {
          if (t2 === i2 && 1 === this._li.getIntersectionNum()) {
            if (e3.isAdjacentSegments(n2, r2)) return true;
            if (t2.isClosed()) {
              var s2 = t2.size() - 1;
              if (0 === n2 && r2 === s2 || 0 === r2 && n2 === s2) return true;
            }
          }
          return false;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(t2, e4, n2, i2) {
          if (t2 === n2 && e4 === i2) return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e4], s2 = t2.getCoordinates()[e4 + 1], a2 = n2.getCoordinates()[i2], o2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, s2, a2, o2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e4, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e4, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [Kn];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        } }, { key: "isAdjacentSegments", value: function(t2, e4) {
          return 1 === Math.abs(t2 - e4);
        } }]), e3;
      }(), Qn = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(t2) {
          var e4 = t2;
          return this.compare(e4.segmentIndex, e4.dist);
        } }, { key: "isEndPoint", value: function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(t2, e4) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e4 ? -1 : this.dist > e4 ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [x2];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          this.coord = new X(t2), this.segmentIndex = e4, this.dist = n2;
        } }]), e3;
      }(), $n = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "print", value: function(t2) {
          t2.println("Intersections:");
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            e4.next().print(t2);
          }
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(t2) {
          this.addEndpoints();
          for (var e4 = this.iterator(), n2 = e4.next(); e4.hasNext(); ) {
            var i2 = e4.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        } }, { key: "addEndpoints", value: function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        } }, { key: "createSplitEdge", value: function(t2, e4) {
          var n2 = e4.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e4.segmentIndex], r2 = e4.dist > 0 || !e4.coord.equals2D(i2);
          r2 || n2--;
          var s2 = new Array(n2).fill(null), a2 = 0;
          s2[a2++] = new X(t2.coord);
          for (var o2 = t2.segmentIndex + 1; o2 <= e4.segmentIndex; o2++) s2[a2++] = this.edge.pts[o2];
          return r2 && (s2[a2] = e4.coord), new si(s2, new Pe(this.edge._label));
        } }, { key: "add", value: function(t2, e4, n2) {
          var i2 = new Qn(t2, e4, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        } }, { key: "isIntersection", value: function(t2) {
          for (var e4 = this.iterator(); e4.hasNext(); ) {
            if (e4.next().coord.equals(t2)) return true;
          }
          return false;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ze(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        } }]), e3;
      }(), ti = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || e3.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || e3.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || e3.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || e3.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || e3.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || e3.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;
        } }, { key: "set", value: function() {
          if (1 === arguments.length) for (var t2 = arguments[0], e4 = 0; e4 < t2.length; e4++) {
            var n2 = Math.trunc(e4 / 3), i2 = e4 % 3;
            this._matrix[n2][i2] = Lt.toDimensionValue(t2.charAt(e4));
          }
          else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this._matrix[r2][s2] = a2;
          }
        } }, { key: "isContains", value: function() {
          return e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (1 === arguments.length) for (var t2 = arguments[0], e4 = 0; e4 < t2.length; e4++) {
            var n2 = Math.trunc(e4 / 3), i2 = e4 % 3;
            this.setAtLeast(n2, i2, Lt.toDimensionValue(t2.charAt(e4)));
          }
          else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this._matrix[r2][s2] < a2 && (this._matrix[r2][s2] = a2);
          }
        } }, { key: "setAtLeastIfValid", value: function(t2, e4, n2) {
          t2 >= 0 && e4 >= 0 && this.setAtLeast(t2, e4, n2);
        } }, { key: "isWithin", value: function() {
          return e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;
        } }, { key: "isTouches", value: function(t2, n2) {
          return t2 > n2 ? this.isTouches(n2, t2) : (t2 === Lt.A && n2 === Lt.A || t2 === Lt.L && n2 === Lt.L || t2 === Lt.L && n2 === Lt.A || t2 === Lt.P && n2 === Lt.A || t2 === Lt.P && n2 === Lt.L) && (this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && (e3.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || e3.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || e3.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])));
        } }, { key: "isOverlaps", value: function(t2, n2) {
          return t2 === Lt.P && n2 === Lt.P || t2 === Lt.A && n2 === Lt.A ? e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && e3.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && e3.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : t2 === Lt.L && n2 === Lt.L && (1 === this._matrix[H.INTERIOR][H.INTERIOR] && e3.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && e3.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]));
        } }, { key: "isEquals", value: function(t2, n2) {
          return t2 === n2 && (e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE);
        } }, { key: "toString", value: function() {
          for (var t2 = new Jt("123456789"), e4 = 0; e4 < 3; e4++) for (var n2 = 0; n2 < 3; n2++) t2.setCharAt(3 * e4 + n2, Lt.toDimensionSymbol(this._matrix[e4][n2]));
          return t2.toString();
        } }, { key: "setAll", value: function(t2) {
          for (var e4 = 0; e4 < 3; e4++) for (var n2 = 0; n2 < 3; n2++) this._matrix[e4][n2] = t2;
        } }, { key: "get", value: function(t2, e4) {
          return this._matrix[t2][e4];
        } }, { key: "transpose", value: function() {
          var t2 = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t2, t2 = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t2, t2 = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t2, this;
        } }, { key: "matches", value: function(t2) {
          if (9 !== t2.length) throw new m("Should be length 9: " + t2);
          for (var n2 = 0; n2 < 3; n2++) for (var i2 = 0; i2 < 3; i2++) if (!e3.matches(this._matrix[n2][i2], t2.charAt(3 * n2 + i2))) return false;
          return true;
        } }, { key: "add", value: function(t2) {
          for (var e4 = 0; e4 < 3; e4++) for (var n2 = 0; n2 < 3; n2++) this.setAtLeast(e4, n2, t2.get(e4, n2));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.INTERIOR][H.BOUNDARY] === Lt.FALSE && this._matrix[H.BOUNDARY][H.INTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "isCrosses", value: function(t2, n2) {
          return t2 === Lt.P && n2 === Lt.L || t2 === Lt.P && n2 === Lt.A || t2 === Lt.L && n2 === Lt.A ? e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && e3.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) : t2 === Lt.L && n2 === Lt.P || t2 === Lt.A && n2 === Lt.P || t2 === Lt.A && n2 === Lt.L ? e3.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && e3.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : t2 === Lt.L && n2 === Lt.L && 0 === this._matrix[H.INTERIOR][H.INTERIOR];
        } }, { key: "interfaces_", get: function() {
          return [I];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(function() {
            return Array(3);
          }), this.setAll(Lt.FALSE);
          else if (1 === arguments.length) {
            if ("string" == typeof arguments[0]) {
              var t2 = arguments[0];
              e3.constructor_.call(this), this.set(t2);
            } else if (arguments[0] instanceof e3) {
              var n2 = arguments[0];
              e3.constructor_.call(this), this._matrix[H.INTERIOR][H.INTERIOR] = n2._matrix[H.INTERIOR][H.INTERIOR], this._matrix[H.INTERIOR][H.BOUNDARY] = n2._matrix[H.INTERIOR][H.BOUNDARY], this._matrix[H.INTERIOR][H.EXTERIOR] = n2._matrix[H.INTERIOR][H.EXTERIOR], this._matrix[H.BOUNDARY][H.INTERIOR] = n2._matrix[H.BOUNDARY][H.INTERIOR], this._matrix[H.BOUNDARY][H.BOUNDARY] = n2._matrix[H.BOUNDARY][H.BOUNDARY], this._matrix[H.BOUNDARY][H.EXTERIOR] = n2._matrix[H.BOUNDARY][H.EXTERIOR], this._matrix[H.EXTERIOR][H.INTERIOR] = n2._matrix[H.EXTERIOR][H.INTERIOR], this._matrix[H.EXTERIOR][H.BOUNDARY] = n2._matrix[H.EXTERIOR][H.BOUNDARY], this._matrix[H.EXTERIOR][H.EXTERIOR] = n2._matrix[H.EXTERIOR][H.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
            var t2 = arguments[0], n2 = arguments[1];
            return n2 === Lt.SYM_DONTCARE || (n2 === Lt.SYM_TRUE && (t2 >= 0 || t2 === Lt.TRUE) || (n2 === Lt.SYM_FALSE && t2 === Lt.FALSE || (n2 === Lt.SYM_P && t2 === Lt.P || (n2 === Lt.SYM_L && t2 === Lt.L || n2 === Lt.SYM_A && t2 === Lt.A))));
          }
          if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1], s2 = new e3(i2);
            return s2.matches(r2);
          }
        } }, { key: "isTrue", value: function(t2) {
          return t2 >= 0 || t2 === Lt.TRUE;
        } }]), e3;
      }(), ei = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(t2) {
          return null === t2 || 0 === t2.length ? null : (this.ensureCapacity(this._size + t2.length), mt.arraycopy(t2, 0, this._data, this._size, t2.length), void (this._size += t2.length));
        } }, { key: "ensureCapacity", value: function(t2) {
          if (t2 <= this._data.length) return null;
          var e4 = Math.max(t2, 2 * this._data.length);
          this._data = At.copyOf(this._data, e4);
        } }, { key: "toArray", value: function() {
          var t2 = new Array(this._size).fill(null);
          return mt.arraycopy(this._data, 0, t2, 0, this._size), t2;
        } }, { key: "add", value: function(t2) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = t2, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, 0 === arguments.length) e3.constructor_.call(this, 10);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._data = new Array(t2).fill(null);
          }
        } }]), e3;
      }(), ni = function() {
        function e3() {
          t(this, e3);
        }
        return n(e3, [{ key: "getChainStartIndices", value: function(t2) {
          var e4 = 0, n2 = new ei(Math.trunc(t2.length / 2));
          n2.add(e4);
          do {
            var i2 = this.findChainEnd(t2, e4);
            n2.add(i2), e4 = i2;
          } while (e4 < t2.length - 1);
          return n2.toArray();
        } }, { key: "findChainEnd", value: function(t2, e4) {
          for (var n2 = We.quadrant(t2[e4], t2[e4 + 1]), i2 = e4 + 1; i2 < t2.length; ) {
            if (We.quadrant(t2[i2 - 1], t2[i2]) !== n2) break;
            i2++;
          }
          return i2 - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(t2) {
          var n2 = 0, i2 = new yt();
          i2.add(n2);
          do {
            var r2 = this.findChainEnd(t2, n2);
            i2.add(r2), n2 = r2;
          } while (n2 < t2.length - 1);
          return e3.toIntArray(i2);
        } }], [{ key: "toIntArray", value: function(t2) {
          for (var e4 = new Array(t2.size()).fill(null), n2 = 0; n2 < e4.length; n2++) e4[n2] = t2.get(n2).intValue();
          return e4;
        } }]), e3;
      }(), ii = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(t2) {
          var e4 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e4 > n2 ? e4 : n2;
        } }, { key: "getMinX", value: function(t2) {
          var e4 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e4 < n2 ? e4 : n2;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e4, e4.startIndex[n2], e4.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3], u5 = arguments[4], l2 = arguments[5];
            if (s2 - r2 == 1 && u5 - o2 == 1) return l2.addIntersections(this.e, r2, a2.e, o2), null;
            if (!this.overlaps(r2, s2, a2, o2, u5)) return null;
            var h2 = Math.trunc((r2 + s2) / 2), c2 = Math.trunc((o2 + u5) / 2);
            r2 < h2 && (o2 < c2 && this.computeIntersectsForChain(r2, h2, a2, o2, c2, l2), c2 < u5 && this.computeIntersectsForChain(r2, h2, a2, c2, u5, l2)), h2 < s2 && (o2 < c2 && this.computeIntersectsForChain(h2, s2, a2, o2, c2, l2), c2 < u5 && this.computeIntersectsForChain(h2, s2, a2, c2, u5, l2));
          }
        } }, { key: "overlaps", value: function(t2, e4, n2, i2, r2) {
          return U.intersects(this.pts[t2], this.pts[e4], n2.pts[i2], n2.pts[r2]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(t2, e4) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++) for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++) this.computeIntersectsForChain(n2, t2, i2, e4);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e4 = new ni();
          this.startIndex = e4.getChainStartIndices(this.pts);
        } }]), e3;
      }(), ri = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "getDepth", value: function(t2, e4) {
          return this._depth[t2][e4];
        } }, { key: "setDepth", value: function(t2, e4, n2) {
          this._depth[t2][e4] = n2;
        } }, { key: "isNull", value: function() {
          if (0 === arguments.length) {
            for (var t2 = 0; t2 < 2; t2++) for (var n2 = 0; n2 < 3; n2++) if (this._depth[t2][n2] !== e3.NULL_VALUE) return false;
            return true;
          }
          if (1 === arguments.length) {
            var i2 = arguments[0];
            return this._depth[i2][1] === e3.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1];
            return this._depth[r2][s2] === e3.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var t2 = 0; t2 < 2; t2++) if (!this.isNull(t2)) {
            var e4 = this._depth[t2][1];
            this._depth[t2][2] < e4 && (e4 = this._depth[t2][2]), e4 < 0 && (e4 = 0);
            for (var n2 = 1; n2 < 3; n2++) {
              var i2 = 0;
              this._depth[t2][n2] > e4 && (i2 = 1), this._depth[t2][n2] = i2;
            }
          }
        } }, { key: "getDelta", value: function(t2) {
          return this._depth[t2][$.RIGHT] - this._depth[t2][$.LEFT];
        } }, { key: "getLocation", value: function(t2, e4) {
          return this._depth[t2][e4] <= 0 ? H.EXTERIOR : H.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (1 === arguments.length) for (var t2 = arguments[0], n2 = 0; n2 < 2; n2++) for (var i2 = 1; i2 < 3; i2++) {
            var r2 = t2.getLocation(n2, i2);
            r2 !== H.EXTERIOR && r2 !== H.INTERIOR || (this.isNull(n2, i2) ? this._depth[n2][i2] = e3.depthAtLocation(r2) : this._depth[n2][i2] += e3.depthAtLocation(r2));
          }
          else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            o2 === H.INTERIOR && this._depth[s2][a2]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var t2 = 0; t2 < 2; t2++) for (var n2 = 0; n2 < 3; n2++) this._depth[t2][n2] = e3.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(t2) {
          return t2 === H.EXTERIOR ? 0 : t2 === H.INTERIOR ? 1 : e3.NULL_VALUE;
        } }]), e3;
      }();
      ri.NULL_VALUE = -1;
      var si = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var t2 = new Array(2).fill(null);
          return t2[0] = this.pts[0], t2[1] = this.pts[1], new a2(t2, Pe.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(t2) {
          this._isIsolated = t2;
        } }, { key: "setName", value: function(t2) {
          this._name = t2;
        } }, { key: "equals", value: function(t2) {
          if (!(t2 instanceof a2)) return false;
          var e4 = t2;
          if (this.pts.length !== e4.pts.length) return false;
          for (var n2 = true, i2 = true, r2 = this.pts.length, s3 = 0; s3 < this.pts.length; s3++) if (this.pts[s3].equals2D(e4.pts[s3]) || (n2 = false), this.pts[s3].equals2D(e4.pts[--r2]) || (i2 = false), !n2 && !i2) return false;
          return true;
        } }, { key: "getCoordinate", value: function() {
          if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.pts[t2];
          }
        } }, { key: "print", value: function(t2) {
          t2.print("edge " + this._name + ": "), t2.print("LINESTRING (");
          for (var e4 = 0; e4 < this.pts.length; e4++) e4 > 0 && t2.print(","), t2.print(this.pts[e4].x + " " + this.pts[e4].y);
          t2.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(t2) {
          a2.updateIM(this._label, t2);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(t2) {
          t2.print("edge " + this._name + ": ");
          for (var e4 = this.pts.length - 1; e4 >= 0; e4--) t2.print(this.pts[e4] + " ");
          t2.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return null === this._mce && (this._mce = new ii(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            this._env = new U();
            for (var t2 = 0; t2 < this.pts.length; t2++) this._env.expandToInclude(this.pts[t2]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(t2, e4, n2, i2) {
          var r2 = new X(t2.getIntersection(i2)), s3 = e4, a3 = t2.getEdgeDistance(n2, i2), o2 = s3 + 1;
          if (o2 < this.pts.length) {
            var u5 = this.pts[o2];
            r2.equals2D(u5) && (s3 = o2, a3 = 0);
          }
          this.eiList.add(r2, s3, a3);
        } }, { key: "toString", value: function() {
          var t2 = new Jt();
          t2.append("edge " + this._name + ": "), t2.append("LINESTRING (");
          for (var e4 = 0; e4 < this.pts.length; e4++) e4 > 0 && t2.append(","), t2.append(this.pts[e4].x + " " + this.pts[e4].y);
          return t2.append(")  " + this._label + " " + this._depthDelta), t2.toString();
        } }, { key: "isPointwiseEqual", value: function(t2) {
          if (this.pts.length !== t2.pts.length) return false;
          for (var e4 = 0; e4 < this.pts.length; e4++) if (!this.pts[e4].equals2D(t2.pts[e4])) return false;
          return true;
        } }, { key: "setDepthDelta", value: function(t2) {
          this._depthDelta = t2;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(t2, e4, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) this.addIntersection(t2, e4, n2, i2);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new $n(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ri(), this._depthDelta = 0, 1 === arguments.length) {
            var t2 = arguments[0];
            a2.constructor_.call(this, t2, null);
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this.pts = e4, this._label = n2;
          }
        } }, { key: "updateIM", value: function() {
          if (!(2 === arguments.length && arguments[1] instanceof ti && arguments[0] instanceof Pe)) return f(r(a2), "updateIM", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1];
          e4.setAtLeastIfValid(t2.getLocation(0, $.ON), t2.getLocation(1, $.ON), 1), t2.isArea() && (e4.setAtLeastIfValid(t2.getLocation(0, $.LEFT), t2.getLocation(1, $.LEFT), 2), e4.setAtLeastIfValid(t2.getLocation(0, $.RIGHT), t2.getLocation(1, $.RIGHT), 2));
        } }]), a2;
      }(qe), ai = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "setWorkingPrecisionModel", value: function(t2) {
          this._workingPrecisionModel = t2;
        } }, { key: "insertUniqueEdge", value: function(t2) {
          var n2 = this._edgeList.findEqualEdge(t2);
          if (null !== n2) {
            var i2 = n2.getLabel(), r2 = t2.getLabel();
            n2.isPointwiseEqual(t2) || (r2 = new Pe(t2.getLabel())).flip(), i2.merge(r2);
            var s2 = e3.depthDelta(r2), a2 = n2.getDepthDelta() + s2;
            n2.setDepthDelta(a2);
          } else this._edgeList.add(t2), t2.setDepthDelta(e3.depthDelta(t2.getLabel()));
        } }, { key: "buildSubgraphs", value: function(t2, e4) {
          for (var n2 = new yt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), s2 = r2.getRightmostCoordinate(), a2 = new Dn(n2).getDepth(s2);
            r2.computeDepth(a2), r2.findResultEdges(), n2.add(r2), e4.add(r2.getDirectedEdges(), r2.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(t2) {
          for (var e4 = new yt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new _t();
              r2.create(i2), e4.add(r2);
            }
          }
          return on.sort(e4, on.reverseOrder()), e4;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(t2) {
          if (null !== this._workingNoder) return this._workingNoder;
          var e4 = new Rn(), n2 = new Oe();
          return n2.setPrecisionModel(t2), e4.setSegmentIntersector(new Jn(n2)), e4;
        } }, { key: "buffer", value: function(t2, e4) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Pn(n2, this._bufParams), r2 = new zn(t2, e4, i2).getCurves();
          if (r2.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new $e(new Zn()), this._graph.addEdges(this._edgeList.getEdges());
          var s2 = this.createSubgraphs(this._graph), a2 = new tn(this._geomFact);
          this.buildSubgraphs(s2, a2);
          var o2 = a2.getPolygons();
          return o2.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(o2);
        } }, { key: "computeNodedEdges", value: function(t2, e4) {
          var n2 = this.getNoder(e4);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), s2 = r2.getCoordinates();
            if (2 !== s2.length || !s2[0].equals2D(s2[1])) {
              var a2 = r2.getData(), o2 = new si(r2.getCoordinates(), new Pe(a2));
              this.insertUniqueEdge(o2);
            }
          }
        } }, { key: "setNoder", value: function(t2) {
          this._workingNoder = t2;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Wn();
          var t2 = arguments[0];
          this._bufParams = t2;
        } }, { key: "depthDelta", value: function(t2) {
          var e4 = t2.getLocation(0, $.LEFT), n2 = t2.getLocation(0, $.RIGHT);
          return e4 === H.INTERIOR && n2 === H.EXTERIOR ? 1 : e4 === H.EXTERIOR && n2 === H.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(t2) {
          for (var e4 = new ae(), n2 = new yt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e4.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e4.buildGeometry(n2);
        } }]), e3;
      }(), oi = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "rescale", value: function() {
          if (rt(arguments[0], Z)) for (var t2 = arguments[0], e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            this.rescale(n2.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var i2 = arguments[0], r2 = 0; r2 < i2.length; r2++) i2[r2].x = i2[r2].x / this._scaleFactor + this._offsetX, i2[r2].y = i2[r2].y / this._scaleFactor + this._offsetY;
            2 === i2.length && i2[0].equals2D(i2[1]) && mt.out.println(i2);
          }
        } }, { key: "scale", value: function() {
          if (rt(arguments[0], Z)) {
            for (var t2 = arguments[0], e4 = new yt(t2.size()), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e4.add(new In(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e4;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], s2 = new Array(r2.length).fill(null), a2 = 0; a2 < r2.length; a2++) s2[a2] = new X(Math.round((r2[a2].x - this._offsetX) * this._scaleFactor), Math.round((r2[a2].y - this._offsetY) * this._scaleFactor), r2[a2].getZ());
            var o2 = jt.removeRepeatedPoints(s2);
            return o2;
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return 1 === this._scaleFactor;
        } }, { key: "getNodedSubstrings", value: function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        } }, { key: "computeNodes", value: function(t2) {
          var e4 = t2;
          this._isScaled && (e4 = this.scale(t2)), this._noder.computeNodes(e4);
        } }, { key: "interfaces_", get: function() {
          return [Ln];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var t2 = arguments[0], n2 = arguments[1];
            e3.constructor_.call(this, t2, n2, 0, 0);
          } else if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this._noder = i2, this._scaleFactor = r2, this._isScaled = !this.isIntegerPrecision();
          }
        } }]), e3;
      }(), ui = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (0 === arguments.length) for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
            var e4 = t2.next(), n2 = e4.getCoordinates();
            this.checkEndPtVertexIntersections(n2[0], this._segStrings), this.checkEndPtVertexIntersections(n2[n2.length - 1], this._segStrings);
          }
          else if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], s2 = r2.iterator(); s2.hasNext(); ) for (var a2 = s2.next(), o2 = a2.getCoordinates(), u5 = 1; u5 < o2.length - 1; u5++) if (o2[u5].equals(i2)) throw new D2("found endpt/interior pt intersection at index " + u5 + " :pt " + i2);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (0 === arguments.length) for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) for (var e4 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.checkInteriorIntersections(e4, i2);
          }
          else if (2 === arguments.length) for (var r2 = arguments[0], s2 = arguments[1], a2 = r2.getCoordinates(), o2 = s2.getCoordinates(), u5 = 0; u5 < a2.length - 1; u5++) for (var l2 = 0; l2 < o2.length - 1; l2++) this.checkInteriorIntersections(r2, u5, s2, l2);
          else if (4 === arguments.length) {
            var h2 = arguments[0], c2 = arguments[1], f2 = arguments[2], v3 = arguments[3];
            if (h2 === f2 && c2 === v3) return null;
            var g2 = h2.getCoordinates()[c2], y3 = h2.getCoordinates()[c2 + 1], d2 = f2.getCoordinates()[v3], _2 = f2.getCoordinates()[v3 + 1];
            if (this._li.computeIntersection(g2, y3, d2, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, y3) || this.hasInteriorIntersection(this._li, d2, _2))) throw new D2("found non-noded intersection at " + g2 + "-" + y3 + " and " + d2 + "-" + _2);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (0 === arguments.length) for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
            var e4 = t2.next();
            this.checkCollapses(e4);
          }
          else if (1 === arguments.length) for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length - 2; r2++) this.checkCollapse(i2[r2], i2[r2 + 1], i2[r2 + 2]);
        } }, { key: "hasInteriorIntersection", value: function(t2, e4, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e4) && !r2.equals(n2)) return true;
          }
          return false;
        } }, { key: "checkCollapse", value: function(t2, n2, i2) {
          if (t2.equals(i2)) throw new D2("found non-noded collapse at " + e3.fact.createLineString([t2, n2, i2]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new Oe(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        } }]), e3;
      }();
      ui.fact = new ae();
      var li = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "intersectsScaled", value: function(t2, e4) {
          var n2 = Math.min(t2.x, e4.x), i2 = Math.max(t2.x, e4.x), r2 = Math.min(t2.y, e4.y), s2 = Math.max(t2.y, e4.y), a2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > s2;
          if (a2) return false;
          var o2 = this.intersectsToleranceSquare(t2, e4);
          return G.isTrue(!(a2 && o2), "Found bad envelope test"), o2;
        } }, { key: "initCorners", value: function(t2) {
          var e4 = 0.5;
          this._minx = t2.x - e4, this._maxx = t2.x + e4, this._miny = t2.y - e4, this._maxy = t2.y + e4, this._corner[0] = new X(this._maxx, this._maxy), this._corner[1] = new X(this._minx, this._maxy), this._corner[2] = new X(this._minx, this._miny), this._corner[3] = new X(this._maxx, this._miny);
        } }, { key: "intersects", value: function(t2, e4) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t2, e4) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e4, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(t2) {
          return Math.round(t2 * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(t2, e4) {
          e4.x = this.scale(t2.x), e4.y = this.scale(t2.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (null === this._safeEnv) {
            var t2 = e3.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new U(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(t2, e4) {
          return this._li.computeIntersection(t2, e4, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e4, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e4, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e4, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(t2, e4) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e4, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e4, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e4, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e4, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e4.equals(this._pt))))));
        } }, { key: "addSnappedNode", value: function(t2, e4) {
          var n2 = t2.getCoordinate(e4), i2 = t2.getCoordinate(e4 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e4), true);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e4, this._li = n2, e4 <= 0) throw new m("Scale factor must be non-zero");
          1 !== e4 && (this._pt = new X(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new X(), this._p1Scaled = new X()), this.initCorners(this._pt);
        } }]), e3;
      }();
      li.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var hi = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "select", value: function() {
          if (1 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e4 = arguments[1];
            t2.getLineSegment(e4, this.selectedSegment), this.select(this.selectedSegment);
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new En();
        } }]), e3;
      }(), ci = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "snap", value: function() {
          if (1 === arguments.length) {
            var e4 = arguments[0];
            return this.snap(e4, null, -1);
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = i2.getSafeEnvelope(), o2 = new fi(i2, r2, s2);
            return this._index.query(a2, new (function() {
              function e6() {
                t(this, e6);
              }
              return n(e6, [{ key: "interfaces_", get: function() {
                return [hn];
              } }, { key: "visitItem", value: function(t2) {
                t2.select(a2, o2);
              } }]), e6;
            }())()), o2.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        } }]), e3;
      }(), fi = function(e3) {
        i(a2, e3);
        var s2 = c(a2);
        function a2() {
          var e4;
          return t(this, a2), e4 = s2.call(this), a2.constructor_.apply(l(e4), arguments), e4;
        }
        return n(a2, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Tn)) return f(r(a2.prototype), "select", this).apply(this, arguments);
          var t2 = arguments[0], e4 = arguments[1], n2 = t2.getContext();
          if (this._parentEdge === n2 && (e4 === this._hotPixelVertexIndex || e4 + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(n2, e4);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
          var t2 = arguments[0], e4 = arguments[1], n2 = arguments[2];
          this._hotPixel = t2, this._parentEdge = e4, this._hotPixelVertexIndex = n2;
        } }]), a2;
      }(hi);
      ci.HotPixelSnapAction = fi;
      var vi = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "processIntersections", value: function(t2, e4, n2, i2) {
          if (t2 === n2 && e4 === i2) return null;
          var r2 = t2.getCoordinates()[e4], s2 = t2.getCoordinates()[e4 + 1], a2 = n2.getCoordinates()[i2], o2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, s2, a2, o2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u5 = 0; u5 < this._li.getIntersectionNum(); u5++) this._interiorIntersections.add(this._li.getIntersection(u5));
            t2.addIntersections(this._li, e4, 0), n2.addIntersections(this._li, i2, 1);
          }
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [Kn];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new yt();
        } }]), e3;
      }(), gi = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "checkCorrectness", value: function(t2) {
          var e4 = In.getNodedSubstrings(t2), n2 = new ui(e4);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof p)) throw t3;
            t3.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return In.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(t2, e4) {
          var n2 = this.findInteriorIntersections(t2, e4);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        } }, { key: "findInteriorIntersections", value: function(t2, e4) {
          var n2 = new vi(e4);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (rt(arguments[0], Z)) for (var t2 = arguments[0], e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next();
            this.computeVertexSnaps(n2);
          }
          else if (arguments[0] instanceof In) for (var i2 = arguments[0], r2 = i2.getCoordinates(), s2 = 0; s2 < r2.length; s2++) {
            var a2 = new li(r2[s2], this._scaleFactor, this._li), o2 = this._pointSnapper.snap(a2, i2, s2);
            o2 && i2.addIntersection(r2[s2], s2);
          }
        } }, { key: "computeNodes", value: function(t2) {
          this._nodedSegStrings = t2, this._noder = new Rn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(t2) {
          for (var e4 = t2.iterator(); e4.hasNext(); ) {
            var n2 = e4.next(), i2 = new li(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        } }, { key: "interfaces_", get: function() {
          return [Ln];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new Oe(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        } }]), e3;
      }(), yi = function() {
        function e3() {
          t(this, e3), e3.constructor_.apply(this, arguments);
        }
        return n(e3, [{ key: "bufferFixedPrecision", value: function(t2) {
          var e4 = new oi(new gi(new ie(1)), t2.getScale()), n2 = new ai(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e4), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (0 === arguments.length) {
            for (var t2 = e3.MAX_PRECISION_DIGITS; t2 >= 0; t2--) {
              try {
                this.bufferReducedPrecision(t2);
              } catch (t3) {
                if (!(t3 instanceof vt)) throw t3;
                this._saveException = t3;
              }
              if (null !== this._resultGeometry) return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = e3.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new ie(i2);
            this.bufferFixedPrecision(r2);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === ie.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var t2 = new ai(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof D2)) throw t3;
            this._saveException = t3;
          }
        } }, { key: "getResultGeometry", value: function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(t2) {
          this._bufParams.setEndCapStyle(t2);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new _(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (2 === arguments.length) {
            var e4 = arguments[0], n2 = arguments[1];
            this._argGeom = e4, this._bufParams = n2;
          }
        } }, { key: "bufferOp", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], n2 = arguments[1], i2 = new e3(t2), r2 = i2.getResultGeometry(n2);
            return r2;
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u5 = new e3(s2);
              u5.setQuadrantSegments(o2);
              var l2 = u5.getResultGeometry(a2);
              return l2;
            }
            if (arguments[2] instanceof _ && arguments[0] instanceof V && "number" == typeof arguments[1]) {
              var h2 = arguments[0], c2 = arguments[1], f2 = arguments[2], v3 = new e3(h2, f2), g2 = v3.getResultGeometry(c2);
              return g2;
            }
          } else if (4 === arguments.length) {
            var y3 = arguments[0], d2 = arguments[1], p2 = arguments[2], m2 = arguments[3], k2 = new e3(y3);
            k2.setQuadrantSegments(p2), k2.setEndCapStyle(m2);
            var x3 = k2.getResultGeometry(d2);
            return x3;
          }
        } }, { key: "precisionScaleFactor", value: function(t2, e4, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = kt.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e4 > 0 ? e4 : 0), s2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, s2);
        } }]), e3;
      }();
      yi.CAP_ROUND = _.CAP_ROUND, yi.CAP_BUTT = _.CAP_FLAT, yi.CAP_FLAT = _.CAP_FLAT, yi.CAP_SQUARE = _.CAP_SQUARE, yi.MAX_PRECISION_DIGITS = 12;
      var di = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], _i = function() {
        function e3(n2) {
          t(this, e3), this.geometryFactory = n2 || new ae();
        }
        return n(e3, [{ key: "read", value: function(t2) {
          var e4, n2 = (e4 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!pi2[n2]) throw new Error("Unknown GeoJSON type: " + e4.type);
          return -1 !== di.indexOf(n2) ? pi2[n2].call(this, e4.coordinates) : "GeometryCollection" === n2 ? pi2[n2].call(this, e4.geometries) : pi2[n2].call(this, e4);
        } }, { key: "write", value: function(t2) {
          var e4 = t2.getGeometryType();
          if (!mi[e4]) throw new Error("Geometry is not supported");
          return mi[e4].call(this, t2);
        } }]), e3;
      }(), pi2 = { Feature: function(t2) {
        var e3 = {};
        for (var n2 in t2) e3[n2] = t2[n2];
        if (t2.geometry) {
          var i2 = t2.geometry.type;
          if (!pi2[i2]) throw new Error("Unknown GeoJSON type: " + t2.type);
          e3.geometry = this.read(t2.geometry);
        }
        return t2.bbox && (e3.bbox = pi2.bbox.call(this, t2.bbox)), e3;
      }, FeatureCollection: function(t2) {
        var e3 = {};
        if (t2.features) {
          e3.features = [];
          for (var n2 = 0; n2 < t2.features.length; ++n2) e3.features.push(this.read(t2.features[n2]));
        }
        return t2.bbox && (e3.bbox = this.parse.bbox.call(this, t2.bbox)), e3;
      }, coordinates: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e3.push(o(X, v2(i2)));
        }
        return e3;
      }, bbox: function(t2) {
        return this.geometryFactory.createLinearRing([new X(t2[0], t2[1]), new X(t2[2], t2[1]), new X(t2[2], t2[3]), new X(t2[0], t2[3]), new X(t2[0], t2[1])]);
      }, Point: function(t2) {
        var e3 = o(X, v2(t2));
        return this.geometryFactory.createPoint(e3);
      }, MultiPoint: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) e3.push(pi2.Point.call(this, t2[n2]));
        return this.geometryFactory.createMultiPoint(e3);
      }, LineString: function(t2) {
        var e3 = pi2.coordinates.call(this, t2);
        return this.geometryFactory.createLineString(e3);
      }, MultiLineString: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) e3.push(pi2.LineString.call(this, t2[n2]));
        return this.geometryFactory.createMultiLineString(e3);
      }, Polygon: function(t2) {
        for (var e3 = pi2.coordinates.call(this, t2[0]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
          var s2 = t2[r2], a2 = pi2.coordinates.call(this, s2), o2 = this.geometryFactory.createLinearRing(a2);
          i2.push(o2);
        }
        return this.geometryFactory.createPolygon(n2, i2);
      }, MultiPolygon: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e3.push(pi2.Polygon.call(this, i2));
        }
        return this.geometryFactory.createMultiPolygon(e3);
      }, GeometryCollection: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e3.push(this.read(i2));
        }
        return this.geometryFactory.createGeometryCollection(e3);
      } }, mi = { coordinate: function(t2) {
        var e3 = [t2.x, t2.y];
        return t2.z && e3.push(t2.z), t2.m && e3.push(t2.m), e3;
      }, Point: function(t2) {
        return { type: "Point", coordinates: mi.coordinate.call(this, t2.getCoordinate()) };
      }, MultiPoint: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = mi.Point.call(this, i2);
          e3.push(r2.coordinates);
        }
        return { type: "MultiPoint", coordinates: e3 };
      }, LineString: function(t2) {
        for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
          var r2 = n2[i2];
          e3.push(mi.coordinate.call(this, r2));
        }
        return { type: "LineString", coordinates: e3 };
      }, MultiLineString: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = mi.LineString.call(this, i2);
          e3.push(r2.coordinates);
        }
        return { type: "MultiLineString", coordinates: e3 };
      }, Polygon: function(t2) {
        var e3 = [], n2 = mi.LineString.call(this, t2._shell);
        e3.push(n2.coordinates);
        for (var i2 = 0; i2 < t2._holes.length; ++i2) {
          var r2 = t2._holes[i2], s2 = mi.LineString.call(this, r2);
          e3.push(s2.coordinates);
        }
        return { type: "Polygon", coordinates: e3 };
      }, MultiPolygon: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = mi.Polygon.call(this, i2);
          e3.push(r2.coordinates);
        }
        return { type: "MultiPolygon", coordinates: e3 };
      }, GeometryCollection: function(t2) {
        for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
          e3.push(mi[r2].call(this, i2));
        }
        return { type: "GeometryCollection", geometries: e3 };
      } };
      return { BufferOp: yi, GeoJSONReader: function() {
        function e3(n2) {
          t(this, e3), this.parser = new _i(n2 || new ae());
        }
        return n(e3, [{ key: "read", value: function(t2) {
          return this.parser.read(t2);
        } }]), e3;
      }(), GeoJSONWriter: function() {
        function e3() {
          t(this, e3), this.parser = new _i(this.geometryFactory);
        }
        return n(e3, [{ key: "write", value: function(t2) {
          return this.parser.write(t2);
        } }]), e3;
      }() };
    });
  }
});

// ../node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.min.js
var require_rbush_min = __commonJS({
  "../node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.min.js"(exports, module) {
    !function(t, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
    }(exports, function() {
      "use strict";
      function t(t2, r2, e3, a2, h2) {
        !function t3(n2, r3, e4, a3, h3) {
          for (; a3 > e4; ) {
            if (a3 - e4 > 600) {
              var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u5 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u5)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u5));
              t3(n2, r3, m2, c2, h3);
            }
            var p2 = n2[r3], d2 = e4, x2 = a3;
            for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
              for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; ) d2++;
              for (; h3(n2[x2], p2) > 0; ) x2--;
            }
            0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
          }
        }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
      }
      function i(t2, i2, n2) {
        var r2 = t2[i2];
        t2[i2] = t2[n2], t2[n2] = r2;
      }
      function n(t2, i2) {
        return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
      }
      var r = function(t2) {
        void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e(t2, i2, n2) {
        if (!n2) return i2.indexOf(t2);
        for (var r2 = 0; r2 < i2.length; r2++) if (n2(t2, i2[r2])) return r2;
        return -1;
      }
      function a(t2, i2) {
        h(t2, 0, t2.children.length, i2, t2);
      }
      function h(t2, i2, n2, r2, e3) {
        e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
        for (var a2 = i2; a2 < n2; a2++) {
          var h2 = t2.children[a2];
          o(e3, t2.leaf ? r2(h2) : h2);
        }
        return e3;
      }
      function o(t2, i2) {
        return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
      }
      function s(t2, i2) {
        return t2.minX - i2.minX;
      }
      function l(t2, i2) {
        return t2.minY - i2.minY;
      }
      function f(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function u4(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function m(t2, i2) {
        return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
      }
      function c(t2, i2) {
        return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
      }
      function p(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r2, e3, a2) {
        for (var h2 = [n2, r2]; h2.length; ) if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
          var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
          t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
        }
      }
      return r.prototype.all = function() {
        return this._all(this.data, []);
      }, r.prototype.search = function(t2) {
        var i2 = this.data, n2 = [];
        if (!c(t2, i2)) return n2;
        for (var r2 = this.toBBox, e3 = []; i2; ) {
          for (var a2 = 0; a2 < i2.children.length; a2++) {
            var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
            c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
          }
          i2 = e3.pop();
        }
        return n2;
      }, r.prototype.collides = function(t2) {
        var i2 = this.data;
        if (!c(t2, i2)) return false;
        for (var n2 = []; i2; ) {
          for (var r2 = 0; r2 < i2.children.length; r2++) {
            var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
            if (c(t2, a2)) {
              if (i2.leaf || m(t2, a2)) return true;
              n2.push(e3);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r.prototype.load = function(t2) {
        if (!t2 || !t2.length) return this;
        if (t2.length < this._minEntries) {
          for (var i2 = 0; i2 < t2.length; i2++) this.insert(t2[i2]);
          return this;
        }
        var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
        if (this.data.children.length) if (this.data.height === n2.height) this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r2 = this.data;
            this.data = n2, n2 = r2;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
        else this.data = n2;
        return this;
      }, r.prototype.insert = function(t2) {
        return t2 && this._insert(t2, this.data.height - 1), this;
      }, r.prototype.clear = function() {
        return this.data = p([]), this;
      }, r.prototype.remove = function(t2, i2) {
        if (!t2) return this;
        for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
          if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
            var f2 = e(t2, h2.children, i2);
            if (-1 !== f2) return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
          }
          a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
        }
        return this;
      }, r.prototype.toBBox = function(t2) {
        return t2;
      }, r.prototype.compareMinX = function(t2, i2) {
        return t2.minX - i2.minX;
      }, r.prototype.compareMinY = function(t2, i2) {
        return t2.minY - i2.minY;
      }, r.prototype.toJSON = function() {
        return this.data;
      }, r.prototype.fromJSON = function(t2) {
        return this.data = t2, this;
      }, r.prototype._all = function(t2, i2) {
        for (var n2 = []; t2; ) t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
        return i2;
      }, r.prototype._build = function(t2, i2, n2, r2) {
        var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h2 <= o2) return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
        r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
        var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t2, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u5 = Math.min(f2 + l2 - 1, n2);
          d(t2, f2, u5, s2, this.compareMinY);
          for (var m2 = f2; m2 <= u5; m2 += s2) {
            var c2 = Math.min(m2 + s2 - 1, u5);
            e3.children.push(this._build(t2, m2, c2, r2 - 1));
          }
        }
        return a(e3, this.toBBox), e3;
      }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
        for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
          for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u5 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
            u5 < a2 ? (a2 = u5, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u5 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
          }
          i2 = h2 || i2.children[0];
        }
        var m2, c2;
        return i2;
      }, r.prototype._insert = function(t2, i2, n2) {
        var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
        for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; ) this._split(e3, i2), i2--;
        this._adjustParentBBoxes(r2, e3, i2);
      }, r.prototype._split = function(t2, i2) {
        var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
        this._chooseSplitAxis(n2, e3, r2);
        var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
        o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r.prototype._splitRoot = function(t2, i2) {
        this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
        for (var r2, e3, a2, o2, s2, l2, u5, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
          var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v2 = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u5 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u5 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u5 - s2)), M = f(d2) + f(x2);
          v2 < m2 ? (m2 = v2, r2 = p2, c2 = M < c2 ? M : c2) : v2 === m2 && M < c2 && (c2 = M, r2 = p2);
        }
        return r2 || n2 - i2;
      }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
        var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
        this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
      }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
        t2.children.sort(r2);
        for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u4(a2) + u4(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m2 = t2.children[f2];
          o(a2, t2.leaf ? e3(m2) : m2), l2 += u4(a2);
        }
        for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
          var p2 = t2.children[c2];
          o(s2, t2.leaf ? e3(p2) : p2), l2 += u4(s2);
        }
        return l2;
      }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
        for (var r2 = n2; r2 >= 0; r2--) o(i2[r2], t2);
      }, r.prototype._condense = function(t2) {
        for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--) 0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
      }, r;
    });
  }
});

// ../node_modules/.pnpm/tinyqueue@2.0.3/node_modules/tinyqueue/index.js
var tinyqueue_exports = {};
__export(tinyqueue_exports, {
  default: () => TinyQueue2
});
function defaultCompare3(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var TinyQueue2;
var init_tinyqueue = __esm({
  "../node_modules/.pnpm/tinyqueue@2.0.3/node_modules/tinyqueue/index.js"() {
    TinyQueue2 = class {
      constructor(data = [], compare = defaultCompare3) {
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) {
          for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
        }
      }
      push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
      }
      pop() {
        if (this.length === 0) return void 0;
        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
          this.data[0] = bottom;
          this._down(0);
        }
        return top;
      }
      peek() {
        return this.data[0];
      }
      _up(pos) {
        const { data, compare } = this;
        const item = data[pos];
        while (pos > 0) {
          const parent = pos - 1 >> 1;
          const current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }
        data[pos] = item;
      }
      _down(pos) {
        const { data, compare } = this;
        const halfLength = this.length >> 1;
        const item = data[pos];
        while (pos < halfLength) {
          let left = (pos << 1) + 1;
          let best = data[left];
          const right = left + 1;
          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }
          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }
        data[pos] = item;
      }
    };
  }
});

// ../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/flat.js
var require_flat = __commonJS({
  "../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/flat.js"(exports, module) {
    module.exports = function pointInPolygonFlat(point2, vs, start, end) {
      var x2 = point2[0], y2 = point2[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = (end - start) / 2;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect4 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
        if (intersect4) inside = !inside;
      }
      return inside;
    };
  }
});

// ../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/nested.js
var require_nested = __commonJS({
  "../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/nested.js"(exports, module) {
    module.exports = function pointInPolygonNested(point2, vs, start, end) {
      var x2 = point2[0], y2 = point2[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = end - start;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect4 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
        if (intersect4) inside = !inside;
      }
      return inside;
    };
  }
});

// ../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/index.js
var require_point_in_polygon = __commonJS({
  "../node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/index.js"(exports, module) {
    var pointInPolygonFlat = require_flat();
    var pointInPolygonNested = require_nested();
    module.exports = function pointInPolygon2(point2, vs, start, end) {
      if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point2, vs, start, end);
      } else {
        return pointInPolygonFlat(point2, vs, start, end);
      }
    };
    module.exports.nested = pointInPolygonNested;
    module.exports.flat = pointInPolygonFlat;
  }
});

// ../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/umd/orient2d.min.js
var require_orient2d_min = __commonJS({
  "../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
    }(exports, function(t) {
      "use strict";
      const e = 134217729, n = 33306690738754706e-32;
      function r(t2, e3, n2, r2, o2) {
        let f2, i2, u5, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
        a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
        let p = 0;
        if (d2 < t2 && l2 < n2) for (a2 > s2 == a2 > -s2 ? (u5 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u5 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u5 && (o2[p++] = u5); d2 < t2 && l2 < n2; ) a2 > s2 == a2 > -s2 ? (u5 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u5 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u5 && (o2[p++] = u5);
        for (; d2 < t2; ) u5 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u5 && (o2[p++] = u5);
        for (; l2 < n2; ) u5 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u5 && (o2[p++] = u5);
        return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
      }
      function o(t2) {
        return new Float64Array(t2);
      }
      const f = 33306690738754716e-32, i = 22204460492503146e-32, u4 = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
      t.orient2d = function(t2, o2, p, b, y2, h) {
        const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
        if (0 === M || 0 === x2 || M > 0 != x2 > 0) return j;
        const m = Math.abs(M + x2);
        return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
          let M2, x3, j2, m2, _, v2, w, A, F, O, P, g, k, q, z, B3, C, D2;
          const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
          _ = (z = (A = E - (w = (v2 = e * E) - (v2 - E))) * (O = I - (F = (v2 = e * I) - (v2 - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v2 = e * H) - (v2 - H))) * (O = G - (F = (v2 = e * G) - (v2 - G))) - ((B3 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B3), c[1] = k - (P + _) + (_ - B3), _ = (D2 = g + P) - g, c[2] = g - (D2 - _) + (P - _), c[3] = D2;
          let J = function(t4, e3) {
            let n2 = e3[0];
            for (let r2 = 1; r2 < t4; r2++) n2 += e3[r2];
            return n2;
          }(4, c), K = i * h2;
          if (J >= K || -J >= K) return J;
          if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m2) return J;
          if (K = u4 * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K) return J;
          _ = (z = (A = M2 - (w = (v2 = e * M2) - (v2 - M2))) * (O = I - (F = (v2 = e * I) - (v2 - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v2 = e * x3) - (v2 - x3))) * (O = G - (F = (v2 = e * G) - (v2 - G))) - ((B3 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B3), l[1] = k - (P + _) + (_ - B3), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const L = r(4, c, 4, l, s);
          _ = (z = (A = E - (w = (v2 = e * E) - (v2 - E))) * (O = m2 - (F = (v2 = e * m2) - (v2 - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v2 = e * H) - (v2 - H))) * (O = j2 - (F = (v2 = e * j2) - (v2 - j2))) - ((B3 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B3), l[1] = k - (P + _) + (_ - B3), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const N = r(L, s, 4, l, a);
          _ = (z = (A = M2 - (w = (v2 = e * M2) - (v2 - M2))) * (O = m2 - (F = (v2 = e * m2) - (v2 - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v2 = e * x3) - (v2 - x3))) * (O = j2 - (F = (v2 = e * j2) - (v2 - j2))) - ((B3 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B3), l[1] = k - (P + _) + (_ - B3), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const Q = r(N, a, 4, l, d);
          return d[Q - 1];
        }(t2, o2, p, b, y2, h, m);
      }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
        return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
      }, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// ../node_modules/.pnpm/concaveman@1.2.1/node_modules/concaveman/index.js
var require_concaveman = __commonJS({
  "../node_modules/.pnpm/concaveman@1.2.1/node_modules/concaveman/index.js"(exports, module) {
    "use strict";
    var RBush2 = require_rbush_min();
    var Queue = (init_tinyqueue(), __toCommonJS(tinyqueue_exports));
    var pointInPolygon2 = require_point_in_polygon();
    var orient = require_orient2d_min().orient2d;
    if (Queue.default) {
      Queue = Queue.default;
    }
    module.exports = concaveman2;
    module.exports.default = concaveman2;
    function concaveman2(points2, concavity, lengthThreshold) {
      concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
      lengthThreshold = lengthThreshold || 0;
      var hull = fastConvexHull(points2);
      var tree = new RBush2(16);
      tree.toBBox = function(a2) {
        return {
          minX: a2[0],
          minY: a2[1],
          maxX: a2[0],
          maxY: a2[1]
        };
      };
      tree.compareMinX = function(a2, b2) {
        return a2[0] - b2[0];
      };
      tree.compareMinY = function(a2, b2) {
        return a2[1] - b2[1];
      };
      tree.load(points2);
      var queue = [];
      for (var i = 0, last; i < hull.length; i++) {
        var p = hull[i];
        tree.remove(p);
        last = insertNode(p, last);
        queue.push(last);
      }
      var segTree = new RBush2(16);
      for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));
      var sqConcavity = concavity * concavity;
      var sqLenThreshold = lengthThreshold * lengthThreshold;
      while (queue.length) {
        var node = queue.shift();
        var a = node.p;
        var b = node.next.p;
        var sqLen = getSqDist2(a, b);
        if (sqLen < sqLenThreshold) continue;
        var maxSqLen = sqLen / sqConcavity;
        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
        if (p && Math.min(getSqDist2(p, a), getSqDist2(p, b)) <= maxSqLen) {
          queue.push(node);
          queue.push(insertNode(p, node));
          tree.remove(p);
          segTree.remove(node);
          segTree.insert(updateBBox(node));
          segTree.insert(updateBBox(node.next));
        }
      }
      node = last;
      var concave2 = [];
      do {
        concave2.push(node.p);
        node = node.next;
      } while (node !== last);
      concave2.push(node.p);
      return concave2;
    }
    function findCandidate(tree, a, b, c, d, maxDist, segTree) {
      var queue = new Queue([], compareDist);
      var node = tree.data;
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
          if (dist > maxDist) continue;
          queue.push({
            node: child,
            dist
          });
        }
        while (queue.length && !queue.peek().node.children) {
          var item = queue.pop();
          var p = item.node;
          var d0 = sqSegDist(p, a, b);
          var d1 = sqSegDist(p, c, d);
          if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;
        }
        node = queue.pop();
        if (node) node = node.node;
      }
      return null;
    }
    function compareDist(a, b) {
      return a.dist - b.dist;
    }
    function sqSegBoxDist(a, b, bbox3) {
      if (inside(a, bbox3) || inside(b, bbox3)) return 0;
      var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.maxX, bbox3.minY);
      if (d1 === 0) return 0;
      var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.minX, bbox3.maxY);
      if (d2 === 0) return 0;
      var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.maxX, bbox3.minY, bbox3.maxX, bbox3.maxY);
      if (d3 === 0) return 0;
      var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.maxY, bbox3.maxX, bbox3.maxY);
      if (d4 === 0) return 0;
      return Math.min(d1, d2, d3, d4);
    }
    function inside(a, bbox3) {
      return a[0] >= bbox3.minX && a[0] <= bbox3.maxX && a[1] >= bbox3.minY && a[1] <= bbox3.maxY;
    }
    function noIntersections(a, b, segTree) {
      var minX = Math.min(a[0], b[0]);
      var minY = Math.min(a[1], b[1]);
      var maxX = Math.max(a[0], b[0]);
      var maxY = Math.max(a[1], b[1]);
      var edges2 = segTree.search({ minX, minY, maxX, maxY });
      for (var i = 0; i < edges2.length; i++) {
        if (intersects2(edges2[i].p, edges2[i].next.p, a, b)) return false;
      }
      return true;
    }
    function cross(p1, p2, p3) {
      return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }
    function intersects2(p1, q1, p2, q2) {
      return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
    }
    function updateBBox(node) {
      var p1 = node.p;
      var p2 = node.next.p;
      node.minX = Math.min(p1[0], p2[0]);
      node.minY = Math.min(p1[1], p2[1]);
      node.maxX = Math.max(p1[0], p2[0]);
      node.maxY = Math.max(p1[1], p2[1]);
      return node;
    }
    function fastConvexHull(points2) {
      var left = points2[0];
      var top = points2[0];
      var right = points2[0];
      var bottom = points2[0];
      for (var i = 0; i < points2.length; i++) {
        var p = points2[i];
        if (p[0] < left[0]) left = p;
        if (p[0] > right[0]) right = p;
        if (p[1] < top[1]) top = p;
        if (p[1] > bottom[1]) bottom = p;
      }
      var cull = [left, top, right, bottom];
      var filtered = cull.slice();
      for (i = 0; i < points2.length; i++) {
        if (!pointInPolygon2(points2[i], cull)) filtered.push(points2[i]);
      }
      return convexHull(filtered);
    }
    function insertNode(p, prev) {
      var node = {
        p,
        prev: null,
        next: null,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
      if (!prev) {
        node.prev = node;
        node.next = node;
      } else {
        node.next = prev.next;
        node.prev = prev;
        prev.next.prev = node;
        prev.next = node;
      }
      return node;
    }
    function getSqDist2(p1, p2) {
      var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
      return dx * dx + dy * dy;
    }
    function sqSegDist(p, p1, p2) {
      var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
      if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x2 = p2[0];
          y2 = p2[1];
        } else if (t > 0) {
          x2 += dx * t;
          y2 += dy * t;
        }
      }
      dx = p[0] - x2;
      dy = p[1] - y2;
      return dx * dx + dy * dy;
    }
    function sqSegSegDist(x02, y02, x12, y12, x2, y2, x3, y3) {
      var ux = x12 - x02;
      var uy = y12 - y02;
      var vx = x3 - x2;
      var vy = y3 - y2;
      var wx = x02 - x2;
      var wy = y02 - y2;
      var a = ux * ux + uy * uy;
      var b = ux * vx + uy * vy;
      var c = vx * vx + vy * vy;
      var d = ux * wx + uy * wy;
      var e = vx * wx + vy * wy;
      var D2 = a * c - b * b;
      var sc, sN, tc, tN;
      var sD = D2;
      var tD = D2;
      if (D2 === 0) {
        sN = 0;
        sD = 1;
        tN = e;
        tD = c;
      } else {
        sN = b * e - c * d;
        tN = a * e - b * d;
        if (sN < 0) {
          sN = 0;
          tN = e;
          tD = c;
        } else if (sN > sD) {
          sN = sD;
          tN = e + b;
          tD = c;
        }
      }
      if (tN < 0) {
        tN = 0;
        if (-d < 0) sN = 0;
        else if (-d > a) sN = sD;
        else {
          sN = -d;
          sD = a;
        }
      } else if (tN > tD) {
        tN = tD;
        if (-d + b < 0) sN = 0;
        else if (-d + b > a) sN = sD;
        else {
          sN = -d + b;
          sD = a;
        }
      }
      sc = sN === 0 ? 0 : sN / sD;
      tc = tN === 0 ? 0 : tN / tD;
      var cx = (1 - sc) * x02 + sc * x12;
      var cy = (1 - sc) * y02 + sc * y12;
      var cx2 = (1 - tc) * x2 + tc * x3;
      var cy2 = (1 - tc) * y2 + tc * y3;
      var dx = cx2 - cx;
      var dy = cy2 - cy;
      return dx * dx + dy * dy;
    }
    function compareByX(a, b) {
      return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
    }
    function convexHull(points2) {
      points2.sort(compareByX);
      var lower = [];
      for (var i = 0; i < points2.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points2[i]) <= 0) {
          lower.pop();
        }
        lower.push(points2[i]);
      }
      var upper = [];
      for (var ii = points2.length - 1; ii >= 0; ii--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points2[ii]) <= 0) {
          upper.pop();
        }
        upper.push(points2[ii]);
      }
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }
  }
});

// ../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/distance.js
var require_distance = __commonJS({
  "../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/distance.js"(exports, module) {
    "use strict";
    module.exports = {
      /**
       * Euclidean distance
       */
      eudist: function eudist(v1, v2, sqrt2) {
        var len = v1.length;
        var sum3 = 0;
        for (var i = 0; i < len; i++) {
          var d = (v1[i] || 0) - (v2[i] || 0);
          sum3 += d * d;
        }
        return sqrt2 ? Math.sqrt(sum3) : sum3;
      },
      mandist: function mandist(v1, v2, sqrt2) {
        var len = v1.length;
        var sum3 = 0;
        for (var i = 0; i < len; i++) {
          sum3 += Math.abs((v1[i] || 0) - (v2[i] || 0));
        }
        return sqrt2 ? Math.sqrt(sum3) : sum3;
      },
      /**
       * Unidimensional distance
       */
      dist: function dist(v1, v2, sqrt2) {
        var d = Math.abs(v1 - v2);
        return sqrt2 ? d : d * d;
      }
    };
  }
});

// ../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/kinit.js
var require_kinit = __commonJS({
  "../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/kinit.js"(exports, module) {
    "use strict";
    var Distance = require_distance();
    var eudist = Distance.eudist;
    var dist = Distance.dist;
    module.exports = {
      kmrand: function kmrand(data, k) {
        var map2 = {}, ks = [], t = k << 2;
        var len = data.length;
        var multi = data[0].length > 0;
        while (ks.length < k && t-- > 0) {
          var d = data[Math.floor(Math.random() * len)];
          var key = multi ? d.join("_") : "" + d;
          if (!map2[key]) {
            map2[key] = true;
            ks.push(d);
          }
        }
        if (ks.length < k) throw new Error("Error initializating clusters");
        else return ks;
      },
      /**
       * K-means++ initial centroid selection
       */
      kmpp: function kmpp(data, k) {
        var distance2 = data[0].length ? eudist : dist;
        var ks = [], len = data.length;
        var multi = data[0].length > 0;
        var map2 = {};
        var c = data[Math.floor(Math.random() * len)];
        var key = multi ? c.join("_") : "" + c;
        ks.push(c);
        map2[key] = true;
        while (ks.length < k) {
          var dists = [], lk = ks.length;
          var dsum = 0, prs = [];
          for (var i = 0; i < len; i++) {
            var min = Infinity;
            for (var j = 0; j < lk; j++) {
              var _dist = distance2(data[i], ks[j]);
              if (_dist <= min) min = _dist;
            }
            dists[i] = min;
          }
          for (var _i = 0; _i < len; _i++) {
            dsum += dists[_i];
          }
          for (var _i2 = 0; _i2 < len; _i2++) {
            prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
          }
          prs.sort(function(a, b) {
            return a.pr - b.pr;
          });
          prs[0].cs = prs[0].pr;
          for (var _i3 = 1; _i3 < len; _i3++) {
            prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
          }
          var rnd2 = Math.random();
          var idx = 0;
          while (idx < len - 1 && prs[idx++].cs < rnd2) {
          }
          ks.push(prs[idx - 1].v);
        }
        return ks;
      }
    };
  }
});

// ../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/main.js
var require_main = __commonJS({
  "../node_modules/.pnpm/skmeans@0.9.7/node_modules/skmeans/dist/node/main.js"(exports, module) {
    "use strict";
    var Distance = require_distance();
    var ClusterInit = require_kinit();
    var eudist = Distance.eudist;
    var mandist = Distance.mandist;
    var dist = Distance.dist;
    var kmrand = ClusterInit.kmrand;
    var kmpp = ClusterInit.kmpp;
    var MAX = 1e4;
    function init(len, val, v2) {
      v2 = v2 || [];
      for (var i = 0; i < len; i++) {
        v2[i] = val;
      }
      return v2;
    }
    function skmeans2(data, k, initial, maxit) {
      var ks = [], old = [], idxs = [], dist2 = [];
      var conv = false, it = maxit || MAX;
      var len = data.length, vlen = data[0].length, multi = vlen > 0;
      var count = [];
      if (!initial) {
        var _idxs = {};
        while (ks.length < k) {
          var idx = Math.floor(Math.random() * len);
          if (!_idxs[idx]) {
            _idxs[idx] = true;
            ks.push(data[idx]);
          }
        }
      } else if (initial == "kmrand") {
        ks = kmrand(data, k);
      } else if (initial == "kmpp") {
        ks = kmpp(data, k);
      } else {
        ks = initial;
      }
      do {
        init(k, 0, count);
        for (var i = 0; i < len; i++) {
          var min = Infinity, _idx = 0;
          for (var j = 0; j < k; j++) {
            var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
            if (dist2 <= min) {
              min = dist2;
              _idx = j;
            }
          }
          idxs[i] = _idx;
          count[_idx]++;
        }
        var sum3 = [], old = [], dif = 0;
        for (var _j = 0; _j < k; _j++) {
          sum3[_j] = multi ? init(vlen, 0, sum3[_j]) : 0;
          old[_j] = ks[_j];
        }
        if (multi) {
          for (var _j2 = 0; _j2 < k; _j2++) {
            ks[_j2] = [];
          }
          for (var _i = 0; _i < len; _i++) {
            var _idx2 = idxs[_i], vsum = sum3[_idx2], vect = data[_i];
            for (var h = 0; h < vlen; h++) {
              vsum[h] += vect[h];
            }
          }
          conv = true;
          for (var _j3 = 0; _j3 < k; _j3++) {
            var ksj = ks[_j3], sumj = sum3[_j3], oldj = old[_j3], cj = count[_j3];
            for (var _h = 0; _h < vlen; _h++) {
              ksj[_h] = sumj[_h] / cj || 0;
            }
            if (conv) {
              for (var _h2 = 0; _h2 < vlen; _h2++) {
                if (oldj[_h2] != ksj[_h2]) {
                  conv = false;
                  break;
                }
              }
            }
          }
        } else {
          for (var _i2 = 0; _i2 < len; _i2++) {
            var _idx3 = idxs[_i2];
            sum3[_idx3] += data[_i2];
          }
          for (var _j4 = 0; _j4 < k; _j4++) {
            ks[_j4] = sum3[_j4] / count[_j4] || 0;
          }
          conv = true;
          for (var _j5 = 0; _j5 < k; _j5++) {
            if (old[_j5] != ks[_j5]) {
              conv = false;
              break;
            }
          }
        }
        conv = conv || --it <= 0;
      } while (!conv);
      return {
        it: MAX - it,
        k,
        idxs,
        centroids: ks
      };
    }
    module.exports = skmeans2;
  }
});

// ../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x2 = data[i];
          y2 = data[i + 1];
          if (x2 < minX) minX = x2;
          if (y2 < minY) minY = y2;
          if (x2 > maxX) maxX = x2;
          if (y2 > maxY) maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals2(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals2(p, p.next) || area2(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area2(a, b, c) >= 0) return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area2(a, b, c) >= 0) return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x02, y02, minX, minY, invSize), maxZ = zOrder(x12, y12, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals2(a, b) && intersects2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m = p.x < p.next.x ? p : p.next;
            if (x2 === hx) return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan2 = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan2;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e;
            else list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || // does not create opposite-facing sectors
      equals2(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
    }
    function area2(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals2(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects2(p1, q1, p2, q2) {
      var o1 = sign3(area2(p1, q1, p2));
      var o2 = sign3(area2(p1, q1, q2));
      var o3 = sign3(area2(p2, q2, p1));
      var o4 = sign3(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign3(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node3(a.i, a.x, a.y), b2 = new Node3(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x2, y2, last) {
      var p = new Node3(i, x2, y2);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node3(i, x2, y2) {
      this.i = i;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea2 = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea2 -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea2 === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea2) / polygonArea2);
    };
    function signedArea(data, start, end, dim) {
      var sum3 = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum3 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum3;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// ../node_modules/.pnpm/@turf+helpers@7.1.0/node_modules/@turf/helpers/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  areaFactors: () => areaFactors,
  azimuthToBearing: () => azimuthToBearing,
  bearingToAzimuth: () => bearingToAzimuth,
  convertArea: () => convertArea,
  convertLength: () => convertLength,
  degreesToRadians: () => degreesToRadians,
  earthRadius: () => earthRadius,
  factors: () => factors,
  feature: () => feature,
  featureCollection: () => featureCollection,
  geometry: () => geometry,
  geometryCollection: () => geometryCollection,
  isNumber: () => isNumber,
  isObject: () => isObject,
  lengthToDegrees: () => lengthToDegrees,
  lengthToRadians: () => lengthToRadians,
  lineString: () => lineString,
  lineStrings: () => lineStrings,
  multiLineString: () => multiLineString,
  multiPoint: () => multiPoint,
  multiPolygon: () => multiPolygon,
  point: () => point,
  points: () => points,
  polygon: () => polygon,
  polygons: () => polygons,
  radiansToDegrees: () => radiansToDegrees,
  radiansToLength: () => radiansToLength,
  round: () => round,
  validateBBox: () => validateBBox,
  validateId: () => validateId
});
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var areaFactors = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function feature(geom, properties, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function geometry(type, coordinates, _options = {}) {
  switch (type) {
    case "Point":
      return point(coordinates).geometry;
    case "LineString":
      return lineString(coordinates).geometry;
    case "Polygon":
      return polygon(coordinates).geometry;
    case "MultiPoint":
      return multiPoint(coordinates).geometry;
    case "MultiLineString":
      return multiLineString(coordinates).geometry;
    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;
    default:
      throw new Error(type + " is invalid");
  }
}
function point(coordinates, properties, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function points(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return point(coords, properties);
    }),
    options
  );
}
function polygon(coordinates, properties, options = {}) {
  for (const ring of coordinates) {
    if (ring.length < 4) {
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    }
    if (ring[ring.length - 1].length !== ring[0].length) {
      throw new Error("First and last Position are not equivalent.");
    }
    for (let j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  const geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygons(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return polygon(coords, properties);
    }),
    options
  );
}
function lineString(coordinates, properties, options = {}) {
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  const geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return lineString(coords, properties);
    }),
    options
  );
}
function featureCollection(features, options = {}) {
  const fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiLineString(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiPoint",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options = {}) {
  const geom = {
    type: "GeometryCollection",
    geometries
  };
  return feature(geom, properties, options);
}
function round(num, precision = 0) {
  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }
  const multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians2 * factor;
}
function lengthToRadians(distance2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function lengthToDegrees(distance2, units) {
  return radiansToDegrees(lengthToRadians(distance2, units));
}
function bearingToAzimuth(bearing2) {
  let angle2 = bearing2 % 360;
  if (angle2 < 0) {
    angle2 += 360;
  }
  return angle2;
}
function azimuthToBearing(angle2) {
  angle2 = angle2 % 360;
  if (angle2 > 0)
    return angle2 > 180 ? angle2 - 360 : angle2;
  return angle2 < -180 ? angle2 + 360 : angle2;
}
function radiansToDegrees(radians2) {
  const degrees2 = radians2 % (2 * Math.PI);
  return degrees2 * 180 / Math.PI;
}
function degreesToRadians(degrees2) {
  const radians2 = degrees2 % 360;
  return radians2 * Math.PI / 180;
}
function convertLength(length3, originalUnit = "kilometers", finalUnit = "kilometers") {
  if (!(length3 >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length3, originalUnit), finalUnit);
}
function convertArea(area2, originalUnit = "meters", finalUnit = "kilometers") {
  if (!(area2 >= 0)) {
    throw new Error("area must be a positive number");
  }
  const startFactor = areaFactors[originalUnit];
  if (!startFactor) {
    throw new Error("invalid original units");
  }
  const finalFactor = areaFactors[finalUnit];
  if (!finalFactor) {
    throw new Error("invalid final units");
  }
  return area2 / startFactor * finalFactor;
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
  return input !== null && typeof input === "object" && !Array.isArray(input);
}
function validateBBox(bbox3) {
  if (!bbox3) {
    throw new Error("bbox is required");
  }
  if (!Array.isArray(bbox3)) {
    throw new Error("bbox must be an Array");
  }
  if (bbox3.length !== 4 && bbox3.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }
  bbox3.forEach((num) => {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }
  if (["string", "number"].indexOf(typeof id) === -1) {
    throw new Error("id must be a number or a string");
  }
}

// ../node_modules/.pnpm/@turf+invariant@7.1.0/node_modules/@turf/invariant/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  collectionOf: () => collectionOf,
  containsNumber: () => containsNumber,
  featureOf: () => featureOf,
  geojsonType: () => geojsonType,
  getCoord: () => getCoord,
  getCoords: () => getCoords,
  getGeom: () => getGeom,
  getType: () => getType
});
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function containsNumber(coordinates) {
  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {
    return true;
  }
  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }
  throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
  if (!type || !name) {
    throw new Error("type and name required");
  }
  if (!value || value.type !== type) {
    throw new Error(
      "Invalid input to " + name + ": must be a " + type + ", given " + value.type
    );
  }
}
function featureOf(feature2, type, name) {
  if (!feature2) {
    throw new Error("No feature passed");
  }
  if (!name) {
    throw new Error(".featureOf() requires a name");
  }
  if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
    throw new Error(
      "Invalid input to " + name + ", Feature with geometry required"
    );
  }
  if (!feature2.geometry || feature2.geometry.type !== type) {
    throw new Error(
      "Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type
    );
  }
}
function collectionOf(featureCollection2, type, name) {
  if (!featureCollection2) {
    throw new Error("No featureCollection passed");
  }
  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }
  if (!featureCollection2 || featureCollection2.type !== "FeatureCollection") {
    throw new Error(
      "Invalid input to " + name + ", FeatureCollection required"
    );
  }
  for (const feature2 of featureCollection2.features) {
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error(
        "Invalid input to " + name + ", Feature with geometry required"
      );
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error(
        "Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type
      );
    }
  }
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}

// ../node_modules/.pnpm/@turf+bearing@7.1.0/node_modules/@turf/bearing/dist/esm/index.js
function bearing(start, end, options = {}) {
  if (options.final === true) {
    return calculateFinalBearing(start, end);
  }
  const coordinates1 = getCoord(start);
  const coordinates2 = getCoord(end);
  const lon1 = degreesToRadians(coordinates1[0]);
  const lon2 = degreesToRadians(coordinates2[0]);
  const lat1 = degreesToRadians(coordinates1[1]);
  const lat2 = degreesToRadians(coordinates2[1]);
  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
  let bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}

// ../node_modules/.pnpm/@turf+destination@7.1.0/node_modules/@turf/destination/dist/esm/index.js
function destination(origin, distance2, bearing2, options = {}) {
  const coordinates1 = getCoord(origin);
  const longitude1 = degreesToRadians(coordinates1[0]);
  const latitude1 = degreesToRadians(coordinates1[1]);
  const bearingRad = degreesToRadians(bearing2);
  const radians2 = lengthToRadians(distance2, options.units);
  const latitude2 = Math.asin(
    Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad)
  );
  const longitude2 = longitude1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1),
    Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2)
  );
  const lng = radiansToDegrees(longitude2);
  const lat2 = radiansToDegrees(latitude2);
  return point([lng, lat2], options.properties);
}

// ../node_modules/.pnpm/@turf+distance@7.1.0/node_modules/@turf/distance/dist/esm/index.js
function distance(from, to, options = {}) {
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    options.units
  );
}

// ../node_modules/.pnpm/@turf+along@7.1.0/node_modules/@turf/along/dist/esm/index.js
function along(line, distance2, options = {}) {
  const geom = getGeom(line);
  const coords = geom.coordinates;
  let travelled = 0;
  for (let i = 0; i < coords.length; i++) {
    if (distance2 >= travelled && i === coords.length - 1) {
      break;
    } else if (travelled >= distance2) {
      const overshot = distance2 - travelled;
      if (!overshot) {
        return point(coords[i]);
      } else {
        const direction = bearing(coords[i], coords[i - 1]) - 180;
        const interpolated = destination(
          coords[i],
          overshot,
          direction,
          options
        );
        return interpolated;
      }
    } else {
      travelled += distance(coords[i], coords[i + 1], options);
    }
  }
  return point(coords[coords.length - 1]);
}

// ../node_modules/.pnpm/@turf+rhumb-bearing@7.1.0/node_modules/@turf/rhumb-bearing/dist/esm/index.js
function rhumbBearing(start, end, options = {}) {
  let bear360;
  if (options.final) {
    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));
  } else {
    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));
  }
  const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
  return bear180;
}
function calculateRhumbBearing(from, to) {
  const phi1 = degreesToRadians(from[1]);
  const phi2 = degreesToRadians(to[1]);
  let deltaLambda = degreesToRadians(to[0] - from[0]);
  if (deltaLambda > Math.PI) {
    deltaLambda -= 2 * Math.PI;
  }
  if (deltaLambda < -Math.PI) {
    deltaLambda += 2 * Math.PI;
  }
  const deltaPsi = Math.log(
    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)
  );
  const theta = Math.atan2(deltaLambda, deltaPsi);
  return (radiansToDegrees(theta) + 360) % 360;
}

// ../node_modules/.pnpm/@turf+angle@7.1.0/node_modules/@turf/angle/dist/esm/index.js
function angle(startPoint, midPoint, endPoint, options = {}) {
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  if (!startPoint) {
    throw new Error("startPoint is required");
  }
  if (!midPoint) {
    throw new Error("midPoint is required");
  }
  if (!endPoint) {
    throw new Error("endPoint is required");
  }
  const A = startPoint;
  const O = midPoint;
  const B3 = endPoint;
  const azimuthAO = bearingToAzimuth(
    options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O)
  );
  const azimuthBO = bearingToAzimuth(
    options.mercator !== true ? bearing(B3, O) : rhumbBearing(B3, O)
  );
  const angleAO = Math.abs(azimuthAO - azimuthBO);
  if (options.explementary === true) {
    return 360 - angleAO;
  }
  return angleAO;
}

// ../node_modules/.pnpm/@turf+meta@7.1.0/node_modules/@turf/meta/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  coordAll: () => coordAll,
  coordEach: () => coordEach,
  coordReduce: () => coordReduce,
  featureEach: () => featureEach,
  featureReduce: () => featureReduce,
  findPoint: () => findPoint,
  findSegment: () => findSegment,
  flattenEach: () => flattenEach,
  flattenReduce: () => flattenReduce,
  geomEach: () => geomEach,
  geomReduce: () => geomReduce,
  lineEach: () => lineEach,
  lineReduce: () => lineReduce,
  propEach: () => propEach,
  propReduce: () => propReduce,
  segmentEach: () => segmentEach,
  segmentReduce: () => segmentReduce
});
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k, l, geometry2, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry2 = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry2 === null)
        continue;
      coords = geometry2.coordinates;
      var geomType = geometry2.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry2.geometries.length; j++)
            if (coordEach(geometry2.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (coordIndex === 0 && initialValue === void 0)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false)
          break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function(currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false)
        break;
    }
  }
}
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function(currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentFeature;
    else
      previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function(coord) {
    coords.push(coord);
  });
  return coords;
}
function geomEach(geojson, callback) {
  var i, j, g, geometry2, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId2, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId2 = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry2 = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry2 === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId2
        ) === false)
          return false;
        continue;
      }
      switch (geometry2.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry2,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId2
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry2.geometries.length; j++) {
            if (callback(
              geometry2.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId2
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId2) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId2
        );
    }
  );
  return previousValue;
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry2, featureIndex, properties, bbox3, id) {
    var type = geometry2 === null ? null : geometry2.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry2, properties, { bbox: bbox3, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry2.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry2.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function(currentFeature, featureIndex, multiFeatureIndex) {
      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry)
      return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint")
      return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
function lineEach(geojson, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    if (feature2.geometry === null)
      return;
    var type = feature2.geometry.type;
    var coords = feature2.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback(
            lineString(coords[geometryIndex], feature2.properties),
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
        }
        break;
    }
  });
}
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}
function findSegment(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0)
        segmentIndex = coords.length + segmentIndex - 1;
      return lineString(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
      return point(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return point(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0)
        coordIndex = coords.length + coordIndex;
      return point(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return point(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return point(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return point(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

// ../node_modules/.pnpm/@turf+area@7.1.0/node_modules/@turf/area/dist/esm/index.js
function area(geojson) {
  return geomReduce(
    geojson,
    (value, geom) => {
      return value + calculateArea(geom);
    },
    0
  );
}
function calculateArea(geom) {
  let total = 0;
  let i;
  switch (geom.type) {
    case "Polygon":
      return polygonArea(geom.coordinates);
    case "MultiPolygon":
      for (i = 0; i < geom.coordinates.length; i++) {
        total += polygonArea(geom.coordinates[i]);
      }
      return total;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(coords) {
  let total = 0;
  if (coords && coords.length > 0) {
    total += Math.abs(ringArea(coords[0]));
    for (let i = 1; i < coords.length; i++) {
      total -= Math.abs(ringArea(coords[i]));
    }
  }
  return total;
}
var FACTOR = earthRadius * earthRadius / 2;
var PI_OVER_180 = Math.PI / 180;
function ringArea(coords) {
  const coordsLength = coords.length - 1;
  if (coordsLength <= 2)
    return 0;
  let total = 0;
  let i = 0;
  while (i < coordsLength) {
    const lower = coords[i];
    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];
    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];
    const lowerX = lower[0] * PI_OVER_180;
    const middleY = middle[1] * PI_OVER_180;
    const upperX = upper[0] * PI_OVER_180;
    total += (upperX - lowerX) * Math.sin(middleY);
    i++;
  }
  return total * FACTOR;
}

// ../node_modules/.pnpm/@turf+bbox@7.1.0/node_modules/@turf/bbox/dist/esm/index.js
function bbox(geojson, options = {}) {
  if (geojson.bbox != null && true !== options.recompute) {
    return geojson.bbox;
  }
  const result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, (coord) => {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}

// ../node_modules/.pnpm/@turf+bbox-clip@7.1.0/node_modules/@turf/bbox-clip/dist/esm/index.js
function lineclip(points2, bbox3, result) {
  var len = points2.length, codeA = bitCode(points2[0], bbox3), part = [], i, codeB, lastCode;
  let a;
  let b;
  if (!result)
    result = [];
  for (i = 1; i < len; i++) {
    a = points2[i - 1];
    b = points2[i];
    codeB = lastCode = bitCode(b, bbox3);
    while (true) {
      if (!(codeA | codeB)) {
        part.push(a);
        if (codeB !== lastCode) {
          part.push(b);
          if (i < len - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === len - 1) {
          part.push(b);
        }
        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        a = intersect(a, b, codeA, bbox3);
        codeA = bitCode(a, bbox3);
      } else {
        b = intersect(a, b, codeB, bbox3);
        codeB = bitCode(b, bbox3);
      }
    }
    codeA = lastCode;
  }
  if (part.length)
    result.push(part);
  return result;
}
function polygonclip(points2, bbox3) {
  var result, edge, prev, prevInside, i, p, inside;
  for (edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = points2[points2.length - 1];
    prevInside = !(bitCode(prev, bbox3) & edge);
    for (i = 0; i < points2.length; i++) {
      p = points2[i];
      inside = !(bitCode(p, bbox3) & edge);
      if (inside !== prevInside)
        result.push(intersect(prev, p, edge, bbox3));
      if (inside)
        result.push(p);
      prev = p;
      prevInside = inside;
    }
    points2 = result;
    if (!points2.length)
      break;
  }
  return result;
}
function intersect(a, b, edge, bbox3) {
  return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox3[3] - a[1]) / (b[1] - a[1]), bbox3[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox3[1] - a[1]) / (b[1] - a[1]), bbox3[1]] : edge & 2 ? [bbox3[2], a[1] + (b[1] - a[1]) * (bbox3[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox3[0], a[1] + (b[1] - a[1]) * (bbox3[0] - a[0]) / (b[0] - a[0])] : null;
}
function bitCode(p, bbox3) {
  var code = 0;
  if (p[0] < bbox3[0])
    code |= 1;
  else if (p[0] > bbox3[2])
    code |= 2;
  if (p[1] < bbox3[1])
    code |= 4;
  else if (p[1] > bbox3[3])
    code |= 8;
  return code;
}
function bboxClip(feature2, bbox3) {
  const geom = getGeom(feature2);
  const type = geom.type;
  const properties = feature2.type === "Feature" ? feature2.properties : {};
  let coords = geom.coordinates;
  switch (type) {
    case "LineString":
    case "MultiLineString": {
      const lines = [];
      if (type === "LineString") {
        coords = [coords];
      }
      coords.forEach((line) => {
        lineclip(line, bbox3, lines);
      });
      if (lines.length === 1) {
        return lineString(lines[0], properties);
      }
      return multiLineString(lines, properties);
    }
    case "Polygon":
      return polygon(clipPolygon(coords, bbox3), properties);
    case "MultiPolygon":
      return multiPolygon(
        coords.map((poly) => {
          return clipPolygon(poly, bbox3);
        }),
        properties
      );
    default:
      throw new Error("geometry " + type + " not supported");
  }
}
function clipPolygon(rings, bbox3) {
  const outRings = [];
  for (const ring of rings) {
    const clipped = polygonclip(ring, bbox3);
    if (clipped.length > 0) {
      if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
        clipped.push(clipped[0]);
      }
      if (clipped.length >= 4) {
        outRings.push(clipped);
      }
    }
  }
  return outRings;
}

// ../node_modules/.pnpm/@turf+bbox-polygon@7.1.0/node_modules/@turf/bbox-polygon/dist/esm/index.js
function bboxPolygon(bbox3, options = {}) {
  const west = Number(bbox3[0]);
  const south = Number(bbox3[1]);
  const east = Number(bbox3[2]);
  const north = Number(bbox3[3]);
  if (bbox3.length === 6) {
    throw new Error(
      "@turf/bbox-polygon does not support BBox with 6 positions"
    );
  }
  const lowLeft = [west, south];
  const topLeft = [west, north];
  const topRight = [east, north];
  const lowRight = [east, south];
  return polygon(
    [[lowLeft, lowRight, topRight, topLeft, lowLeft]],
    options.properties,
    { bbox: bbox3, id: options.id }
  );
}

// ../node_modules/.pnpm/@turf+bezier-spline@7.1.0/node_modules/@turf/bezier-spline/dist/esm/index.js
var Spline = class {
  constructor(options) {
    this.points = options.points || [];
    this.duration = options.duration || 1e4;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    for (let i = 0; i < this.length; i++) {
      this.points[i].z = this.points[i].z || 0;
    }
    for (let i = 0; i < this.length - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];
      this.centers.push({
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2,
        z: (p1.z + p2.z) / 2
      });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (let i = 0; i < this.centers.length - 1; i++) {
      const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
      const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
      const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
      this.controls.push([
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
        },
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
        }
      ]);
    }
    this.controls.push([
      this.points[this.length - 1],
      this.points[this.length - 1]
    ]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
  }
  /**
   * Caches an array of equidistant (more or less) points on the curve.
   */
  cacheSteps(mindist) {
    const steps = [];
    let laststep = this.pos(0);
    steps.push(0);
    for (let t = 0; t < this.duration; t += 10) {
      const step = this.pos(t);
      const dist = Math.sqrt(
        (step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z)
      );
      if (dist > mindist) {
        steps.push(t);
        laststep = step;
      }
    }
    return steps;
  }
  /**
   * returns angle and speed in the given point in the curve
   */
  vector(t) {
    const p1 = this.pos(t + 10);
    const p2 = this.pos(t - 10);
    return {
      angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
      speed: Math.sqrt(
        (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z)
      )
    };
  }
  /**
   * Gets the position of the point, given time.
   *
   * WARNING: The speed is not constant. The time it takes between control points is constant.
   *
   * For constant speed, use Spline.steps[i];
   */
  pos(time) {
    let t = time - this.delay;
    if (t < 0) {
      t = 0;
    }
    if (t > this.duration) {
      t = this.duration - 1;
    }
    const t2 = t / this.duration;
    if (t2 >= 1) {
      return this.points[this.length - 1];
    }
    const n = Math.floor((this.points.length - 1) * t2);
    const t1 = (this.length - 1) * t2 - n;
    return bezier(
      t1,
      this.points[n],
      this.controls[n][1],
      this.controls[n + 1][0],
      this.points[n + 1]
    );
  }
};
function bezier(t, p1, c1, c2, p2) {
  const b = B(t);
  const pos = {
    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
  };
  return pos;
}
function B(t) {
  const t2 = t * t;
  const t3 = t2 * t;
  return [
    t3,
    3 * t2 * (1 - t),
    3 * t * (1 - t) * (1 - t),
    (1 - t) * (1 - t) * (1 - t)
  ];
}
function bezierSpline(line, options = {}) {
  const resolution = options.resolution || 1e4;
  const sharpness = options.sharpness || 0.85;
  const coords = [];
  const points2 = getGeom(line).coordinates.map((pt) => {
    return { x: pt[0], y: pt[1] };
  });
  const spline = new Spline({
    duration: resolution,
    points: points2,
    sharpness
  });
  const pushCoord = (time) => {
    var pos = spline.pos(time);
    if (Math.floor(time / 100) % 2 === 0) {
      coords.push([pos.x, pos.y]);
    }
  };
  for (var i = 0; i < spline.duration; i += 10) {
    pushCoord(i);
  }
  pushCoord(spline.duration);
  return lineString(coords, options.properties);
}

// ../node_modules/.pnpm/@turf+boolean-clockwise@7.1.0/node_modules/@turf/boolean-clockwise/dist/esm/index.js
function booleanClockwise(line) {
  const ring = getCoords(line);
  let sum3 = 0;
  let i = 1;
  let prev;
  let cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum3 += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum3 > 0;
}

// ../node_modules/.pnpm/@turf+boolean-concave@7.1.0/node_modules/@turf/boolean-concave/dist/esm/index.js
function booleanConcave(polygon2) {
  const coords = getGeom(polygon2).coordinates;
  if (coords[0].length <= 4) {
    return false;
  }
  let sign3 = false;
  const n = coords[0].length - 1;
  for (let i = 0; i < n; i++) {
    const dx1 = coords[0][(i + 2) % n][0] - coords[0][(i + 1) % n][0];
    const dy1 = coords[0][(i + 2) % n][1] - coords[0][(i + 1) % n][1];
    const dx2 = coords[0][i][0] - coords[0][(i + 1) % n][0];
    const dy2 = coords[0][i][1] - coords[0][(i + 1) % n][1];
    const zcrossproduct = dx1 * dy2 - dy1 * dx2;
    if (i === 0) {
      sign3 = zcrossproduct > 0;
    } else if (sign3 !== zcrossproduct > 0) {
      return true;
    }
  }
  return false;
}

// ../node_modules/.pnpm/point-in-polygon-hao@1.1.0/node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs
function pointInPolygon(p, polygon2) {
  var i = 0;
  var ii = 0;
  var k = 0;
  var f = 0;
  var u1 = 0;
  var v1 = 0;
  var u22 = 0;
  var v2 = 0;
  var currentP = null;
  var nextP = null;
  var x2 = p[0];
  var y2 = p[1];
  var numContours = polygon2.length;
  for (i; i < numContours; i++) {
    ii = 0;
    var contourLen = polygon2[i].length - 1;
    var contour = polygon2[i];
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x2;
    v1 = currentP[1] - y2;
    for (ii; ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      v2 = nextP[1] - y2;
      if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
        currentP = nextP;
        v1 = v2;
        u1 = currentP[0] - x2;
        continue;
      }
      u22 = nextP[0] - p[0];
      if (v2 > 0 && v1 <= 0) {
        f = u1 * v2 - u22 * v1;
        if (f > 0) {
          k = k + 1;
        } else if (f === 0) {
          return 0;
        }
      } else if (v1 > 0 && v2 <= 0) {
        f = u1 * v2 - u22 * v1;
        if (f < 0) {
          k = k + 1;
        } else if (f === 0) {
          return 0;
        }
      } else if (v2 === 0 && v1 < 0) {
        f = u1 * v2 - u22 * v1;
        if (f === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 < 0) {
        f = u1 * v2 - u22 * v1;
        if (f === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 === 0) {
        if (u22 <= 0 && u1 >= 0) {
          return 0;
        } else if (u1 <= 0 && u22 >= 0) {
          return 0;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u22;
    }
  }
  if (k % 2 === 0) {
    return false;
  }
  return true;
}
var pointInPolygon_default = pointInPolygon;

// ../node_modules/.pnpm/@turf+boolean-point-in-polygon@7.1.0/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js
function booleanPointInPolygon(point2, polygon2, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon2);
  const type = geom.type;
  const bbox3 = polygon2.bbox;
  let polys = geom.coordinates;
  if (bbox3 && inBBox(pt, bbox3) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  let result = false;
  for (var i = 0; i < polys.length; ++i) {
    const polyResult = pointInPolygon_default(pt, polys[i]);
    if (polyResult === 0)
      return options.ignoreBoundary ? false : true;
    else if (polyResult)
      result = true;
  }
  return result;
}
function inBBox(pt, bbox3) {
  return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
}

// ../node_modules/.pnpm/@turf+boolean-point-on-line@7.1.0/node_modules/@turf/boolean-point-on-line/dist/esm/index.js
function booleanPointOnLine(pt, line, options = {}) {
  const ptCoords = getCoord(pt);
  const lineCoords = getCoords(line);
  for (let i = 0; i < lineCoords.length - 1; i++) {
    let ignoreBoundary = false;
    if (options.ignoreEndVertices) {
      if (i === 0) {
        ignoreBoundary = "start";
      }
      if (i === lineCoords.length - 2) {
        ignoreBoundary = "end";
      }
      if (i === 0 && i + 1 === lineCoords.length - 1) {
        ignoreBoundary = "both";
      }
    }
    if (isPointOnLineSegment(
      lineCoords[i],
      lineCoords[i + 1],
      ptCoords,
      ignoreBoundary,
      typeof options.epsilon === "undefined" ? null : options.epsilon
    )) {
      return true;
    }
  }
  return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon6) {
  const x2 = pt[0];
  const y2 = pt[1];
  const x12 = lineSegmentStart[0];
  const y12 = lineSegmentStart[1];
  const x22 = lineSegmentEnd[0];
  const y22 = lineSegmentEnd[1];
  const dxc = pt[0] - x12;
  const dyc = pt[1] - y12;
  const dxl = x22 - x12;
  const dyl = y22 - y12;
  const cross = dxc * dyl - dyc * dxl;
  if (epsilon6 !== null) {
    if (Math.abs(cross) > epsilon6) {
      return false;
    }
  } else if (cross !== 0) {
    return false;
  }
  if (!excludeBoundary) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x2 && x2 <= x22 : x22 <= x2 && x2 <= x12;
    }
    return dyl > 0 ? y12 <= y2 && y2 <= y22 : y22 <= y2 && y2 <= y12;
  } else if (excludeBoundary === "start") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x2 && x2 <= x22 : x22 <= x2 && x2 < x12;
    }
    return dyl > 0 ? y12 < y2 && y2 <= y22 : y22 <= y2 && y2 < y12;
  } else if (excludeBoundary === "end") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x2 && x2 < x22 : x22 < x2 && x2 <= x12;
    }
    return dyl > 0 ? y12 <= y2 && y2 < y22 : y22 < y2 && y2 <= y12;
  } else if (excludeBoundary === "both") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x2 && x2 < x22 : x22 < x2 && x2 < x12;
    }
    return dyl > 0 ? y12 < y2 && y2 < y22 : y22 < y2 && y2 < y12;
  }
  return false;
}

// ../node_modules/.pnpm/@turf+boolean-contains@7.1.0/node_modules/@turf/boolean-contains/dist/esm/index.js
function booleanContains(feature1, feature2) {
  const geom1 = getGeom(feature1);
  const geom2 = getGeom(feature2);
  const type1 = geom1.type;
  const type2 = geom2.type;
  const coords1 = geom1.coordinates;
  const coords2 = geom2.coordinates;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "Point":
          return compareCoords(coords1, coords2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "Point":
          return isPointInMultiPoint(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInMultiPoint(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "Point":
          return booleanPointOnLine(geom2, geom1, { ignoreEndVertices: true });
        case "LineString":
          return isLineOnLine(geom1, geom2);
        case "MultiPoint":
          return isMultiPointOnLine(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Point":
          return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });
        case "LineString":
          return isLineInPoly(geom1, geom2);
        case "Polygon":
          return isPolyInPoly(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPolygon":
      switch (type2) {
        case "Polygon":
          return isPolygonInMultiPolygon(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPolygonInMultiPolygon(multiPolygon2, polygon2) {
  return multiPolygon2.coordinates.some(
    (coords) => isPolyInPoly({ type: "Polygon", coordinates: coords }, polygon2)
  );
}
function isPointInMultiPoint(multiPoint2, pt) {
  let i;
  let output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords(multiPoint2.coordinates[i], pt.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
  for (const coord2 of multiPoint2.coordinates) {
    let matchFound = false;
    for (const coord1 of multiPoint1.coordinates) {
      if (compareCoords(coord2, coord1)) {
        matchFound = true;
        break;
      }
    }
    if (!matchFound) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine(lineString2, multiPoint2) {
  let haveFoundInteriorPoint = false;
  for (const coord of multiPoint2.coordinates) {
    if (booleanPointOnLine(coord, lineString2, { ignoreEndVertices: true })) {
      haveFoundInteriorPoint = true;
    }
    if (!booleanPointOnLine(coord, lineString2)) {
      return false;
    }
  }
  if (haveFoundInteriorPoint) {
    return true;
  }
  return false;
}
function isMultiPointInPoly(polygon2, multiPoint2) {
  for (const coord of multiPoint2.coordinates) {
    if (!booleanPointInPolygon(coord, polygon2, { ignoreBoundary: true })) {
      return false;
    }
  }
  return true;
}
function isLineOnLine(lineString1, lineString2) {
  let haveFoundInteriorPoint = false;
  for (const coords of lineString2.coordinates) {
    if (booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: true
    })) {
      haveFoundInteriorPoint = true;
    }
    if (!booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: false
    })) {
      return false;
    }
  }
  return haveFoundInteriorPoint;
}
function isLineInPoly(polygon2, linestring) {
  let output = false;
  let i = 0;
  const polyBbox = bbox(polygon2);
  const lineBbox = bbox(linestring);
  if (!doBBoxOverlap(polyBbox, lineBbox)) {
    return false;
  }
  for (i; i < linestring.coordinates.length - 1; i++) {
    const midPoint = getMidpoint(
      linestring.coordinates[i],
      linestring.coordinates[i + 1]
    );
    if (booleanPointInPolygon({ type: "Point", coordinates: midPoint }, polygon2, {
      ignoreBoundary: true
    })) {
      output = true;
      break;
    }
  }
  return output;
}
function isPolyInPoly(feature1, feature2) {
  if (feature1.type === "Feature" && feature1.geometry === null) {
    return false;
  }
  if (feature2.type === "Feature" && feature2.geometry === null) {
    return false;
  }
  const poly1Bbox = bbox(feature1);
  const poly2Bbox = bbox(feature2);
  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
    return false;
  }
  const coords = getGeom(feature2).coordinates;
  for (const ring of coords) {
    for (const coord of ring) {
      if (!booleanPointInPolygon(coord, feature1)) {
        return false;
      }
    }
  }
  return true;
}
function doBBoxOverlap(bbox1, bbox22) {
  if (bbox1[0] > bbox22[0]) {
    return false;
  }
  if (bbox1[2] < bbox22[2]) {
    return false;
  }
  if (bbox1[1] > bbox22[1]) {
    return false;
  }
  if (bbox1[3] < bbox22[3]) {
    return false;
  }
  return true;
}
function compareCoords(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}

// ../node_modules/.pnpm/sweepline-intersections@1.5.0/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js
var TinyQueue = class {
  constructor(data = [], compare = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare(best, item) >= 0) break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
};
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function checkWhichEventIsLeft(e1, e22) {
  if (e1.p.x > e22.p.x) return 1;
  if (e1.p.x < e22.p.x) return -1;
  if (e1.p.y !== e22.p.y) return e1.p.y > e22.p.y ? 1 : -1;
  return 1;
}
function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
  if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1;
  if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1;
  if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;
  return 1;
}
var Event = class {
  constructor(p, featureId2, ringId2, eventId2) {
    this.p = {
      x: p[0],
      y: p[1]
    };
    this.featureId = featureId2;
    this.ringId = ringId2;
    this.eventId = eventId2;
    this.otherEvent = null;
    this.isLeftEndpoint = null;
  }
  isSamePoint(eventToCheck) {
    return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;
  }
};
function fillEventQueue(geojson, eventQueue) {
  if (geojson.type === "FeatureCollection") {
    const features = geojson.features;
    for (let i = 0; i < features.length; i++) {
      processFeature(features[i], eventQueue);
    }
  } else {
    processFeature(geojson, eventQueue);
  }
}
var featureId = 0;
var ringId = 0;
var eventId = 0;
function processFeature(featureOrGeometry, eventQueue) {
  const geom = featureOrGeometry.type === "Feature" ? featureOrGeometry.geometry : featureOrGeometry;
  let coords = geom.coordinates;
  if (geom.type === "Polygon" || geom.type === "MultiLineString") coords = [coords];
  if (geom.type === "LineString") coords = [[coords]];
  for (let i = 0; i < coords.length; i++) {
    for (let ii = 0; ii < coords[i].length; ii++) {
      let currentP = coords[i][ii][0];
      let nextP = null;
      ringId = ringId + 1;
      for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {
        nextP = coords[i][ii][iii + 1];
        const e1 = new Event(currentP, featureId, ringId, eventId);
        const e22 = new Event(nextP, featureId, ringId, eventId + 1);
        e1.otherEvent = e22;
        e22.otherEvent = e1;
        if (checkWhichEventIsLeft(e1, e22) > 0) {
          e22.isLeftEndpoint = true;
          e1.isLeftEndpoint = false;
        } else {
          e1.isLeftEndpoint = true;
          e22.isLeftEndpoint = false;
        }
        eventQueue.push(e1);
        eventQueue.push(e22);
        currentP = nextP;
        eventId = eventId + 1;
      }
    }
  }
  featureId = featureId + 1;
}
var Segment = class {
  constructor(event) {
    this.leftSweepEvent = event;
    this.rightSweepEvent = event.otherEvent;
  }
};
function testSegmentIntersect(seg1, seg2) {
  if (seg1 === null || seg2 === null) return false;
  if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false;
  const x12 = seg1.leftSweepEvent.p.x;
  const y12 = seg1.leftSweepEvent.p.y;
  const x2 = seg1.rightSweepEvent.p.x;
  const y2 = seg1.rightSweepEvent.p.y;
  const x3 = seg2.leftSweepEvent.p.x;
  const y3 = seg2.leftSweepEvent.p.y;
  const x4 = seg2.rightSweepEvent.p.x;
  const y4 = seg2.rightSweepEvent.p.y;
  const denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y12);
  const numeA = (x4 - x3) * (y12 - y3) - (y4 - y3) * (x12 - x3);
  const numeB = (x2 - x12) * (y12 - y3) - (y2 - y12) * (x12 - x3);
  if (denom === 0) {
    if (numeA === 0 && numeB === 0) return false;
    return false;
  }
  const uA = numeA / denom;
  const uB = numeB / denom;
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    const x5 = x12 + uA * (x2 - x12);
    const y5 = y12 + uA * (y2 - y12);
    return [x5, y5];
  }
  return false;
}
function runCheck(eventQueue, ignoreSelfIntersections) {
  ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;
  const intersectionPoints = [];
  const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);
  while (eventQueue.length) {
    const event = eventQueue.pop();
    if (event.isLeftEndpoint) {
      const segment = new Segment(event);
      for (let i = 0; i < outQueue.data.length; i++) {
        const otherSeg = outQueue.data[i];
        if (ignoreSelfIntersections) {
          if (otherSeg.leftSweepEvent.featureId === event.featureId) continue;
        }
        const intersection3 = testSegmentIntersect(segment, otherSeg);
        if (intersection3 !== false) intersectionPoints.push(intersection3);
      }
      outQueue.push(segment);
    } else if (event.isLeftEndpoint === false) {
      outQueue.pop();
    }
  }
  return intersectionPoints;
}
function sweeplineIntersections(geojson, ignoreSelfIntersections) {
  const eventQueue = new TinyQueue([], checkWhichEventIsLeft);
  fillEventQueue(geojson, eventQueue);
  return runCheck(eventQueue, ignoreSelfIntersections);
}
var sweeplineIntersections_esm_default = sweeplineIntersections;

// ../node_modules/.pnpm/@turf+line-intersect@7.1.0/node_modules/@turf/line-intersect/dist/esm/index.js
var sweeplineIntersections2 = sweeplineIntersections_esm_default;
function lineIntersect(line1, line2, options = {}) {
  const { removeDuplicates: removeDuplicates2 = true, ignoreSelfIntersections = false } = options;
  let features = [];
  if (line1.type === "FeatureCollection")
    features = features.concat(line1.features);
  else if (line1.type === "Feature")
    features.push(line1);
  else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
    features.push(feature(line1));
  }
  if (line2.type === "FeatureCollection")
    features = features.concat(line2.features);
  else if (line2.type === "Feature")
    features.push(line2);
  else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
    features.push(feature(line2));
  }
  const intersections = sweeplineIntersections2(
    featureCollection(features),
    ignoreSelfIntersections
  );
  let results = [];
  if (removeDuplicates2) {
    const unique = {};
    intersections.forEach((intersection3) => {
      const key = intersection3.join(",");
      if (!unique[key]) {
        unique[key] = true;
        results.push(intersection3);
      }
    });
  } else {
    results = intersections;
  }
  return featureCollection(results.map((r) => point(r)));
}

// ../node_modules/.pnpm/@turf+polygon-to-line@7.1.0/node_modules/@turf/polygon-to-line/dist/esm/index.js
function polygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return singlePolygonToLine(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function singlePolygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  const coords = geom.coordinates;
  const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options = {}) {
  const geom = getGeom(multiPoly);
  const coords = geom.coordinates;
  const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  const lines = [];
  coords.forEach((coord) => {
    lines.push(coordsToLine(coord, properties));
  });
  return featureCollection(lines);
}
function coordsToLine(coords, properties) {
  if (coords.length > 1) {
    return multiLineString(coords, properties);
  }
  return lineString(coords[0], properties);
}

// ../node_modules/.pnpm/@turf+boolean-crosses@7.1.0/node_modules/@turf/boolean-crosses/dist/esm/index.js
function booleanCrosses(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "MultiPoint":
      switch (type2) {
        case "LineString":
          return doMultiPointAndLineStringCross(geom1, geom2);
        case "Polygon":
          return doesMultiPointCrossPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "MultiPoint":
          return doMultiPointAndLineStringCross(geom2, geom1);
        case "LineString":
          return doLineStringsCross(geom1, geom2);
        case "Polygon":
          return doLineStringAndPolygonCross(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "MultiPoint":
          return doesMultiPointCrossPoly(geom2, geom1);
        case "LineString":
          return doLineStringAndPolygonCross(geom2, geom1);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function doMultiPointAndLineStringCross(multiPoint2, lineString2) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  var i = 0;
  while (i < pointLength && !foundIntPoint && !foundExtPoint) {
    for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
      var incEndVertices = true;
      if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
        incEndVertices = false;
      }
      if (isPointOnLineSegment2(
        lineString2.coordinates[i2],
        lineString2.coordinates[i2 + 1],
        multiPoint2.coordinates[i],
        incEndVertices
      )) {
        foundIntPoint = true;
      } else {
        foundExtPoint = true;
      }
    }
    i++;
  }
  return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
  var doLinesIntersect = lineIntersect(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
        var incEndVertices = true;
        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
          incEndVertices = false;
        }
        if (isPointOnLineSegment2(
          lineString1.coordinates[i],
          lineString1.coordinates[i + 1],
          lineString2.coordinates[i2],
          incEndVertices
        )) {
          return true;
        }
      }
    }
  }
  return false;
}
function doLineStringAndPolygonCross(lineString2, polygon2) {
  const line = polygonToLine(polygon2);
  const doLinesIntersect = lineIntersect(lineString2, line);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function doesMultiPointCrossPoly(multiPoint2, polygon2) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  for (let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
    if (booleanPointInPolygon(point(multiPoint2.coordinates[i]), polygon2)) {
      foundIntPoint = true;
    } else {
      foundExtPoint = true;
    }
  }
  return foundExtPoint && foundIntPoint;
}
function isPointOnLineSegment2(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (incEnd) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  } else {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
  }
}

// ../node_modules/.pnpm/@turf+boolean-disjoint@7.1.0/node_modules/@turf/boolean-disjoint/dist/esm/index.js
function booleanDisjoint(feature1, feature2, options = {}) {
  var _a;
  const ignoreSelfIntersections = (_a = options.ignoreSelfIntersections) != null ? _a : false;
  let bool = true;
  flattenEach(feature1, (flatten1) => {
    flattenEach(feature2, (flatten2) => {
      if (bool === false) {
        return false;
      }
      bool = disjoint(
        flatten1.geometry,
        flatten2.geometry,
        ignoreSelfIntersections
      );
    });
  });
  return bool;
}
function disjoint(geom1, geom2, ignoreSelfIntersections) {
  switch (geom1.type) {
    case "Point":
      switch (geom2.type) {
        case "Point":
          return !compareCoords2(geom1.coordinates, geom2.coordinates);
        case "LineString":
          return !isPointOnLine(geom2, geom1);
        case "Polygon":
          return !booleanPointInPolygon(geom1, geom2);
      }
      break;
    case "LineString":
      switch (geom2.type) {
        case "Point":
          return !isPointOnLine(geom1, geom2);
        case "LineString":
          return !isLineOnLine2(geom1, geom2, ignoreSelfIntersections);
        case "Polygon":
          return !isLineInPoly2(geom2, geom1, ignoreSelfIntersections);
      }
      break;
    case "Polygon":
      switch (geom2.type) {
        case "Point":
          return !booleanPointInPolygon(geom2, geom1);
        case "LineString":
          return !isLineInPoly2(geom1, geom2, ignoreSelfIntersections);
        case "Polygon":
          return !isPolyInPoly2(geom2, geom1, ignoreSelfIntersections);
      }
  }
  return false;
}
function isPointOnLine(lineString2, pt) {
  for (let i = 0; i < lineString2.coordinates.length - 1; i++) {
    if (isPointOnLineSegment3(
      lineString2.coordinates[i],
      lineString2.coordinates[i + 1],
      pt.coordinates
    )) {
      return true;
    }
  }
  return false;
}
function isLineOnLine2(lineString1, lineString2, ignoreSelfIntersections) {
  const doLinesIntersect = lineIntersect(lineString1, lineString2, {
    ignoreSelfIntersections
  });
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isLineInPoly2(polygon2, lineString2, ignoreSelfIntersections) {
  for (const coord of lineString2.coordinates) {
    if (booleanPointInPolygon(coord, polygon2)) {
      return true;
    }
  }
  const doLinesIntersect = lineIntersect(lineString2, polygonToLine(polygon2), {
    ignoreSelfIntersections
  });
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPolyInPoly2(feature1, feature2, ignoreSelfIntersections) {
  for (const coord1 of feature1.coordinates[0]) {
    if (booleanPointInPolygon(coord1, feature2)) {
      return true;
    }
  }
  for (const coord2 of feature2.coordinates[0]) {
    if (booleanPointInPolygon(coord2, feature1)) {
      return true;
    }
  }
  const doLinesIntersect = lineIntersect(
    polygonToLine(feature1),
    polygonToLine(feature2),
    { ignoreSelfIntersections }
  );
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPointOnLineSegment3(lineSegmentStart, lineSegmentEnd, pt) {
  const dxc = pt[0] - lineSegmentStart[0];
  const dyc = pt[1] - lineSegmentStart[1];
  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  const cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (Math.abs(dxl) >= Math.abs(dyl)) {
    if (dxl > 0) {
      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
    } else {
      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
  } else if (dyl > 0) {
    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
  } else {
    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  }
}
function compareCoords2(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}

// ../node_modules/.pnpm/geojson-equality-ts@1.0.2/node_modules/geojson-equality-ts/dist/esm/index.js
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var _GeojsonEquality = class _GeojsonEquality2 {
  constructor(opts) {
    this.direction = false;
    this.compareProperties = true;
    var _a, _b, _c;
    this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);
    this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;
    this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
  }
  compare(g1, g2) {
    if (g1.type !== g2.type) {
      return false;
    }
    if (!sameLength(g1, g2)) {
      return false;
    }
    switch (g1.type) {
      case "Point":
        return this.compareCoord(g1.coordinates, g2.coordinates);
      case "LineString":
        return this.compareLine(g1.coordinates, g2.coordinates);
      case "Polygon":
        return this.comparePolygon(g1, g2);
      case "GeometryCollection":
        return this.compareGeometryCollection(g1, g2);
      case "Feature":
        return this.compareFeature(g1, g2);
      case "FeatureCollection":
        return this.compareFeatureCollection(g1, g2);
      default:
        if (g1.type.startsWith("Multi")) {
          const g1s = explode(g1);
          const g2s = explode(
            g2
          );
          return g1s.every(
            (g1part) => g2s.some((g2part) => this.compare(g1part, g2part))
          );
        }
    }
    return false;
  }
  compareCoord(c1, c2) {
    return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);
  }
  compareLine(path1, path2, ind = 0, isPoly = false) {
    if (!sameLength(path1, path2)) {
      return false;
    }
    const p1 = path1;
    let p2 = path2;
    if (isPoly && !this.compareCoord(p1[0], p2[0])) {
      const startIndex = this.fixStartIndex(p2, p1);
      if (!startIndex) {
        return false;
      } else {
        p2 = startIndex;
      }
    }
    const sameDirection = this.compareCoord(p1[ind], p2[ind]);
    if (this.direction || sameDirection) {
      return this.comparePath(p1, p2);
    } else {
      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
        return this.comparePath(p1.slice().reverse(), p2);
      }
      return false;
    }
  }
  fixStartIndex(sourcePath, targetPath) {
    let correctPath, ind = -1;
    for (let i = 0; i < sourcePath.length; i++) {
      if (this.compareCoord(sourcePath[i], targetPath[0])) {
        ind = i;
        break;
      }
    }
    if (ind >= 0) {
      correctPath = [].concat(
        sourcePath.slice(ind, sourcePath.length),
        sourcePath.slice(1, ind + 1)
      );
    }
    return correctPath;
  }
  comparePath(p1, p2) {
    return p1.every((c, i) => this.compareCoord(c, p2[i]));
  }
  comparePolygon(g1, g2) {
    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
      return holes1.every(
        (h1) => holes2.some((h2) => this.compareLine(h1, h2, 1, true))
      );
    }
    return false;
  }
  compareGeometryCollection(g1, g2) {
    return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]));
  }
  compareFeature(g1, g2) {
    return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
  }
  compareFeatureCollection(g1, g2) {
    return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i) => this.compare(f, g2.features[i]));
  }
  compareBBox(g1, g2) {
    return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
  }
};
__name(_GeojsonEquality, "GeojsonEquality");
var GeojsonEquality = _GeojsonEquality;
function sameLength(g1, g2) {
  return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
__name(sameLength, "sameLength");
function explode(g) {
  return g.coordinates.map((part) => ({
    type: g.type.replace("Multi", ""),
    coordinates: part
  }));
}
__name(explode, "explode");
function geojsonEquality(g1, g2, opts) {
  const eq = new GeojsonEquality(opts);
  return eq.compare(g1, g2);
}
__name(geojsonEquality, "geojsonEquality");
function equal(object1, object2) {
  if (object1 === null && object2 === null) {
    return true;
  }
  if (object1 === null || object2 === null) {
    return false;
  }
  const objKeys1 = Object.keys(object1);
  const objKeys2 = Object.keys(object2);
  if (objKeys1.length !== objKeys2.length) return false;
  for (var key of objKeys1) {
    const value1 = object1[key];
    const value2 = object2[key];
    const isObjects = isObject2(value1) && isObject2(value2);
    if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
}
__name(equal, "equal");
var isObject2 = __name((object2) => {
  return object2 != null && typeof object2 === "object";
}, "isObject");

// ../node_modules/.pnpm/@turf+clean-coords@7.1.0/node_modules/@turf/clean-coords/dist/esm/index.js
function cleanCoords(geojson, options = {}) {
  var mutate = typeof options === "object" ? options.mutate : options;
  if (!geojson)
    throw new Error("geojson is required");
  var type = getType(geojson);
  var newCoords = [];
  switch (type) {
    case "LineString":
      newCoords = cleanLine(geojson, type);
      break;
    case "MultiLineString":
    case "Polygon":
      getCoords(geojson).forEach(function(line) {
        newCoords.push(cleanLine(line, type));
      });
      break;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(polygons2) {
        var polyPoints = [];
        polygons2.forEach(function(ring) {
          polyPoints.push(cleanLine(ring, type));
        });
        newCoords.push(polyPoints);
      });
      break;
    case "Point":
      return geojson;
    case "MultiPoint":
      var existing = {};
      getCoords(geojson).forEach(function(coord) {
        var key = coord.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;
    default:
      throw new Error(type + " geometry not supported");
  }
  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }
    return { type, coordinates: newCoords };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }
    return feature({ type, coordinates: newCoords }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
function cleanLine(line, type) {
  var points2 = getCoords(line);
  if (points2.length === 2 && !equals(points2[0], points2[1]))
    return points2;
  var newPoints = [];
  var secondToLast = points2.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points2[0]);
  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points2[i][0] === prevAddedPoint[0] && points2[i][1] === prevAddedPoint[1])
      continue;
    else {
      newPoints.push(points2[i]);
      newPointsLength = newPoints.length;
      if (newPointsLength > 2) {
        if (isPointOnLineSegment4(
          newPoints[newPointsLength - 3],
          newPoints[newPointsLength - 1],
          newPoints[newPointsLength - 2]
        ))
          newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }
  newPoints.push(points2[points2.length - 1]);
  newPointsLength = newPoints.length;
  if ((type === "Polygon" || type === "MultiPolygon") && equals(points2[0], points2[points2.length - 1]) && newPointsLength < 4) {
    throw new Error("invalid polygon");
  }
  if (type === "LineString" && newPointsLength < 3) {
    return newPoints;
  }
  if (isPointOnLineSegment4(
    newPoints[newPointsLength - 3],
    newPoints[newPointsLength - 1],
    newPoints[newPointsLength - 2]
  ))
    newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
function equals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment4(start, end, point2) {
  var x2 = point2[0], y2 = point2[1];
  var startX = start[0], startY = start[1];
  var endX = end[0], endY = end[1];
  var dxc = x2 - startX;
  var dyc = y2 - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0)
    return false;
  else if (Math.abs(dxl) >= Math.abs(dyl))
    return dxl > 0 ? startX <= x2 && x2 <= endX : endX <= x2 && x2 <= startX;
  else
    return dyl > 0 ? startY <= y2 && y2 <= endY : endY <= y2 && y2 <= startY;
}

// ../node_modules/.pnpm/@turf+boolean-equal@7.1.0/node_modules/@turf/boolean-equal/dist/esm/index.js
function booleanEqual(feature1, feature2, options = {}) {
  let precision = options.precision;
  precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
  if (typeof precision !== "number" || !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }
  const type1 = getGeom(feature1).type;
  const type2 = getGeom(feature2).type;
  if (type1 !== type2)
    return false;
  return geojsonEquality(cleanCoords(feature1), cleanCoords(feature2), {
    precision
  });
}

// ../node_modules/.pnpm/@turf+boolean-intersects@7.1.0/node_modules/@turf/boolean-intersects/dist/esm/index.js
function booleanIntersects(feature1, feature2, options = {}) {
  var _a;
  const ignoreSelfIntersections = (_a = options.ignoreSelfIntersections) != null ? _a : false;
  let bool = false;
  flattenEach(feature1, (flatten1) => {
    flattenEach(feature2, (flatten2) => {
      if (bool === true) {
        return true;
      }
      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {
        ignoreSelfIntersections
      });
    });
  });
  return bool;
}

// ../node_modules/.pnpm/quickselect@2.0.0/node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare2);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare2(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// ../node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox3) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox3, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox3, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox3, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox3) {
    let node = this.data;
    if (!intersects(bbox3, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox3, childBBox)) {
          if (node.leaf || contains(bbox3, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox3 = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index2 = findItem(item, node.children, equalsFn);
        if (index2 !== -1) {
          node.children.splice(index2, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox3)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox3, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area2 = bboxArea(child);
        const enlargement = enlargedArea(bbox3, child) - area2;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area2 < minArea ? area2 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area2 < minArea) {
            minArea = area2;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox3 = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox3, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox3);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else break;
    }
    this._adjustParentBBoxes(bbox3, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index2;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox22 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox22);
      const area2 = bboxArea(bbox1) + bboxArea(bbox22);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index2 = i;
        minArea = area2 < minArea ? area2 : minArea;
      } else if (overlap === minOverlap) {
        if (area2 < minArea) {
          minArea = area2;
          index2 = i;
        }
      }
    }
    return index2 || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox3, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox3);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// ../node_modules/.pnpm/@turf+geojson-rbush@7.1.0/node_modules/@turf/geojson-rbush/dist/esm/index.js
function geojsonRbush(maxEntries) {
  var tree = new RBush(maxEntries);
  tree.insert = function(feature2) {
    if (feature2.type !== "Feature")
      throw new Error("invalid feature");
    feature2.bbox = feature2.bbox ? feature2.bbox : bbox(feature2);
    return RBush.prototype.insert.call(this, feature2);
  };
  tree.load = function(features) {
    var load = [];
    if (Array.isArray(features)) {
      features.forEach(function(feature2) {
        if (feature2.type !== "Feature")
          throw new Error("invalid features");
        feature2.bbox = feature2.bbox ? feature2.bbox : bbox(feature2);
        load.push(feature2);
      });
    } else {
      featureEach(features, function(feature2) {
        if (feature2.type !== "Feature")
          throw new Error("invalid features");
        feature2.bbox = feature2.bbox ? feature2.bbox : bbox(feature2);
        load.push(feature2);
      });
    }
    return RBush.prototype.load.call(this, load);
  };
  tree.remove = function(feature2, equals2) {
    if (feature2.type !== "Feature")
      throw new Error("invalid feature");
    feature2.bbox = feature2.bbox ? feature2.bbox : bbox(feature2);
    return RBush.prototype.remove.call(this, feature2, equals2);
  };
  tree.clear = function() {
    return RBush.prototype.clear.call(this);
  };
  tree.search = function(geojson) {
    var features = RBush.prototype.search.call(this, this.toBBox(geojson));
    return featureCollection(features);
  };
  tree.collides = function(geojson) {
    return RBush.prototype.collides.call(this, this.toBBox(geojson));
  };
  tree.all = function() {
    var features = RBush.prototype.all.call(this);
    return featureCollection(features);
  };
  tree.toJSON = function() {
    return RBush.prototype.toJSON.call(this);
  };
  tree.fromJSON = function(json) {
    return RBush.prototype.fromJSON.call(this, json);
  };
  tree.toBBox = function(geojson) {
    var bbox3;
    if (geojson.bbox)
      bbox3 = geojson.bbox;
    else if (Array.isArray(geojson) && geojson.length === 4)
      bbox3 = geojson;
    else if (Array.isArray(geojson) && geojson.length === 6)
      bbox3 = [geojson[0], geojson[1], geojson[3], geojson[4]];
    else if (geojson.type === "Feature")
      bbox3 = bbox(geojson);
    else if (geojson.type === "FeatureCollection")
      bbox3 = bbox(geojson);
    else
      throw new Error("invalid geojson");
    return {
      minX: bbox3[0],
      minY: bbox3[1],
      maxX: bbox3[2],
      maxY: bbox3[3]
    };
  };
  return tree;
}

// ../node_modules/.pnpm/@turf+line-segment@7.1.0/node_modules/@turf/line-segment/dist/esm/index.js
function lineSegment(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  const results = [];
  flattenEach(geojson, (feature2) => {
    lineSegmentFeature(feature2, results);
  });
  return featureCollection(results);
}
function lineSegmentFeature(geojson, results) {
  let coords = [];
  const geometry2 = geojson.geometry;
  if (geometry2 !== null) {
    switch (geometry2.type) {
      case "Polygon":
        coords = getCoords(geometry2);
        break;
      case "LineString":
        coords = [getCoords(geometry2)];
    }
    coords.forEach((coord) => {
      const segments = createSegments(coord, geojson.properties);
      segments.forEach((segment) => {
        segment.id = results.length;
        results.push(segment);
      });
    });
  }
}
function createSegments(coords, properties) {
  const segments = [];
  coords.reduce((previousCoords, currentCoords) => {
    const segment = lineString([previousCoords, currentCoords], properties);
    segment.bbox = bbox2(previousCoords, currentCoords);
    segments.push(segment);
    return currentCoords;
  });
  return segments;
}
function bbox2(coords1, coords2) {
  const x12 = coords1[0];
  const y12 = coords1[1];
  const x2 = coords2[0];
  const y2 = coords2[1];
  const west = x12 < x2 ? x12 : x2;
  const south = y12 < y2 ? y12 : y2;
  const east = x12 > x2 ? x12 : x2;
  const north = y12 > y2 ? y12 : y2;
  return [west, south, east, north];
}

// ../node_modules/.pnpm/@turf+nearest-point-on-line@7.1.0/node_modules/@turf/nearest-point-on-line/dist/esm/index.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function nearestPointOnLine(lines, pt, options = {}) {
  if (!lines || !pt) {
    throw new Error("lines and pt are required arguments");
  }
  let closestPt = point([Infinity, Infinity], {
    dist: Infinity,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  });
  let length3 = 0;
  flattenEach(
    lines,
    function(line, _featureIndex, multiFeatureIndex) {
      const coords = getCoords(line);
      for (let i = 0; i < coords.length - 1; i++) {
        const start = point(coords[i]);
        start.properties.dist = distance(pt, start, options);
        const stop = point(coords[i + 1]);
        stop.properties.dist = distance(pt, stop, options);
        const sectionLength = distance(start, stop, options);
        const heightDistance = Math.max(
          start.properties.dist,
          stop.properties.dist
        );
        const direction = bearing(start, stop);
        const perpendicularPt1 = destination(
          pt,
          heightDistance,
          direction + 90,
          options
        );
        const perpendicularPt2 = destination(
          pt,
          heightDistance,
          direction - 90,
          options
        );
        const intersect4 = lineIntersect(
          lineString([
            perpendicularPt1.geometry.coordinates,
            perpendicularPt2.geometry.coordinates
          ]),
          lineString([start.geometry.coordinates, stop.geometry.coordinates])
        );
        let intersectPt;
        if (intersect4.features.length > 0 && intersect4.features[0]) {
          intersectPt = __spreadProps(__spreadValues({}, intersect4.features[0]), {
            properties: {
              dist: distance(pt, intersect4.features[0], options),
              multiFeatureIndex,
              location: length3 + distance(start, intersect4.features[0], options)
            }
          });
        }
        if (start.properties.dist < closestPt.properties.dist) {
          closestPt = __spreadProps(__spreadValues({}, start), {
            properties: __spreadProps(__spreadValues({}, start.properties), {
              index: i,
              multiFeatureIndex,
              location: length3
            })
          });
        }
        if (stop.properties.dist < closestPt.properties.dist) {
          closestPt = __spreadProps(__spreadValues({}, stop), {
            properties: __spreadProps(__spreadValues({}, stop.properties), {
              index: i + 1,
              multiFeatureIndex,
              location: length3 + sectionLength
            })
          });
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
          closestPt = __spreadProps(__spreadValues({}, intersectPt), {
            properties: __spreadProps(__spreadValues({}, intersectPt.properties), { index: i })
          });
        }
        length3 += sectionLength;
      }
    }
  );
  return closestPt;
}

// ../node_modules/.pnpm/@turf+line-overlap@7.1.0/node_modules/@turf/line-overlap/dist/esm/index.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function lineOverlap(line1, line2, options = {}) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var tolerance = options.tolerance || 0;
  var features = [];
  var tree = geojsonRbush();
  const line = lineSegment(line1);
  tree.load(line);
  var overlapSegment;
  let additionalSegments = [];
  segmentEach(line2, function(segment) {
    var doesOverlaps = false;
    if (!segment) {
      return;
    }
    featureEach(tree.search(segment), function(match) {
      if (doesOverlaps === false) {
        var coordsSegment = getCoords(segment).sort();
        var coordsMatch = getCoords(match).sort();
        if ((0, import_fast_deep_equal.default)(coordsSegment, coordsMatch)) {
          doesOverlaps = true;
          if (overlapSegment) {
            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
          } else
            overlapSegment = segment;
        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {
          doesOverlaps = true;
          if (overlapSegment) {
            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
          } else
            overlapSegment = segment;
        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {
          if (overlapSegment) {
            const combinedSegment = concatSegment(overlapSegment, match);
            if (combinedSegment) {
              overlapSegment = combinedSegment;
            } else {
              additionalSegments.push(match);
            }
          } else
            overlapSegment = match;
        }
      }
    });
    if (doesOverlaps === false && overlapSegment) {
      features.push(overlapSegment);
      if (additionalSegments.length) {
        features = features.concat(additionalSegments);
        additionalSegments = [];
      }
      overlapSegment = void 0;
    }
  });
  if (overlapSegment)
    features.push(overlapSegment);
  return featureCollection(features);
}
function concatSegment(line, segment) {
  var coords = getCoords(segment);
  var lineCoords = getCoords(line);
  var start = lineCoords[0];
  var end = lineCoords[lineCoords.length - 1];
  var geom = line.geometry.coordinates;
  if ((0, import_fast_deep_equal.default)(coords[0], start))
    geom.unshift(coords[1]);
  else if ((0, import_fast_deep_equal.default)(coords[0], end))
    geom.push(coords[1]);
  else if ((0, import_fast_deep_equal.default)(coords[1], start))
    geom.unshift(coords[0]);
  else if ((0, import_fast_deep_equal.default)(coords[1], end))
    geom.push(coords[0]);
  else
    return;
  return line;
}

// ../node_modules/.pnpm/@turf+boolean-overlap@7.1.0/node_modules/@turf/boolean-overlap/dist/esm/index.js
function booleanOverlap(feature1, feature2) {
  const geom1 = getGeom(feature1);
  const geom2 = getGeom(feature2);
  const type1 = geom1.type;
  const type2 = geom2.type;
  if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
    throw new Error("features must be of the same type");
  }
  if (type1 === "Point")
    throw new Error("Point geometry not supported");
  if (geojsonEquality(feature1, feature2, { precision: 6 }))
    return false;
  let overlap = 0;
  switch (type1) {
    case "MultiPoint":
      for (var i = 0; i < geom1.coordinates.length; i++) {
        for (var j = 0; j < geom2.coordinates.length; j++) {
          var coord1 = geom1.coordinates[i];
          var coord2 = geom2.coordinates[j];
          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
            return true;
          }
        }
      }
      return false;
    case "LineString":
    case "MultiLineString":
      segmentEach(feature1, (segment1) => {
        segmentEach(feature2, (segment2) => {
          if (lineOverlap(segment1, segment2).features.length)
            overlap++;
        });
      });
      break;
    case "Polygon":
    case "MultiPolygon":
      segmentEach(feature1, (segment1) => {
        segmentEach(feature2, (segment2) => {
          if (lineIntersect(segment1, segment2).features.length)
            overlap++;
        });
      });
      break;
  }
  return overlap > 0;
}

// ../node_modules/.pnpm/@turf+boolean-parallel@7.1.0/node_modules/@turf/boolean-parallel/dist/esm/index.js
function booleanParallel(line1, line2) {
  if (!line1)
    throw new Error("line1 is required");
  if (!line2)
    throw new Error("line2 is required");
  var type1 = getType2(line1, "line1");
  if (type1 !== "LineString")
    throw new Error("line1 must be a LineString");
  var type2 = getType2(line2, "line2");
  if (type2 !== "LineString")
    throw new Error("line2 must be a LineString");
  var segments1 = lineSegment(cleanCoords(line1)).features;
  var segments2 = lineSegment(cleanCoords(line2)).features;
  for (var i = 0; i < segments1.length; i++) {
    var segment1 = segments1[i].geometry.coordinates;
    if (!segments2[i])
      break;
    var segment2 = segments2[i].geometry.coordinates;
    if (!isParallel(segment1, segment2))
      return false;
  }
  return true;
}
function isParallel(segment1, segment2) {
  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));
  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));
  return slope1 === slope2 || (slope2 - slope1) % 180 === 0;
}
function getType2(geojson, name) {
  if (geojson.geometry && geojson.geometry.type)
    return geojson.geometry.type;
  if (geojson.type)
    return geojson.type;
  throw new Error("Invalid GeoJSON object for " + name);
}

// ../node_modules/.pnpm/@turf+boolean-touches@7.1.0/node_modules/@turf/boolean-touches/dist/esm/index.js
function booleanTouches(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "LineString":
          return isPointOnLineEnd(geom1, geom2);
        case "MultiLineString":
          var foundTouchingPoint = false;
          for (var ii = 0; ii < geom2.coordinates.length; ii++) {
            if (isPointOnLineEnd(geom1, {
              type: "LineString",
              coordinates: geom2.coordinates[ii]
            }))
              foundTouchingPoint = true;
          }
          return foundTouchingPoint;
        case "Polygon":
          for (var i = 0; i < geom2.coordinates.length; i++) {
            if (booleanPointOnLine(geom1, {
              type: "LineString",
              coordinates: geom2.coordinates[i]
            }))
              return true;
          }
          return false;
        case "MultiPolygon":
          for (var i = 0; i < geom2.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates[i].length; ii++) {
              if (booleanPointOnLine(geom1, {
                type: "LineString",
                coordinates: geom2.coordinates[i][ii]
              }))
                return true;
            }
          }
          return false;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "LineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (isPointOnLineEnd(
                { type: "Point", coordinates: geom1.coordinates[i] },
                geom2
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointOnLine(
              { type: "Point", coordinates: geom1.coordinates[i] },
              geom2,
              { ignoreEndVertices: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "MultiLineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (isPointOnLineEnd(
                  { type: "Point", coordinates: geom1.coordinates[i] },
                  { type: "LineString", coordinates: geom2.coordinates[ii] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom1.coordinates[i] },
                { type: "LineString", coordinates: geom2.coordinates[ii] },
                { ignoreEndVertices: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "Polygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom1.coordinates[i] },
                { type: "LineString", coordinates: geom2.coordinates[0] }
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom1.coordinates[i] },
              geom2,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "MultiPolygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[i] },
                  {
                    type: "LineString",
                    coordinates: geom2.coordinates[ii][0]
                  }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom1.coordinates[i] },
                { type: "Polygon", coordinates: geom2.coordinates[ii] },
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "Point":
          return isPointOnLineEnd(geom2, geom1);
        case "MultiPoint":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (isPointOnLineEnd(
                { type: "Point", coordinates: geom2.coordinates[i] },
                geom1
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointOnLine(
              { type: "Point", coordinates: geom2.coordinates[i] },
              geom1,
              { ignoreEndVertices: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "LineString":
          var endMatch = false;
          if (isPointOnLineEnd(
            { type: "Point", coordinates: geom1.coordinates[0] },
            geom2
          ))
            endMatch = true;
          if (isPointOnLineEnd(
            {
              type: "Point",
              coordinates: geom1.coordinates[geom1.coordinates.length - 1]
            },
            geom2
          ))
            endMatch = true;
          if (endMatch === false)
            return false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (booleanPointOnLine(
              { type: "Point", coordinates: geom1.coordinates[i] },
              geom2,
              { ignoreEndVertices: true }
            ))
              return false;
          }
          return endMatch;
        case "MultiLineString":
          var endMatch = false;
          for (var i = 0; i < geom2.coordinates.length; i++) {
            if (isPointOnLineEnd(
              { type: "Point", coordinates: geom1.coordinates[0] },
              { type: "LineString", coordinates: geom2.coordinates[i] }
            ))
              endMatch = true;
            if (isPointOnLineEnd(
              {
                type: "Point",
                coordinates: geom1.coordinates[geom1.coordinates.length - 1]
              },
              { type: "LineString", coordinates: geom2.coordinates[i] }
            ))
              endMatch = true;
            for (var ii = 0; ii < geom1.coordinates[i].length; ii++) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom1.coordinates[ii] },
                { type: "LineString", coordinates: geom2.coordinates[i] },
                { ignoreEndVertices: true }
              ))
                return false;
            }
          }
          return endMatch;
        case "Polygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom1.coordinates[i] },
                { type: "LineString", coordinates: geom2.coordinates[0] }
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom1.coordinates[i] },
              geom2,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "MultiPolygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[i] },
                  {
                    type: "LineString",
                    coordinates: geom2.coordinates[ii][0]
                  }
                ))
                  foundTouchingPoint = true;
              }
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom1.coordinates[i] },
              geom2,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiLineString":
      switch (type2) {
        case "Point":
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (isPointOnLineEnd(geom2, {
              type: "LineString",
              coordinates: geom1.coordinates[i]
            }))
              return true;
          }
          return false;
        case "MultiPoint":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (isPointOnLineEnd(
                  { type: "Point", coordinates: geom2.coordinates[ii] },
                  { type: "LineString", coordinates: geom1.coordinates[ii] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom2.coordinates[ii] },
                { type: "LineString", coordinates: geom1.coordinates[ii] },
                { ignoreEndVertices: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "LineString":
          var endMatch = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (isPointOnLineEnd(
              { type: "Point", coordinates: geom1.coordinates[i][0] },
              geom2
            ))
              endMatch = true;
            if (isPointOnLineEnd(
              {
                type: "Point",
                coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
              },
              geom2
            ))
              endMatch = true;
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom2.coordinates[ii] },
                { type: "LineString", coordinates: geom1.coordinates[i] },
                { ignoreEndVertices: true }
              ))
                return false;
            }
          }
          return endMatch;
        case "MultiLineString":
          var endMatch = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (isPointOnLineEnd(
                { type: "Point", coordinates: geom1.coordinates[i][0] },
                { type: "LineString", coordinates: geom2.coordinates[ii] }
              ))
                endMatch = true;
              if (isPointOnLineEnd(
                {
                  type: "Point",
                  coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
                },
                { type: "LineString", coordinates: geom2.coordinates[ii] }
              ))
                endMatch = true;
              for (var iii = 0; iii < geom1.coordinates[i].length; iii++) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[i][iii] },
                  { type: "LineString", coordinates: geom2.coordinates[ii] },
                  { ignoreEndVertices: true }
                ))
                  return false;
              }
            }
          }
          return endMatch;
        case "Polygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom1.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[i][ii] },
                  { type: "LineString", coordinates: geom2.coordinates[0] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom1.coordinates[i][ii] },
                geom2,
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "MultiPolygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom1.coordinates.length; ii++) {
              for (var iii = 0; iii < geom1.coordinates[ii].length; iii++) {
                if (!foundTouchingPoint) {
                  if (booleanPointOnLine(
                    {
                      type: "Point",
                      coordinates: geom1.coordinates[ii][iii]
                    },
                    {
                      type: "LineString",
                      coordinates: geom2.coordinates[0][i]
                    }
                  ))
                    foundTouchingPoint = true;
                }
                if (booleanPointInPolygon(
                  { type: "Point", coordinates: geom1.coordinates[ii][iii] },
                  { type: "Polygon", coordinates: [geom2.coordinates[0][i]] },
                  { ignoreBoundary: true }
                ))
                  return false;
              }
            }
          }
          return foundTouchingPoint;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Point":
          for (var i = 0; i < geom1.coordinates.length; i++) {
            if (booleanPointOnLine(geom2, {
              type: "LineString",
              coordinates: geom1.coordinates[i]
            }))
              return true;
          }
          return false;
        case "MultiPoint":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom2.coordinates[i] },
                { type: "LineString", coordinates: geom1.coordinates[0] }
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom2.coordinates[i] },
              geom1,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "LineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates.length; i++) {
            if (!foundTouchingPoint) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom2.coordinates[i] },
                { type: "LineString", coordinates: geom1.coordinates[0] }
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom2.coordinates[i] },
              geom1,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "MultiLineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates[i].length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom2.coordinates[i][ii] },
                  { type: "LineString", coordinates: geom1.coordinates[0] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom2.coordinates[i][ii] },
                geom1,
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "Polygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            if (!foundTouchingPoint) {
              if (booleanPointOnLine(
                { type: "Point", coordinates: geom1.coordinates[0][i] },
                { type: "LineString", coordinates: geom2.coordinates[0] }
              ))
                foundTouchingPoint = true;
            }
            if (booleanPointInPolygon(
              { type: "Point", coordinates: geom1.coordinates[0][i] },
              geom2,
              { ignoreBoundary: true }
            ))
              return false;
          }
          return foundTouchingPoint;
        case "MultiPolygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom2.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom1.coordinates[0].length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[0][ii] },
                  { type: "LineString", coordinates: geom2.coordinates[0][i] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom1.coordinates[0][ii] },
                { type: "Polygon", coordinates: geom2.coordinates[0][i] },
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPolygon":
      switch (type2) {
        case "Point":
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            if (booleanPointOnLine(geom2, {
              type: "LineString",
              coordinates: geom1.coordinates[0][i]
            }))
              return true;
          }
          return false;
        case "MultiPoint":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom2.coordinates[ii] },
                  { type: "LineString", coordinates: geom1.coordinates[0][i] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom2.coordinates[ii] },
                { type: "Polygon", coordinates: geom1.coordinates[0][i] },
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "LineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom2.coordinates[ii] },
                  { type: "LineString", coordinates: geom1.coordinates[0][i] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom2.coordinates[ii] },
                { type: "Polygon", coordinates: geom1.coordinates[0][i] },
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "MultiLineString":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var ii = 0; ii < geom2.coordinates.length; ii++) {
              for (var iii = 0; iii < geom2.coordinates[ii].length; iii++) {
                if (!foundTouchingPoint) {
                  if (booleanPointOnLine(
                    {
                      type: "Point",
                      coordinates: geom2.coordinates[ii][iii]
                    },
                    {
                      type: "LineString",
                      coordinates: geom1.coordinates[i][0]
                    }
                  ))
                    foundTouchingPoint = true;
                }
                if (booleanPointInPolygon(
                  { type: "Point", coordinates: geom2.coordinates[ii][iii] },
                  { type: "Polygon", coordinates: [geom1.coordinates[i][0]] },
                  { ignoreBoundary: true }
                ))
                  return false;
              }
            }
          }
          return foundTouchingPoint;
        case "Polygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom1.coordinates[0][i].length; ii++) {
              if (!foundTouchingPoint) {
                if (booleanPointOnLine(
                  { type: "Point", coordinates: geom1.coordinates[0][i][ii] },
                  { type: "LineString", coordinates: geom2.coordinates[0] }
                ))
                  foundTouchingPoint = true;
              }
              if (booleanPointInPolygon(
                { type: "Point", coordinates: geom1.coordinates[0][i][ii] },
                geom2,
                { ignoreBoundary: true }
              ))
                return false;
            }
          }
          return foundTouchingPoint;
        case "MultiPolygon":
          var foundTouchingPoint = false;
          for (var i = 0; i < geom1.coordinates[0].length; i++) {
            for (var ii = 0; ii < geom2.coordinates[0].length; ii++) {
              for (var iii = 0; iii < geom1.coordinates[0].length; iii++) {
                if (!foundTouchingPoint) {
                  if (booleanPointOnLine(
                    {
                      type: "Point",
                      coordinates: geom1.coordinates[0][i][iii]
                    },
                    {
                      type: "LineString",
                      coordinates: geom2.coordinates[0][ii]
                    }
                  ))
                    foundTouchingPoint = true;
                }
                if (booleanPointInPolygon(
                  {
                    type: "Point",
                    coordinates: geom1.coordinates[0][i][iii]
                  },
                  { type: "Polygon", coordinates: geom2.coordinates[0][ii] },
                  { ignoreBoundary: true }
                ))
                  return false;
              }
            }
          }
          return foundTouchingPoint;
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointOnLineEnd(point2, line) {
  if (compareCoords3(line.coordinates[0], point2.coordinates))
    return true;
  if (compareCoords3(
    line.coordinates[line.coordinates.length - 1],
    point2.coordinates
  ))
    return true;
  return false;
}
function compareCoords3(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}

// ../node_modules/.pnpm/@turf+boolean-valid@7.1.0/node_modules/@turf/boolean-valid/dist/esm/index.js
function booleanValid(feature2) {
  if (!feature2.type)
    return false;
  const geom = getGeom(feature2);
  const type = geom.type;
  const coords = geom.coordinates;
  switch (type) {
    case "Point":
      return coords.length > 1;
    case "MultiPoint":
      for (var i = 0; i < coords.length; i++) {
        if (coords[i].length < 2)
          return false;
      }
      return true;
    case "LineString":
      if (coords.length < 2)
        return false;
      for (var i = 0; i < coords.length; i++) {
        if (coords[i].length < 2)
          return false;
      }
      return true;
    case "MultiLineString":
      if (coords.length < 2)
        return false;
      for (var i = 0; i < coords.length; i++) {
        if (coords[i].length < 2)
          return false;
      }
      return true;
    case "Polygon":
      for (var i = 0; i < geom.coordinates.length; i++) {
        if (coords[i].length < 4)
          return false;
        if (!checkRingsClose(coords[i]))
          return false;
        if (checkRingsForSpikesPunctures(coords[i]))
          return false;
        if (i > 0) {
          if (lineIntersect(polygon([coords[0]]), polygon([coords[i]])).features.length > 1)
            return false;
        }
      }
      return true;
    case "MultiPolygon":
      for (var i = 0; i < geom.coordinates.length; i++) {
        var poly = geom.coordinates[i];
        for (var ii = 0; ii < poly.length; ii++) {
          if (poly[ii].length < 4)
            return false;
          if (!checkRingsClose(poly[ii]))
            return false;
          if (checkRingsForSpikesPunctures(poly[ii]))
            return false;
          if (ii === 0) {
            if (!checkPolygonAgainstOthers(poly, geom.coordinates, i))
              return false;
          }
          if (ii > 0) {
            if (lineIntersect(polygon([poly[0]]), polygon([poly[ii]])).features.length > 1)
              return false;
          }
        }
      }
      return true;
    default:
      return false;
  }
}
function checkRingsClose(geom) {
  return geom[0][0] === geom[geom.length - 1][0] && geom[0][1] === geom[geom.length - 1][1];
}
function checkRingsForSpikesPunctures(geom) {
  for (var i = 0; i < geom.length - 1; i++) {
    var point2 = geom[i];
    for (var ii = i + 1; ii < geom.length - 2; ii++) {
      var seg = [geom[ii], geom[ii + 1]];
      if (booleanPointOnLine(point2, lineString(seg)))
        return true;
    }
  }
  return false;
}
function checkPolygonAgainstOthers(poly, geom, index2) {
  var polyToCheck = polygon(poly);
  for (var i = index2 + 1; i < geom.length; i++) {
    if (!booleanDisjoint(polyToCheck, polygon(geom[i]))) {
      if (booleanCrosses(polyToCheck, lineString(geom[i][0])))
        return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/@turf+boolean-within@7.1.0/node_modules/@turf/boolean-within/dist/esm/index.js
function booleanWithin(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "MultiPoint":
          return isPointInMultiPoint2(geom1, geom2);
        case "LineString":
          return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });
        case "Polygon":
        case "MultiPolygon":
          return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "MultiPoint":
          return isMultiPointInMultiPoint2(geom1, geom2);
        case "LineString":
          return isMultiPointOnLine2(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isMultiPointInPoly2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "LineString":
          return isLineOnLine3(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isLineInPoly3(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Polygon":
        case "MultiPolygon":
          return isPolyInPoly3(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint2(point2, multiPoint2) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords4(multiPoint2.coordinates[i], point2.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint2(multiPoint1, multiPoint2) {
  for (var i = 0; i < multiPoint1.coordinates.length; i++) {
    var anyMatch = false;
    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
      if (compareCoords4(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
        anyMatch = true;
      }
    }
    if (!anyMatch) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine2(multiPoint2, lineString2) {
  var foundInsidePoint = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    if (!booleanPointOnLine(multiPoint2.coordinates[i], lineString2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointOnLine(
        multiPoint2.coordinates[i],
        lineString2,
        { ignoreEndVertices: true }
      );
    }
  }
  return foundInsidePoint;
}
function isMultiPointInPoly2(multiPoint2, polygon2) {
  var output = true;
  var oneInside = false;
  var isInside3 = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    isInside3 = booleanPointInPolygon(multiPoint2.coordinates[i], polygon2);
    if (!isInside3) {
      output = false;
      break;
    }
    if (!oneInside) {
      isInside3 = booleanPointInPolygon(multiPoint2.coordinates[i], polygon2, {
        ignoreBoundary: true
      });
    }
  }
  return output && isInside3;
}
function isLineOnLine3(lineString1, lineString2) {
  for (var i = 0; i < lineString1.coordinates.length; i++) {
    if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {
      return false;
    }
  }
  return true;
}
function isLineInPoly3(linestring, polygon2) {
  var polyBbox = bbox(polygon2);
  var lineBbox = bbox(linestring);
  if (!doBBoxOverlap2(polyBbox, lineBbox)) {
    return false;
  }
  var foundInsidePoint = false;
  for (var i = 0; i < linestring.coordinates.length; i++) {
    if (!booleanPointInPolygon(linestring.coordinates[i], polygon2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointInPolygon(
        linestring.coordinates[i],
        polygon2,
        { ignoreBoundary: true }
      );
    }
    if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
      var midpoint2 = getMidpoint2(
        linestring.coordinates[i],
        linestring.coordinates[i + 1]
      );
      foundInsidePoint = booleanPointInPolygon(midpoint2, polygon2, {
        ignoreBoundary: true
      });
    }
  }
  return foundInsidePoint;
}
function isPolyInPoly3(geometry1, geometry2) {
  var poly1Bbox = bbox(geometry1);
  var poly2Bbox = bbox(geometry2);
  if (!doBBoxOverlap2(poly2Bbox, poly1Bbox)) {
    return false;
  }
  for (var i = 0; i < geometry1.coordinates[0].length; i++) {
    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
      return false;
    }
  }
  return true;
}
function doBBoxOverlap2(bbox1, bbox22) {
  if (bbox1[0] > bbox22[0])
    return false;
  if (bbox1[2] < bbox22[2])
    return false;
  if (bbox1[1] > bbox22[1])
    return false;
  if (bbox1[3] < bbox22[3])
    return false;
  return true;
}
function compareCoords4(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint2(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}

// ../node_modules/.pnpm/@turf+center@7.1.0/node_modules/@turf/center/dist/esm/index.js
function center(geojson, options = {}) {
  const ext = bbox(geojson);
  const x2 = (ext[0] + ext[2]) / 2;
  const y2 = (ext[1] + ext[3]) / 2;
  return point([x2, y2], options.properties, options);
}

// ../node_modules/.pnpm/@turf+buffer@7.1.0/node_modules/@turf/buffer/dist/esm/index.js
var import_jsts = __toESM(require_jsts_min());

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/adder.js
function adder_default() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(y2) {
    add(temp, y2, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder, a, b) {
  var x2 = adder.s = a + b, bv = x2 - a, av = x2 - bv;
  adder.t = a - av + (b - bv);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/math.js
var epsilon = 1e-6;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp = Math.exp;
var log = Math.log;
var sin = Math.sin;
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/noop.js
function noop() {
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/stream.js
function streamGeometry(geometry2, stream) {
  if (geometry2 && streamGeometryType.hasOwnProperty(geometry2.type)) {
    streamGeometryType[geometry2.type](geometry2, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object2 = coordinates[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/area.js
var areaRingSum = adder_default();
var areaSum = adder_default();

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/bounds.js
var deltaSum = adder_default();

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/compose.js
function compose_default(a, b) {
  function compose(x2, y2) {
    return x2 = a(x2, y2), b(x2[0], x2[1]);
  }
  if (a.invert && b.invert) compose.invert = function(x2, y2) {
    return x2 = b.invert(x2, y2), x2 && a.invert(x2[0], x2[1]);
  };
  return compose;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan2(y2 * cosDeltaGamma - k * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan2(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point2, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point2 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x2, y2) {
      line.push([x2, y2]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/line.js
function line_default(a, b, x02, y02, x12, y12) {
  var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/polygon.js
function Intersection(point2, points2, other, entry) {
  this.x = point2;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function polygon_default(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p0 = segment[0], p1 = segment[n2], x2;
    if (pointEqual_default(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n2; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point2;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i) stream.point((point2 = points2[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i = points2.length - 1; i >= 0; --i) stream.point((point2 = points2[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array2) {
  if (!(n = array2.length)) return;
  var n, i = 0, a = array2[0], b;
  while (++i < n) {
    a.n = b = array2[i];
    b.p = a;
    a = b;
  }
  a.n = b = array2[0];
  b.p = a;
}

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/bisector.js
function bisector_default(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x2, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x2, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x2) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x2) {
    return ascending_default(f(d), x2);
  };
}

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// ../node_modules/.pnpm/d3-array@1.2.4/node_modules/d3-array/src/merge.js
function merge_default(arrays) {
  var n = arrays.length, m, i = -1, j = 0, merged, array2;
  while (++i < n) j += arrays[i].length;
  merged = new Array(j);
  while (--n >= 0) {
    array2 = arrays[n];
    m = array2.length;
    while (--m >= 0) {
      merged[--j] = array2[m];
    }
  }
  return merged;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/extent.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipExtent(x02, y02, x12, y12) {
  function visible(x2, y2) {
    return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
  }
  function interpolate2(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a, b) {
    return comparePoint(a.x, b.x);
  }
  function comparePoint(a, b) {
    var ca3 = corner(a, 1), cb = corner(b, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a[1] : ca3 === 1 ? a[0] - b[0] : ca3 === 2 ? a[1] - b[1] : b[0] - a[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x2, y2) {
      if (visible(x2, y2)) activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon2.length; i < n; ++i) {
        for (var ring2 = polygon2[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon2 = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge_default(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          polygon_default(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon2 = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon2) polygon2.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x2, y2) {
      var v2 = visible(x2, y2);
      if (polygon2) ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v2 && v_) activeStream.point(x2, y2);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (line_default(a, b, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v2;
    }
    return clipStream;
  };
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/polygonContains.js
var sum = adder_default();
function polygonContains_default(polygon2, point2) {
  var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
  sum.reset();
  for (var i = 0, n = polygon2.length; i < n; ++i) {
    if (!(m = (ring = polygon2[i]).length)) continue;
    var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
      sum.add(atan2(k * sign3 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection3 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection3);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection3[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/length.js
var lengthSum = adder_default();

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/identity.js
function identity_default2(x2) {
  return x2;
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/path/area.js
var areaSum2 = adder_default();
var areaRingSum2 = adder_default();

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/path/bounds.js
var x0 = Infinity;
var y0 = x0;
var x1 = -x0;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x0) x0 = x2;
  if (x2 > x1) x1 = x2;
  if (y2 < y0) y0 = y2;
  if (y2 > y1) y1 = y2;
}
var bounds_default = boundsStream;

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/path/measure.js
var lengthSum2 = adder_default();

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x2, ",", y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x2, ",", y2);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x2, ",", y2, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(rotate, sink) {
    var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
    var clip = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon2 = [];
      },
      polygonEnd: function() {
        clip.point = point2;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge_default(segments);
        var startInside = polygonContains_default(polygon2, rotatedStart);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          polygon_default(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon2 = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi) {
      var point3 = rotate(lambda, phi);
      if (pointVisible(lambda = point3[0], phi = point3[1])) sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      var point3 = rotate(lambda, phi);
      line.point(point3[0], point3[1]);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point2;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point3 = rotate(lambda, phi);
      ringSink.point(point3[0], point3[1]);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon2.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) {
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon;
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/clip/circle.js
function circle_default(radius, delta) {
  var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
  function interpolate2(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point2, v2 = visible(lambda, phi), c = smallRadius ? v2 ? 0 : code(lambda, phi) : v2 ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point2 = intersect4(point0, point1);
          if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v2 = visible(point1[0], point1[1]);
          }
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point2 = intersect4(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect4(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t;
          if (!(c & c0) && (t = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a, b, two) {
    var pa = cartesian(a), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B3 = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B3);
    var u4 = n1xn2, w = cartesianDot(A, u4), uu = cartesianDot(u4, u4), t2 = w * w - uu * (cartesianDot(A, A) - 1);
    if (t2 < 0) return;
    var t = sqrt(t2), q = cartesianScale(u4, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u4, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi < -r) code2 |= 4;
    else if (phi > r) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s = new TransformStream();
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/fit.js
function fitExtent(projection2, extent, object2) {
  var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default));
  var b = bounds_default.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y2 = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
  if (clip != null) projection2.clipExtent(clip);
  return projection2.scale(k * 150).translate([x2, y2]);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x2, y2) {
      x2 = project(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x02, y02, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, lambda0, x02, y02, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x2, y2) {
      x2 = project(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x02 = p[0], y02 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x02, y02);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x02, y00 = y02, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k = 150, x2 = 480, y2 = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, theta = null, preclip = antimeridian_default, x02 = null, y02, x12, y12, postclip = identity_default2, delta2 = 0.5, projectResample = resample_default(projectTransform, delta2), cache, cacheStream;
  function projection2(point2) {
    point2 = projectRotate(point2[0] * radians, point2[1] * radians);
    return [point2[0] * k + dx, dy - point2[1] * k];
  }
  function invert(point2) {
    point2 = projectRotate.invert((point2[0] - dx) / k, (dy - point2[1]) / k);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  function projectTransform(x3, y3) {
    return x3 = project(x3, y3), [x3[0] * k + dx, dy - x3[1] * k];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default(theta = _ * radians, 6 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity_default2) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };
  projection2.fitExtent = function(extent, object2) {
    return fitExtent(projection2, extent, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  function recenter() {
    projectRotate = compose_default(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center2 = project(lambda, phi);
    dx = x2 - center2[0] * k;
    dy = y2 + center2[1] * k;
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale3) {
  return function(x2, y2) {
    var cx = cos(x2), cy = cos(y2), k = scale3(cx * cy);
    return [
      k * cy * sin(x2),
      k * sin(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z = sqrt(x2 * x2 + y2 * y2), c = angle2(z), sc = sin(c), cc2 = cos(c);
    return [
      atan2(x2 * sc, z * cc2),
      asin(z && y2 * sc / z)
    ];
  };
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi];
};

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x2, y2) {
  var cy = cos(y2), k = cos(x2) * cy;
  return [cy * sin(x2) / k, sin(y2) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi = y2, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
    phi
  ];
};

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x2, y2) {
  return [cos(y2) * sin(x2), sin(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin);

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x2, y2) {
  var cy = cos(y2), k = 1 + cos(x2) * cy;
  return [cy * sin(x2) / k, sin(y2) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

// ../node_modules/.pnpm/d3-geo@1.7.1/node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi];
};

// ../node_modules/.pnpm/@turf+buffer@7.1.0/node_modules/@turf/buffer/dist/esm/index.js
var { BufferOp, GeoJSONReader, GeoJSONWriter } = import_jsts.default;
function buffer(geojson, radius, options) {
  options = options || {};
  var units = options.units || "kilometers";
  var steps = options.steps || 8;
  if (!geojson)
    throw new Error("geojson is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (typeof steps !== "number")
    throw new Error("steps must be an number");
  if (radius === void 0)
    throw new Error("radius is required");
  if (steps <= 0)
    throw new Error("steps must be greater than 0");
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        var buffered = bufferFeature(geometry2, radius, units, steps);
        if (buffered)
          results.push(buffered);
      });
      return featureCollection(results);
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        var multiBuffered = bufferFeature(feature2, radius, units, steps);
        if (multiBuffered) {
          featureEach(multiBuffered, function(buffered) {
            if (buffered)
              results.push(buffered);
          });
        }
      });
      return featureCollection(results);
  }
  return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry2 = geojson.type === "Feature" ? geojson.geometry : geojson;
  if (geometry2.type === "GeometryCollection") {
    var results = [];
    geomEach(geojson, function(geometry22) {
      var buffered2 = bufferFeature(geometry22, radius, units, steps);
      if (buffered2)
        results.push(buffered2);
    });
    return featureCollection(results);
  }
  var projection2 = defineProjection(geometry2);
  var projected = {
    type: geometry2.type,
    coordinates: projectCoords(geometry2.coordinates, projection2)
  };
  var reader = new GeoJSONReader();
  var geom = reader.read(projected);
  var distance2 = radiansToLength(lengthToRadians(radius, units), "meters");
  var buffered = BufferOp.bufferOp(geom, distance2, steps);
  var writer = new GeoJSONWriter();
  buffered = writer.write(buffered);
  if (coordsIsNaN(buffered.coordinates))
    return void 0;
  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection2)
  };
  return feature(result, properties);
}
function coordsIsNaN(coords) {
  if (Array.isArray(coords[0]))
    return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj(coords);
  return coords.map(function(coord) {
    return projectCoords(coord, proj);
  });
}
function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj.invert(coords);
  return coords.map(function(coord) {
    return unprojectCoords(coord, proj);
  });
}
function defineProjection(geojson) {
  var coords = center(geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return azimuthalEquidistant_default().rotate(rotation).scale(earthRadius);
}

// ../node_modules/.pnpm/@turf+center-mean@7.1.0/node_modules/@turf/center-mean/dist/esm/index.js
function centerMean(geojson, options = {}) {
  let sumXs = 0;
  let sumYs = 0;
  let sumNs = 0;
  geomEach(geojson, function(geom, featureIndex, properties) {
    let weight = options.weight ? properties == null ? void 0 : properties[options.weight] : void 0;
    weight = weight === void 0 || weight === null ? 1 : weight;
    if (!isNumber(weight))
      throw new Error(
        "weight value must be a number for feature index " + featureIndex
      );
    weight = Number(weight);
    if (weight > 0) {
      coordEach(geom, function(coord) {
        sumXs += coord[0] * weight;
        sumYs += coord[1] * weight;
        sumNs += weight;
      });
    }
  });
  return point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
}

// ../node_modules/.pnpm/@turf+centroid@7.1.0/node_modules/@turf/centroid/dist/esm/index.js
function centroid(geojson, options = {}) {
  let xSum = 0;
  let ySum = 0;
  let len = 0;
  coordEach(
    geojson,
    function(coord) {
      xSum += coord[0];
      ySum += coord[1];
      len++;
    },
    true
  );
  return point([xSum / len, ySum / len], options.properties);
}

// ../node_modules/.pnpm/@turf+center-median@7.1.0/node_modules/@turf/center-median/dist/esm/index.js
function centerMedian(features, options = {}) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var counter = options.counter || 10;
  if (!isNumber(counter))
    throw new Error("counter must be a number");
  var weightTerm = options.weight;
  var meanCenter = centerMean(features, { weight: options.weight });
  var centroids = featureCollection([]);
  featureEach(features, function(feature2) {
    var _a;
    centroids.features.push(
      centroid(feature2, {
        properties: { weight: (_a = feature2.properties) == null ? void 0 : _a[weightTerm] }
      })
    );
  });
  const properties = {
    tolerance: options.tolerance,
    medianCandidates: []
  };
  return findMedian(
    meanCenter.geometry.coordinates,
    [0, 0],
    centroids,
    properties,
    counter
  );
}
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
  var tolerance = properties.tolerance || 1e-3;
  var candidateXsum = 0;
  var candidateYsum = 0;
  var kSum = 0;
  var centroidCount = 0;
  featureEach(centroids, function(theCentroid) {
    var _a;
    var weightValue = (_a = theCentroid.properties) == null ? void 0 : _a.weight;
    var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
    weight = Number(weight);
    if (!isNumber(weight))
      throw new Error("weight value must be a number");
    if (weight > 0) {
      centroidCount += 1;
      var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);
      if (distanceFromCandidate === 0)
        distanceFromCandidate = 1;
      var k = weight / distanceFromCandidate;
      candidateXsum += theCentroid.geometry.coordinates[0] * k;
      candidateYsum += theCentroid.geometry.coordinates[1] * k;
      kSum += k;
    }
  });
  if (centroidCount < 1)
    throw new Error("no features to measure");
  var candidateX = candidateXsum / kSum;
  var candidateY = candidateYsum / kSum;
  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
    return point([candidateX, candidateY], {
      medianCandidates: properties.medianCandidates
    });
  } else {
    properties.medianCandidates.push([candidateX, candidateY]);
    return findMedian(
      [candidateX, candidateY],
      candidateMedian,
      centroids,
      properties,
      counter - 1
    );
  }
}

// ../node_modules/.pnpm/@turf+convex@7.1.0/node_modules/@turf/convex/dist/esm/index.js
var import_concaveman = __toESM(require_concaveman());
function convex(geojson, options = {}) {
  options.concavity = options.concavity || Infinity;
  const points2 = [];
  coordEach(geojson, (coord) => {
    points2.push([coord[0], coord[1]]);
  });
  if (!points2.length) {
    return null;
  }
  const convexHull = (0, import_concaveman.default)(points2, options.concavity);
  if (convexHull.length > 3) {
    return polygon([convexHull]);
  }
  return null;
}

// ../node_modules/.pnpm/@turf+center-of-mass@7.1.0/node_modules/@turf/center-of-mass/dist/esm/index.js
function centerOfMass(geojson, options = {}) {
  switch (getType(geojson)) {
    case "Point":
      return point(getCoord(geojson), options.properties);
    case "Polygon":
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      var centre = centroid(geojson, { properties: options.properties });
      var translation = centre.geometry.coordinates;
      var sx = 0;
      var sy = 0;
      var sArea = 0;
      var i, pi2, pj, xi, xj, yi, yj, a;
      var neutralizedPoints = coords.map(function(point2) {
        return [point2[0] - translation[0], point2[1] - translation[1]];
      });
      for (i = 0; i < coords.length - 1; i++) {
        pi2 = neutralizedPoints[i];
        xi = pi2[0];
        yi = pi2[1];
        pj = neutralizedPoints[i + 1];
        xj = pj[0];
        yj = pj[1];
        a = xi * yj - xj * yi;
        sArea += a;
        sx += (xi + xj) * a;
        sy += (yi + yj) * a;
      }
      if (sArea === 0) {
        return centre;
      } else {
        var area2 = sArea * 0.5;
        var areaFactor = 1 / (6 * area2);
        return point(
          [translation[0] + areaFactor * sx, translation[1] + areaFactor * sy],
          options.properties
        );
      }
    default:
      var hull = convex(geojson);
      if (hull)
        return centerOfMass(hull, { properties: options.properties });
      else
        return centroid(geojson, { properties: options.properties });
  }
}

// ../node_modules/.pnpm/@turf+circle@7.1.0/node_modules/@turf/circle/dist/esm/index.js
function circle2(center2, radius, options = {}) {
  const steps = options.steps || 64;
  const properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
  const coordinates = [];
  for (let i = 0; i < steps; i++) {
    coordinates.push(
      destination(center2, radius, i * -360 / steps, options).geometry.coordinates
    );
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}

// ../node_modules/.pnpm/@turf+clone@7.1.0/node_modules/@turf/clone/dist/esm/index.js
function clone(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  const cloned = { type: "Feature" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  if (geojson.geometry == null) {
    cloned.geometry = null;
  } else {
    cloned.geometry = cloneGeometry(geojson.geometry);
  }
  return cloned;
}
function cloneProperties(properties) {
  const cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach((key) => {
    const value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map((item) => {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  const cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map((feature2) => {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry2) {
  const geom = { type: geometry2.type };
  if (geometry2.bbox) {
    geom.bbox = geometry2.bbox;
  }
  if (geometry2.type === "GeometryCollection") {
    geom.geometries = geometry2.geometries.map((g) => {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry2.coordinates);
  return geom;
}
function deepSlice(coords) {
  const cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map((coord) => {
    return deepSlice(coord);
  });
}

// ../node_modules/.pnpm/@turf+clusters@7.1.0/node_modules/@turf/clusters/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  applyFilter: () => applyFilter,
  clusterEach: () => clusterEach,
  clusterReduce: () => clusterReduce,
  createBins: () => createBins,
  filterProperties: () => filterProperties,
  getCluster: () => getCluster,
  propertiesContainsFilter: () => propertiesContainsFilter
});
function getCluster(geojson, filter) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (filter === void 0 || filter === null)
    throw new Error("filter is required");
  var features = [];
  featureEach(geojson, function(feature2) {
    if (applyFilter(feature2.properties, filter))
      features.push(feature2);
  });
  return featureCollection(features);
}
function clusterEach(geojson, property, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (property === void 0 || property === null)
    throw new Error("property is required");
  var bins = createBins(geojson, property);
  var values = Object.keys(bins);
  for (var index2 = 0; index2 < values.length; index2++) {
    var value = values[index2];
    var bin = bins[value];
    var features = [];
    for (var i = 0; i < bin.length; i++) {
      features.push(geojson.features[bin[i]]);
    }
    callback(featureCollection(features), value, index2);
  }
}
function clusterReduce(geojson, property, callback, initialValue) {
  var previousValue = initialValue;
  clusterEach(
    geojson,
    property,
    function(cluster, clusterValue, currentIndex) {
      if (currentIndex === 0 && initialValue === void 0)
        previousValue = cluster;
      else
        previousValue = callback(
          previousValue,
          cluster,
          clusterValue,
          currentIndex
        );
    }
  );
  return previousValue;
}
function createBins(geojson, property) {
  var bins = {};
  featureEach(geojson, function(feature2, i) {
    var properties = feature2.properties || {};
    if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
      var value = properties[property];
      if (Object.prototype.hasOwnProperty.call(bins, value))
        bins[value].push(i);
      else
        bins[value] = [i];
    }
  });
  return bins;
}
function applyFilter(properties, filter) {
  if (properties === void 0)
    return false;
  var filterType = typeof filter;
  if (filterType === "number" || filterType === "string")
    return Object.prototype.hasOwnProperty.call(properties, filter);
  else if (Array.isArray(filter)) {
    for (var i = 0; i < filter.length; i++) {
      if (!applyFilter(properties, filter[i]))
        return false;
    }
    return true;
  } else {
    return propertiesContainsFilter(properties, filter);
  }
}
function propertiesContainsFilter(properties, filter) {
  var keys = Object.keys(filter);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (properties[key] !== filter[key])
      return false;
  }
  return true;
}
function filterProperties(properties, keys) {
  if (!keys)
    return {};
  if (!keys.length)
    return {};
  var newProperties = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (Object.prototype.hasOwnProperty.call(properties, key))
      newProperties[key] = properties[key];
  }
  return newProperties;
}

// ../node_modules/.pnpm/@turf+clusters-dbscan@7.1.0/node_modules/@turf/clusters-dbscan/dist/esm/index.js
var rbush = RBush;
function clustersDbscan(points2, maxDistance, options = {}) {
  if (options.mutate !== true)
    points2 = clone(points2);
  const minPoints = options.minPoints || 3;
  const latDistanceInDegrees = lengthToDegrees(maxDistance, options.units);
  var tree = new rbush(points2.features.length);
  var visited = points2.features.map((_) => false);
  var assigned = points2.features.map((_) => false);
  var isnoise = points2.features.map((_) => false);
  var clusterIds = points2.features.map((_) => -1);
  tree.load(
    points2.features.map((point2, index2) => {
      var [x2, y2] = point2.geometry.coordinates;
      return {
        minX: x2,
        minY: y2,
        maxX: x2,
        maxY: y2,
        index: index2
      };
    })
  );
  const regionQuery = (index2) => {
    const point2 = points2.features[index2];
    const [x2, y2] = point2.geometry.coordinates;
    const minY = Math.max(y2 - latDistanceInDegrees, -90);
    const maxY = Math.min(y2 + latDistanceInDegrees, 90);
    const lonDistanceInDegrees = function() {
      if (minY < 0 && maxY > 0) {
        return latDistanceInDegrees;
      }
      if (Math.abs(minY) < Math.abs(maxY)) {
        return latDistanceInDegrees / Math.cos(degreesToRadians(maxY));
      } else {
        return latDistanceInDegrees / Math.cos(degreesToRadians(minY));
      }
    }();
    const minX = Math.max(x2 - lonDistanceInDegrees, -360);
    const maxX = Math.min(x2 + lonDistanceInDegrees, 360);
    const bbox3 = { minX, minY, maxX, maxY };
    return tree.search(bbox3).filter(
      (neighbor) => {
        const neighborIndex = neighbor.index;
        const neighborPoint = points2.features[neighborIndex];
        const distanceInKm = distance(point2, neighborPoint, {
          units: "kilometers"
        });
        return distanceInKm <= maxDistance;
      }
    );
  };
  const expandCluster = (clusteredId, neighbors) => {
    for (var i = 0; i < neighbors.length; i++) {
      var neighbor = neighbors[i];
      const neighborIndex = neighbor.index;
      if (!visited[neighborIndex]) {
        visited[neighborIndex] = true;
        const nextNeighbors = regionQuery(neighborIndex);
        if (nextNeighbors.length >= minPoints) {
          neighbors.push(...nextNeighbors);
        }
      }
      if (!assigned[neighborIndex]) {
        assigned[neighborIndex] = true;
        clusterIds[neighborIndex] = clusteredId;
      }
    }
  };
  var nextClusteredId = 0;
  points2.features.forEach((_, index2) => {
    if (visited[index2])
      return;
    const neighbors = regionQuery(index2);
    if (neighbors.length >= minPoints) {
      const clusteredId = nextClusteredId;
      nextClusteredId++;
      visited[index2] = true;
      expandCluster(clusteredId, neighbors);
    } else {
      isnoise[index2] = true;
    }
  });
  points2.features.forEach((_, index2) => {
    var clusterPoint = points2.features[index2];
    if (!clusterPoint.properties) {
      clusterPoint.properties = {};
    }
    if (clusterIds[index2] >= 0) {
      clusterPoint.properties.dbscan = isnoise[index2] ? "edge" : "core";
      clusterPoint.properties.cluster = clusterIds[index2];
    } else {
      clusterPoint.properties.dbscan = "noise";
    }
  });
  return points2;
}

// ../node_modules/.pnpm/@turf+clusters-kmeans@7.1.0/node_modules/@turf/clusters-kmeans/dist/esm/index.js
var import_skmeans = __toESM(require_main());
function clustersKmeans(points2, options = {}) {
  var count = points2.features.length;
  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));
  if (options.numberOfClusters > count)
    options.numberOfClusters = count;
  if (options.mutate !== true)
    points2 = clone(points2);
  var data = coordAll(points2);
  var initialCentroids = data.slice(0, options.numberOfClusters);
  var skmeansResult = (0, import_skmeans.default)(data, options.numberOfClusters, initialCentroids);
  var centroids = {};
  skmeansResult.centroids.forEach(function(coord, idx) {
    centroids[idx] = coord;
  });
  featureEach(points2, function(point2, index2) {
    var clusterId = skmeansResult.idxs[index2];
    point2.properties.cluster = clusterId;
    point2.properties.centroid = centroids[clusterId];
  });
  return points2;
}

// ../node_modules/.pnpm/@turf+collect@7.1.0/node_modules/@turf/collect/dist/esm/index.js
var rbush2 = RBush;
function collect(polygons2, points2, inProperty, outProperty) {
  var rtree = new rbush2(6);
  var treeItems = points2.features.map(function(item) {
    var _a;
    return {
      minX: item.geometry.coordinates[0],
      minY: item.geometry.coordinates[1],
      maxX: item.geometry.coordinates[0],
      maxY: item.geometry.coordinates[1],
      property: (_a = item.properties) == null ? void 0 : _a[inProperty]
    };
  });
  rtree.load(treeItems);
  polygons2.features.forEach(function(poly) {
    if (!poly.properties) {
      poly.properties = {};
    }
    var bbox3 = bbox(poly);
    var potentialPoints = rtree.search({
      minX: bbox3[0],
      minY: bbox3[1],
      maxX: bbox3[2],
      maxY: bbox3[3]
    });
    var values = [];
    potentialPoints.forEach(function(pt) {
      if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {
        values.push(pt.property);
      }
    });
    poly.properties[outProperty] = values;
  });
  return polygons2;
}

// ../node_modules/.pnpm/@turf+combine@7.1.0/node_modules/@turf/combine/dist/esm/index.js
function combine(fc) {
  var groups = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  featureEach(fc, (feature2) => {
    var _a;
    switch ((_a = feature2.geometry) == null ? void 0 : _a.type) {
      case "Point":
        groups.MultiPoint.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "MultiPoint":
        groups.MultiPoint.coordinates.push(...feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "LineString":
        groups.MultiLineString.coordinates.push(feature2.geometry.coordinates);
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "MultiLineString":
        groups.MultiLineString.coordinates.push(
          ...feature2.geometry.coordinates
        );
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "Polygon":
        groups.MultiPolygon.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
      case "MultiPolygon":
        groups.MultiPolygon.coordinates.push(...feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
      default:
        break;
    }
  });
  return featureCollection(
    Object.keys(groups).filter(function(key) {
      return groups[key].coordinates.length;
    }).sort().map(function(key) {
      var geometry2 = { type: key, coordinates: groups[key].coordinates };
      var properties = { collectedProperties: groups[key].properties };
      return feature(geometry2, properties);
    })
  );
}

// ../node_modules/.pnpm/@turf+tin@7.1.0/node_modules/@turf/tin/dist/esm/index.js
function tin(points2, z) {
  let isPointZ = false;
  return featureCollection(
    triangulate(
      points2.features.map((p) => {
        const point2 = {
          x: p.geometry.coordinates[0],
          y: p.geometry.coordinates[1]
        };
        if (z) {
          point2.z = p.properties[z];
        } else if (p.geometry.coordinates.length === 3) {
          isPointZ = true;
          point2.z = p.geometry.coordinates[2];
        }
        return point2;
      })
    ).map((triangle) => {
      const a = [triangle.a.x, triangle.a.y];
      const b = [triangle.b.x, triangle.b.y];
      const c = [triangle.c.x, triangle.c.y];
      let properties = {};
      if (isPointZ) {
        a.push(triangle.a.z);
        b.push(triangle.b.z);
        c.push(triangle.c.z);
      } else {
        properties = {
          a: triangle.a.z,
          b: triangle.b.z,
          c: triangle.c.z
        };
      }
      return polygon([[a, b, c, a]], properties);
    })
  );
}
var Triangle = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
    const A = b.x - a.x;
    const B3 = b.y - a.y;
    const C = c.x - a.x;
    const D2 = c.y - a.y;
    const E = A * (a.x + b.x) + B3 * (a.y + b.y);
    const F = C * (a.x + c.x) + D2 * (a.y + c.y);
    const G = 2 * (A * (c.y - b.y) - B3 * (c.x - b.x));
    let dx;
    let dy;
    this.x = (D2 * E - B3 * F) / G;
    this.y = (A * F - C * E) / G;
    dx = this.x - a.x;
    dy = this.y - a.y;
    this.r = dx * dx + dy * dy;
  }
};
function byX(a, b) {
  return b.x - a.x;
}
function dedup(edges2) {
  let j = edges2.length;
  let a;
  let b;
  let i;
  let m;
  let n;
  outer:
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      i = j;
      while (i) {
        n = edges2[--i];
        m = edges2[--i];
        if (a === m && b === n || a === n && b === m) {
          edges2.splice(j, 2);
          edges2.splice(i, 2);
          j -= 2;
          continue outer;
        }
      }
    }
}
function triangulate(vertices) {
  if (vertices.length < 3) {
    return [];
  }
  vertices.sort(byX);
  let i = vertices.length - 1;
  const xmin = vertices[i].x;
  const xmax = vertices[0].x;
  let ymin = vertices[i].y;
  let ymax = ymin;
  const epsilon6 = 1e-12;
  let a;
  let b;
  let c;
  let A;
  let B3;
  let G;
  while (i--) {
    if (vertices[i].y < ymin) {
      ymin = vertices[i].y;
    }
    if (vertices[i].y > ymax) {
      ymax = vertices[i].y;
    }
  }
  let dx = xmax - xmin;
  let dy = ymax - ymin;
  const dmax = dx > dy ? dx : dy;
  const xmid = (xmax + xmin) * 0.5;
  const ymid = (ymax + ymin) * 0.5;
  const open = [
    new Triangle(
      {
        __sentinel: true,
        x: xmid - 20 * dmax,
        y: ymid - dmax
      },
      {
        __sentinel: true,
        x: xmid,
        y: ymid + 20 * dmax
      },
      {
        __sentinel: true,
        x: xmid + 20 * dmax,
        y: ymid - dmax
      }
    )
  ];
  const closed = [];
  const edges2 = [];
  let j;
  i = vertices.length;
  while (i--) {
    edges2.length = 0;
    j = open.length;
    while (j--) {
      dx = vertices[i].x - open[j].x;
      if (dx > 0 && dx * dx > open[j].r) {
        closed.push(open[j]);
        open.splice(j, 1);
        continue;
      }
      dy = vertices[i].y - open[j].y;
      if (dx * dx + dy * dy > open[j].r) {
        continue;
      }
      edges2.push(
        open[j].a,
        open[j].b,
        open[j].b,
        open[j].c,
        open[j].c,
        open[j].a
      );
      open.splice(j, 1);
    }
    dedup(edges2);
    j = edges2.length;
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      c = vertices[i];
      A = b.x - a.x;
      B3 = b.y - a.y;
      G = 2 * (A * (c.y - b.y) - B3 * (c.x - b.x));
      if (Math.abs(G) > epsilon6) {
        open.push(new Triangle(a, b, c));
      }
    }
  }
  Array.prototype.push.apply(closed, open);
  i = closed.length;
  while (i--) {
    if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
      closed.splice(i, 1);
    }
  }
  return closed;
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/identity.js
function identity_default4(x2) {
  return x2;
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/transform.js
function transform_default2(transform) {
  if (transform == null) return identity_default4;
  var x02, y02, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
  return function(input, i) {
    if (!i) x02 = y02 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x02 += input[0]) * kx + dx;
    output[1] = (y02 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/reverse.js
function reverse_default(array2, n) {
  var t, j = array2.length, i = j - n;
  while (i < --j) t = array2[i], array2[i++] = array2[j], array2[j] = t;
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/feature.js
function object(topology, o) {
  var transformPoint = transform_default2(topology.transform), arcs = topology.arcs;
  function arc(i, points2) {
    if (points2.length) points2.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points2.push(transformPoint(a[k], k));
    }
    if (i < 0) reverse_default(points2, n);
  }
  function point2(p) {
    return transformPoint(p);
  }
  function line(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i) arc(arcs2[i], points2);
    if (points2.length < 2) points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line(arcs2);
    while (points2.length < 4) points2.push(points2[0]);
    return points2;
  }
  function polygon2(arcs2) {
    return arcs2.map(ring);
  }
  function geometry2(o2) {
    var type = o2.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o2.geometries.map(geometry2) };
      case "Point":
        coordinates = point2(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point2);
        break;
      case "LineString":
        coordinates = line(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line);
        break;
      case "Polygon":
        coordinates = polygon2(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon2);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry2(o);
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
  });
  return fragments;
}

// ../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area2 = 0;
  while (++i < n) a = b, b = ring[i], area2 += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area2);
}
function merge_default2(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons2 = [], groups = [];
  objects.forEach(geometry2);
  function geometry2(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry2);
        break;
      case "Polygon":
        extract(o.arcs);
        break;
      case "MultiPolygon":
        o.arcs.forEach(extract);
        break;
    }
  }
  function extract(polygon2) {
    polygon2.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon2);
      });
    });
    polygons2.push(polygon2);
  }
  function area2(ring) {
    return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons2.forEach(function(polygon2) {
    if (!polygon2._) {
      var group = [], neighbors = [polygon2];
      polygon2._ = 1;
      groups.push(group);
      while (polygon2 = neighbors.pop()) {
        group.push(polygon2);
        polygon2.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon3) {
              if (!polygon3._) {
                polygon3._ = 1;
                neighbors.push(polygon3);
              }
            });
          });
        });
      }
    }
  });
  polygons2.forEach(function(polygon2) {
    delete polygon2._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons3) {
      var arcs = [], n;
      polygons3.forEach(function(polygon2) {
        polygon2.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default(topology, arcs);
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area2(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area2(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/object.js
var hasOwnProperty = Object.prototype.hasOwnProperty;

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/bounds.js
function bounds_default3(objects) {
  var x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
  function boundGeometry(geometry2) {
    if (geometry2 != null && hasOwnProperty.call(boundGeometryType, geometry2.type)) boundGeometryType[geometry2.type](geometry2);
  }
  var boundGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(boundGeometry);
    },
    Point: function(o) {
      boundPoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates.forEach(boundPoint);
    },
    LineString: function(o) {
      boundLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs.forEach(boundLine);
    },
    Polygon: function(o) {
      o.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o) {
      o.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    if (x2 < x02) x02 = x2;
    if (x2 > x12) x12 = x2;
    if (y2 < y02) y02 = y2;
    if (y2 > y12) y12 = y2;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key in objects) {
    boundGeometry(objects[key]);
  }
  return x12 >= x02 && y12 >= y02 ? [x02, y02, x12, y12] : void 0;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/hash/hashset.js
function hashset_default(size, hash, equal3, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask2 = size - 1;
  for (var i = 0; i < size; ++i) {
    store[i] = empty;
  }
  function add3(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal3(match, value)) return true;
      if (++collisions >= size) throw new Error("full hashset");
      match = store[index2 = index2 + 1 & mask2];
    }
    store[index2] = value;
    return true;
  }
  function has(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal3(match, value)) return true;
      if (++collisions >= size) break;
      match = store[index2 = index2 + 1 & mask2];
    }
    return false;
  }
  function values() {
    var values2 = [];
    for (var i2 = 0, n = store.length; i2 < n; ++i2) {
      var match = store[i2];
      if (match != empty) values2.push(match);
    }
    return values2;
  }
  return {
    add: add3,
    has,
    values
  };
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/hash/hashmap.js
function hashmap_default(size, hash, equal3, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask2 = size - 1;
  for (var i = 0; i < size; ++i) {
    keystore[i] = keyEmpty;
  }
  function set(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key)) return valstore[index2] = value;
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function maybeSet(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key)) return valstore[index2];
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function get(key, missingValue) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key)) return valstore[index2];
      if (++collisions >= size) break;
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    return missingValue;
  }
  function keys() {
    var keys2 = [];
    for (var i2 = 0, n = keystore.length; i2 < n; ++i2) {
      var matchKey = keystore[i2];
      if (matchKey != keyEmpty) keys2.push(matchKey);
    }
    return keys2;
  }
  return {
    set,
    maybeSet,
    // set if unset
    get,
    keys
  };
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/hash/point-equal.js
function point_equal_default(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/hash/point-hash.js
var buffer2 = new ArrayBuffer(16);
var floats = new Float64Array(buffer2);
var uints = new Uint32Array(buffer2);
function point_hash_default(point2) {
  floats[0] = point2[0];
  floats[1] = point2[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/join.js
function join_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index2(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
  }
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineStart = line[0], lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = -1;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i2, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i2) return;
    visitedByIndex[currentIndex2] = i2;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index2() {
    var indexByPoint = hashmap_default(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
      indexes2[i2] = indexByPoint.maybeSet(i2, i2);
    }
    return indexes2;
  }
  function hashIndex(i2) {
    return point_hash_default(coordinates[i2]);
  }
  function equalIndex(i2, j2) {
    return point_equal_default(coordinates[i2], coordinates[j2]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset_default(junctionCount * 1.4, point_hash_default, point_equal_default), j;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    if (junctionByIndex[j = indexes[i]]) {
      junctionByPoint.add(coordinates[j]);
    }
  }
  return junctionByPoint;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/cut.js
function cut_default(topology) {
  var junctions = join_default(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next, i, n;
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineMid = line[0], lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next = { 0: lineMid, 1: line[1] };
        line[1] = lineMid;
        line = line.next = next;
      }
    }
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology;
}
function rotateArray(array2, start, end, offset) {
  reverse(array2, start, end);
  reverse(array2, start, start + offset);
  reverse(array2, start + offset, end);
}
function reverse(array2, start, end) {
  for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {
    t = array2[start], array2[start] = array2[end], array2[end] = t;
  }
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/dedup.js
function dedup_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, line, rings = topology.rings, ring, arcCount = lines.length + rings.length, i, n;
  delete topology.lines;
  delete topology.rings;
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    while (line = line.next) ++arcCount;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    while (ring = ring.next) ++arcCount;
  }
  var arcsByEnd = hashmap_default(arcCount * 2 * 1.4, point_hash_default, point_equal_default), arcs = topology.arcs = [];
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    do {
      dedupLine(line);
    } while (line = line.next);
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i2, n2;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = startArcs.length; i2 < n2; ++i2) {
        startArc = startArcs[i2];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs) startArcs.push(arc);
    else arcsByEnd.set(startPoint, [arc]);
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i2, n2;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, ++ib) if (!point_equal_default(coordinates[ia], coordinates[ib])) return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, --jb) if (!point_equal_default(coordinates[ia], coordinates[jb])) return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[ib + (i2 + kb) % n2])) return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = n2 - findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[jb - (i2 + kb) % n2])) return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point2 = coordinates[mid];
      if (point2[0] < minimumPoint[0] || point2[0] === minimumPoint[0] && point2[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point2;
      }
    }
    return minimum - start;
  }
  return topology;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/delta.js
function delta_default(arcs) {
  var i = -1, n = arcs.length;
  while (++i < n) {
    var arc = arcs[i], j = 0, k = 1, m = arc.length, point2 = arc[0], x02 = point2[0], y02 = point2[1], x12, y12;
    while (++j < m) {
      point2 = arc[j], x12 = point2[0], y12 = point2[1];
      if (x12 !== x02 || y12 !== y02) arc[k++] = [x12 - x02, y12 - y02], x02 = x12, y02 = y12;
    }
    if (k === 1) arc[k++] = [0, 0];
    arc.length = k;
  }
  return arcs;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/extract.js
function extract_default(objects) {
  var index2 = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry(geometry2) {
    if (geometry2 && hasOwnProperty.call(extractGeometryType, geometry2.type)) extractGeometryType[geometry2.type](geometry2);
  }
  var extractGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(extractGeometry);
    },
    LineString: function(o) {
      o.arcs = extractLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(extractLine);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(extractRing);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line) {
    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index2] = line[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index2] = ring[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key in objects) {
    extractGeometry(objects[key]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/geometry.js
function geometry_default(inputs) {
  var outputs = {}, key;
  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key;
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  for (key in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null) return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/prequantize.js
function prequantize_default(objects, bbox3, n) {
  var x02 = bbox3[0], y02 = bbox3[1], x12 = bbox3[2], y12 = bbox3[3], kx = x12 - x02 ? (n - 1) / (x12 - x02) : 1, ky = y12 - y02 ? (n - 1) / (y12 - y02) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x02) * kx), Math.round((input[1] - y02) * ky)];
  }
  function quantizePoints(input, m) {
    var i = -1, j = 0, n2 = input.length, output = new Array(n2), pi2, px, py, x2, y2;
    while (++i < n2) {
      pi2 = input[i];
      x2 = Math.round((pi2[0] - x02) * kx);
      y2 = Math.round((pi2[1] - y02) * ky);
      if (x2 !== px || y2 !== py) output[j++] = [px = x2, py = y2];
    }
    output.length = j;
    while (j < m) j = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o) {
    if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(quantizeGeometry);
    },
    Point: function(o) {
      o.coordinates = quantizePoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates = o.coordinates.map(quantizePoint);
    },
    LineString: function(o) {
      o.arcs = quantizeLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(quantizeLine);
    },
    Polygon: function(o) {
      o.arcs = quantizePolygon(o.arcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(quantizePolygon);
    }
  };
  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }
  return {
    scale: [1 / kx, 1 / ky],
    translate: [x02, y02]
  };
}

// ../node_modules/.pnpm/topojson-server@3.0.1/node_modules/topojson-server/src/topology.js
function topology_default(objects, quantization) {
  var bbox3 = bounds_default3(objects = geometry_default(objects)), transform = quantization > 0 && bbox3 && prequantize_default(objects, bbox3, quantization), topology = dedup_default(cut_default(extract_default(objects))), coordinates = topology.coordinates, indexByArc = hashmap_default(topology.arcs.length * 1.4, hashArc, equalArc);
  objects = topology.objects;
  topology.bbox = bbox3;
  topology.arcs = topology.arcs.map(function(arc, i) {
    indexByArc.set(arc, i);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology.coordinates;
  coordinates = null;
  function indexGeometry(geometry2) {
    if (geometry2 && hasOwnProperty.call(indexGeometryType, geometry2.type)) indexGeometryType[geometry2.type](geometry2);
  }
  var indexGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(indexGeometry);
    },
    LineString: function(o) {
      o.arcs = indexArcs(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index2 = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index2 : ~index2);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key in objects) {
    indexGeometry(objects[key]);
  }
  if (transform) {
    topology.transform = transform;
    topology.arcs = delta_default(topology.arcs);
  }
  return topology;
}
function hashArc(arc) {
  var i = arc[0], j = arc[1], t;
  if (j < i) t = i, i = j, j = t;
  return i + 31 * j;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
  if (ja < ia) t = ia, ia = ja, ja = t;
  if (jb < ib) t = ib, ib = jb, jb = t;
  return ia === ib && ja === jb;
}

// ../node_modules/.pnpm/@turf+concave@7.1.0/node_modules/@turf/concave/dist/esm/index.js
function lineDissolve(geojson, options = {}) {
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  const mutate = options.mutate;
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = clone(geojson);
  }
  const result = [];
  const lastLine = lineReduce(
    geojson,
    (previousLine, currentLine) => {
      const merged = mergeLineStrings(previousLine, currentLine);
      if (merged) {
        return merged;
      } else {
        result.push(previousLine);
        return currentLine;
      }
    }
  );
  if (lastLine) {
    result.push(lastLine);
  }
  if (!result.length) {
    return null;
  } else if (result.length === 1) {
    return result[0];
  } else {
    return multiLineString(
      result.map((line) => {
        return line.coordinates;
      })
    );
  }
}
function coordId(coord) {
  return coord[0].toString() + "," + coord[1].toString();
}
function mergeLineStrings(a, b) {
  const coords1 = a.geometry.coordinates;
  const coords2 = b.geometry.coordinates;
  const s1 = coordId(coords1[0]);
  const e1 = coordId(coords1[coords1.length - 1]);
  const s2 = coordId(coords2[0]);
  const e22 = coordId(coords2[coords2.length - 1]);
  let coords;
  if (s1 === e22) {
    coords = coords2.concat(coords1.slice(1));
  } else if (s2 === e1) {
    coords = coords1.concat(coords2.slice(1));
  } else if (s1 === s2) {
    coords = coords1.slice(1).reverse().concat(coords2);
  } else if (e1 === e22) {
    coords = coords1.concat(coords2.reverse().slice(1));
  } else {
    return null;
  }
  return lineString(coords);
}
function polygonDissolve(geojson, options = {}) {
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (options.mutate === false || options.mutate === void 0) {
    geojson = clone(geojson);
  }
  const geoms = [];
  flattenEach(geojson, (feature2) => {
    geoms.push(feature2.geometry);
  });
  const topo = topology_default({ geoms: geometryCollection(geoms).geometry });
  const merged = merge_default2(topo, topo.objects.geoms.geometries);
  return merged;
}
function dissolve(geojson, options = {}) {
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  const mutate = options.mutate;
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = clone(geojson);
  }
  const type = getHomogenousType(geojson);
  if (!type) {
    throw new Error("geojson must be homogenous");
  }
  const data = geojson;
  switch (type) {
    case "LineString":
      return lineDissolve(data, options);
    case "Polygon":
      return polygonDissolve(data, options);
    default:
      throw new Error(type + " is not supported");
  }
}
function getHomogenousType(geojson) {
  const types = {};
  flattenEach(geojson, (feature2) => {
    types[feature2.geometry.type] = true;
  });
  const keys = Object.keys(types);
  if (keys.length === 1) {
    return keys[0];
  }
  return null;
}
function concave(points2, options = {}) {
  const maxEdge = options.maxEdge || Infinity;
  const cleaned = removeDuplicates(points2);
  const tinPolys = tin(cleaned);
  tinPolys.features = tinPolys.features.filter((triangle) => {
    const pt1 = triangle.geometry.coordinates[0][0];
    const pt2 = triangle.geometry.coordinates[0][1];
    const pt3 = triangle.geometry.coordinates[0][2];
    const dist1 = distance(pt1, pt2, options);
    const dist2 = distance(pt2, pt3, options);
    const dist3 = distance(pt1, pt3, options);
    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
  });
  if (tinPolys.features.length < 1) {
    return null;
  }
  const dissolved = dissolve(tinPolys);
  if (dissolved.coordinates.length === 1) {
    dissolved.coordinates = dissolved.coordinates[0];
    dissolved.type = "Polygon";
  }
  return feature(dissolved);
}
function removeDuplicates(points2) {
  const cleaned = [];
  const existing = {};
  featureEach(points2, (pt) => {
    if (!pt.geometry) {
      return;
    }
    const key = pt.geometry.coordinates.join("-");
    if (!Object.prototype.hasOwnProperty.call(existing, key)) {
      cleaned.push(pt);
      existing[key] = true;
    }
  });
  return featureCollection(cleaned);
}

// ../node_modules/.pnpm/splaytree@3.1.2/node_modules/splaytree/dist/splay.esm.js
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y2 = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var Node = (
  /** @class */
  /* @__PURE__ */ function() {
    function Node3(key, data) {
      this.next = null;
      this.key = key;
      this.data = data;
      this.left = null;
      this.right = null;
    }
    return Node3;
  }()
);
function DEFAULT_COMPARE(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function splay(i, t, comparator) {
  var N = new Node(null, null);
  var l = N;
  var r = N;
  while (true) {
    var cmp2 = comparator(i, t.key);
    if (cmp2 < 0) {
      if (t.left === null)
        break;
      if (comparator(i, t.left.key) < 0) {
        var y2 = t.left;
        t.left = y2.right;
        y2.right = t;
        t = y2;
        if (t.left === null)
          break;
      }
      r.left = t;
      r = t;
      t = t.left;
    } else if (cmp2 > 0) {
      if (t.right === null)
        break;
      if (comparator(i, t.right.key) > 0) {
        var y2 = t.right;
        t.right = y2.left;
        y2.left = t;
        t = y2;
        if (t.right === null)
          break;
      }
      l.right = t;
      l = t;
      t = t.right;
    } else
      break;
  }
  l.right = t.left;
  r.left = t.right;
  t.left = N.right;
  t.right = N.left;
  return t;
}
function insert(i, data, t, comparator) {
  var node = new Node(i, data);
  if (t === null) {
    node.left = node.right = null;
    return node;
  }
  t = splay(i, t, comparator);
  var cmp2 = comparator(i, t.key);
  if (cmp2 < 0) {
    node.left = t.left;
    node.right = t;
    t.left = null;
  } else if (cmp2 >= 0) {
    node.right = t.right;
    node.left = t;
    t.right = null;
  }
  return node;
}
function split(key, v2, comparator) {
  var left = null;
  var right = null;
  if (v2) {
    v2 = splay(key, v2, comparator);
    var cmp2 = comparator(v2.key, key);
    if (cmp2 === 0) {
      left = v2.left;
      right = v2.right;
    } else if (cmp2 < 0) {
      right = v2.right;
      v2.right = null;
      left = v2;
    } else {
      left = v2.left;
      v2.left = null;
      right = v2;
    }
  }
  return { left, right };
}
function merge(left, right, comparator) {
  if (right === null)
    return left;
  if (left === null)
    return right;
  right = splay(left.key, right, comparator);
  right.left = left;
  return right;
}
function printRow(root, prefix, isTail, out, printNode) {
  if (root) {
    out("" + prefix + (isTail ? "└── " : "├── ") + printNode(root) + "\n");
    var indent = prefix + (isTail ? "    " : "│   ");
    if (root.left)
      printRow(root.left, indent, false, out, printNode);
    if (root.right)
      printRow(root.right, indent, true, out, printNode);
  }
}
var Tree = (
  /** @class */
  function() {
    function Tree2(comparator) {
      if (comparator === void 0) {
        comparator = DEFAULT_COMPARE;
      }
      this._root = null;
      this._size = 0;
      this._comparator = comparator;
    }
    Tree2.prototype.insert = function(key, data) {
      this._size++;
      return this._root = insert(key, data, this._root, this._comparator);
    };
    Tree2.prototype.add = function(key, data) {
      var node = new Node(key, data);
      if (this._root === null) {
        node.left = node.right = null;
        this._size++;
        this._root = node;
      }
      var comparator = this._comparator;
      var t = splay(key, this._root, comparator);
      var cmp2 = comparator(key, t.key);
      if (cmp2 === 0)
        this._root = t;
      else {
        if (cmp2 < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp2 > 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }
        this._size++;
        this._root = node;
      }
      return this._root;
    };
    Tree2.prototype.remove = function(key) {
      this._root = this._remove(key, this._root, this._comparator);
    };
    Tree2.prototype._remove = function(i, t, comparator) {
      var x2;
      if (t === null)
        return null;
      t = splay(i, t, comparator);
      var cmp2 = comparator(i, t.key);
      if (cmp2 === 0) {
        if (t.left === null) {
          x2 = t.right;
        } else {
          x2 = splay(i, t.left, comparator);
          x2.right = t.right;
        }
        this._size--;
        return x2;
      }
      return t;
    };
    Tree2.prototype.pop = function() {
      var node = this._root;
      if (node) {
        while (node.left)
          node = node.left;
        this._root = splay(node.key, this._root, this._comparator);
        this._root = this._remove(node.key, this._root, this._comparator);
        return { key: node.key, data: node.data };
      }
      return null;
    };
    Tree2.prototype.findStatic = function(key) {
      var current = this._root;
      var compare = this._comparator;
      while (current) {
        var cmp2 = compare(key, current.key);
        if (cmp2 === 0)
          return current;
        else if (cmp2 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return null;
    };
    Tree2.prototype.find = function(key) {
      if (this._root) {
        this._root = splay(key, this._root, this._comparator);
        if (this._comparator(key, this._root.key) !== 0)
          return null;
      }
      return this._root;
    };
    Tree2.prototype.contains = function(key) {
      var current = this._root;
      var compare = this._comparator;
      while (current) {
        var cmp2 = compare(key, current.key);
        if (cmp2 === 0)
          return true;
        else if (cmp2 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return false;
    };
    Tree2.prototype.forEach = function(visitor, ctx) {
      var current = this._root;
      var Q = [];
      var done = false;
      while (!done) {
        if (current !== null) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length !== 0) {
            current = Q.pop();
            visitor.call(ctx, current);
            current = current.right;
          } else
            done = true;
        }
      }
      return this;
    };
    Tree2.prototype.range = function(low, high, fn, ctx) {
      var Q = [];
      var compare = this._comparator;
      var node = this._root;
      var cmp2;
      while (Q.length !== 0 || node) {
        if (node) {
          Q.push(node);
          node = node.left;
        } else {
          node = Q.pop();
          cmp2 = compare(node.key, high);
          if (cmp2 > 0) {
            break;
          } else if (compare(node.key, low) >= 0) {
            if (fn.call(ctx, node))
              return this;
          }
          node = node.right;
        }
      }
      return this;
    };
    Tree2.prototype.keys = function() {
      var keys = [];
      this.forEach(function(_a) {
        var key = _a.key;
        return keys.push(key);
      });
      return keys;
    };
    Tree2.prototype.values = function() {
      var values = [];
      this.forEach(function(_a) {
        var data = _a.data;
        return values.push(data);
      });
      return values;
    };
    Tree2.prototype.min = function() {
      if (this._root)
        return this.minNode(this._root).key;
      return null;
    };
    Tree2.prototype.max = function() {
      if (this._root)
        return this.maxNode(this._root).key;
      return null;
    };
    Tree2.prototype.minNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.left)
          t = t.left;
      return t;
    };
    Tree2.prototype.maxNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.right)
          t = t.right;
      return t;
    };
    Tree2.prototype.at = function(index2) {
      var current = this._root;
      var done = false;
      var i = 0;
      var Q = [];
      while (!done) {
        if (current) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length > 0) {
            current = Q.pop();
            if (i === index2)
              return current;
            i++;
            current = current.right;
          } else
            done = true;
        }
      }
      return null;
    };
    Tree2.prototype.next = function(d) {
      var root = this._root;
      var successor = null;
      if (d.right) {
        successor = d.right;
        while (successor.left)
          successor = successor.left;
        return successor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp2 = comparator(d.key, root.key);
        if (cmp2 === 0)
          break;
        else if (cmp2 < 0) {
          successor = root;
          root = root.left;
        } else
          root = root.right;
      }
      return successor;
    };
    Tree2.prototype.prev = function(d) {
      var root = this._root;
      var predecessor = null;
      if (d.left !== null) {
        predecessor = d.left;
        while (predecessor.right)
          predecessor = predecessor.right;
        return predecessor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp2 = comparator(d.key, root.key);
        if (cmp2 === 0)
          break;
        else if (cmp2 < 0)
          root = root.left;
        else {
          predecessor = root;
          root = root.right;
        }
      }
      return predecessor;
    };
    Tree2.prototype.clear = function() {
      this._root = null;
      this._size = 0;
      return this;
    };
    Tree2.prototype.toList = function() {
      return toList(this._root);
    };
    Tree2.prototype.load = function(keys, values, presort) {
      if (values === void 0) {
        values = [];
      }
      if (presort === void 0) {
        presort = false;
      }
      var size = keys.length;
      var comparator = this._comparator;
      if (presort)
        sort(keys, values, 0, size - 1, comparator);
      if (this._root === null) {
        this._root = loadRecursive(keys, values, 0, size);
        this._size = size;
      } else {
        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
        size = this._size + size;
        this._root = sortedListToBST({ head: mergedList }, 0, size);
      }
      return this;
    };
    Tree2.prototype.isEmpty = function() {
      return this._root === null;
    };
    Object.defineProperty(Tree2.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tree2.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: true,
      configurable: true
    });
    Tree2.prototype.toString = function(printNode) {
      if (printNode === void 0) {
        printNode = function(n) {
          return String(n.key);
        };
      }
      var out = [];
      printRow(this._root, "", true, function(v2) {
        return out.push(v2);
      }, printNode);
      return out.join("");
    };
    Tree2.prototype.update = function(key, newKey, newData) {
      var comparator = this._comparator;
      var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
      if (comparator(key, newKey) < 0) {
        right = insert(newKey, newData, right, comparator);
      } else {
        left = insert(newKey, newData, left, comparator);
      }
      this._root = merge(left, right, comparator);
    };
    Tree2.prototype.split = function(key) {
      return split(key, this._root, this._comparator);
    };
    Tree2.prototype[Symbol.iterator] = function() {
      var current, Q, done;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            current = this._root;
            Q = [];
            done = false;
            _a.label = 1;
          case 1:
            if (!!done) return [3, 6];
            if (!(current !== null)) return [3, 2];
            Q.push(current);
            current = current.left;
            return [3, 5];
          case 2:
            if (!(Q.length !== 0)) return [3, 4];
            current = Q.pop();
            return [4, current];
          case 3:
            _a.sent();
            current = current.right;
            return [3, 5];
          case 4:
            done = true;
            _a.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    return Tree2;
  }()
);
function loadRecursive(keys, values, start, end) {
  var size = end - start;
  if (size > 0) {
    var middle = start + Math.floor(size / 2);
    var key = keys[middle];
    var data = values[middle];
    var node = new Node(key, data);
    node.left = loadRecursive(keys, values, start, middle);
    node.right = loadRecursive(keys, values, middle + 1, end);
    return node;
  }
  return null;
}
function createList(keys, values) {
  var head = new Node(null, null);
  var p = head;
  for (var i = 0; i < keys.length; i++) {
    p = p.next = new Node(keys[i], values[i]);
  }
  p.next = null;
  return head.next;
}
function toList(root) {
  var current = root;
  var Q = [];
  var done = false;
  var head = new Node(null, null);
  var p = head;
  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = p = p.next = Q.pop();
        current = current.right;
      } else
        done = true;
    }
  }
  p.next = null;
  return head.next;
}
function sortedListToBST(list, start, end) {
  var size = end - start;
  if (size > 0) {
    var middle = start + Math.floor(size / 2);
    var left = sortedListToBST(list, start, middle);
    var root = list.head;
    root.left = left;
    list.head = list.head.next;
    root.right = sortedListToBST(list, middle + 1, end);
    return root;
  }
  return null;
}
function mergeLists(l1, l2, compare) {
  var head = new Node(null, null);
  var p = head;
  var p1 = l1;
  var p2 = l2;
  while (p1 !== null && p2 !== null) {
    if (compare(p1.key, p2.key) < 0) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  if (p1 !== null) {
    p.next = p1;
  } else if (p2 !== null) {
    p.next = p2;
  }
  return head.next;
}
function sort(keys, values, left, right, compare) {
  if (left >= right)
    return;
  var pivot = keys[left + right >> 1];
  var i = left - 1;
  var j = right + 1;
  while (true) {
    do
      i++;
    while (compare(keys[i], pivot) < 0);
    do
      j--;
    while (compare(keys[j], pivot) > 0);
    if (i >= j)
      break;
    var tmp = keys[i];
    keys[i] = keys[j];
    keys[j] = tmp;
    tmp = values[i];
    values[i] = values[j];
    values[j] = tmp;
  }
  sort(keys, values, left, j, compare);
  sort(keys, values, j + 1, right, compare);
}
var splay_esm_default = Tree;

// ../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js
var epsilon3 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon3) * epsilon3;
function sum2(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// ../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon3) * epsilon3;
var ccwerrboundB = (2 + 12 * epsilon3) * epsilon3;
var ccwerrboundC = (9 + 64 * epsilon3) * epsilon3 * epsilon3;
var B2 = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum2(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum2(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum2(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// ../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon3) * epsilon3;
var o3derrboundB = (3 + 28 * epsilon3) * epsilon3;
var o3derrboundC = (26 + 288 * epsilon3) * epsilon3 * epsilon3;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// ../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon3) * epsilon3;
var iccerrboundB = (4 + 48 * epsilon3) * epsilon3;
var iccerrboundC = (44 + 576 * epsilon3) * epsilon3 * epsilon3;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// ../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon3) * epsilon3;
var isperrboundB = (5 + 72 * epsilon3) * epsilon3;
var isperrboundC = (71 + 1408 * epsilon3) * epsilon3 * epsilon3;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// ../node_modules/.pnpm/polygon-clipping@0.15.7/node_modules/polygon-clipping/dist/polygon-clipping.esm.js
var isInBbox = (bbox3, point2) => {
  return bbox3.ll.x <= point2.x && point2.x <= bbox3.ur.x && bbox3.ll.y <= point2.y && point2.y <= bbox3.ur.y;
};
var getBboxOverlap = (b1, b2) => {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;
  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
var epsilon4 = Number.EPSILON;
if (epsilon4 === void 0) epsilon4 = Math.pow(2, -52);
var EPSILON_SQ = epsilon4 * epsilon4;
var cmp = (a, b) => {
  if (-epsilon4 < a && a < epsilon4) {
    if (-epsilon4 < b && b < epsilon4) {
      return 0;
    }
  }
  const ab5 = a - b;
  if (ab5 * ab5 < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
var PtRounder = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new CoordRounder();
    this.yRounder = new CoordRounder();
  }
  round(x2, y2) {
    return {
      x: this.xRounder.round(x2),
      y: this.yRounder.round(y2)
    };
  }
};
var CoordRounder = class {
  constructor() {
    this.tree = new splay_esm_default();
    this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(coord) {
    const node = this.tree.add(coord);
    const prevNode = this.tree.prev(node);
    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
      this.tree.remove(coord);
      return prevNode.key;
    }
    const nextNode = this.tree.next(node);
    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
      this.tree.remove(coord);
      return nextNode.key;
    }
    return coord;
  }
};
var rounder = new PtRounder();
var crossProduct = (a, b) => a.x * b.y - a.y * b.x;
var dotProduct = (a, b) => a.x * b.x + a.y * b.y;
var compareVectorAngles = (basePt, endPt1, endPt2) => {
  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
  if (res > 0) return -1;
  if (res < 0) return 1;
  return 0;
};
var length = (v2) => Math.sqrt(dotProduct(v2, v2));
var sineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
var cosineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
var horizontalIntersection = (pt, v2, y2) => {
  if (v2.y === 0) return null;
  return {
    x: pt.x + v2.x / v2.y * (y2 - pt.y),
    y: y2
  };
};
var verticalIntersection = (pt, v2, x2) => {
  if (v2.x === 0) return null;
  return {
    x: x2,
    y: pt.y + v2.y / v2.x * (x2 - pt.x)
  };
};
var intersection$1 = (pt1, v1, pt2, v2) => {
  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);
  const kross = crossProduct(v1, v2);
  if (kross == 0) return null;
  const ve = {
    x: pt2.x - pt1.x,
    y: pt2.y - pt1.y
  };
  const d1 = crossProduct(ve, v1) / kross;
  const d2 = crossProduct(ve, v2) / kross;
  const x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
  const y12 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
  const x3 = (x12 + x2) / 2;
  const y3 = (y12 + y2) / 2;
  return {
    x: x3,
    y: y3
  };
};
var SweepEvent = class _SweepEvent {
  // for ordering sweep events in the sweep event queue
  static compare(a, b) {
    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
    if (ptCmp !== 0) return ptCmp;
    if (a.point !== b.point) a.link(b);
    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
    return Segment2.compare(a.segment, b.segment);
  }
  // for ordering points in sweep line order
  static comparePoints(aPt, bPt) {
    if (aPt.x < bPt.x) return -1;
    if (aPt.x > bPt.x) return 1;
    if (aPt.y < bPt.y) return -1;
    if (aPt.y > bPt.y) return 1;
    return 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(point2, isLeft2) {
    if (point2.events === void 0) point2.events = [this];
    else point2.events.push(this);
    this.point = point2;
    this.isLeft = isLeft2;
  }
  link(other) {
    if (other.point === this.point) {
      throw new Error("Tried to link already linked events");
    }
    const otherEvents = other.point.events;
    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
      const evt = otherEvents[i];
      this.point.events.push(evt);
      evt.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const numEvents = this.point.events.length;
    for (let i = 0; i < numEvents; i++) {
      const evt1 = this.point.events[i];
      if (evt1.segment.consumedBy !== void 0) continue;
      for (let j = i + 1; j < numEvents; j++) {
        const evt2 = this.point.events[j];
        if (evt2.consumedBy !== void 0) continue;
        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
        evt1.segment.consume(evt2.segment);
      }
    }
  }
  getAvailableLinkedEvents() {
    const events = [];
    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
      const evt = this.point.events[i];
      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
        events.push(evt);
      }
    }
    return events;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(baseEvent) {
    const cache = /* @__PURE__ */ new Map();
    const fillCache = (linkedEvent) => {
      const nextEvent = linkedEvent.otherSE;
      cache.set(linkedEvent, {
        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
      });
    };
    return (a, b) => {
      if (!cache.has(a)) fillCache(a);
      if (!cache.has(b)) fillCache(b);
      const {
        sine: asine,
        cosine: acosine
      } = cache.get(a);
      const {
        sine: bsine,
        cosine: bcosine
      } = cache.get(b);
      if (asine >= 0 && bsine >= 0) {
        if (acosine < bcosine) return 1;
        if (acosine > bcosine) return -1;
        return 0;
      }
      if (asine < 0 && bsine < 0) {
        if (acosine < bcosine) return -1;
        if (acosine > bcosine) return 1;
        return 0;
      }
      if (bsine < asine) return -1;
      if (bsine > asine) return 1;
      return 0;
    };
  }
};
var segmentId = 0;
var Segment2 = class _Segment {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(a, b) {
    const alx = a.leftSE.point.x;
    const blx = b.leftSE.point.x;
    const arx = a.rightSE.point.x;
    const brx = b.rightSE.point.x;
    if (brx < alx) return 1;
    if (arx < blx) return -1;
    const aly = a.leftSE.point.y;
    const bly = b.leftSE.point.y;
    const ary = a.rightSE.point.y;
    const bry = b.rightSE.point.y;
    if (alx < blx) {
      if (bly < aly && bly < ary) return 1;
      if (bly > aly && bly > ary) return -1;
      const aCmpBLeft = a.comparePoint(b.leftSE.point);
      if (aCmpBLeft < 0) return 1;
      if (aCmpBLeft > 0) return -1;
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
      return -1;
    }
    if (alx > blx) {
      if (aly < bly && aly < bry) return -1;
      if (aly > bly && aly > bry) return 1;
      const bCmpALeft = b.comparePoint(a.leftSE.point);
      if (bCmpALeft !== 0) return bCmpALeft;
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
      return 1;
    }
    if (aly < bly) return -1;
    if (aly > bly) return 1;
    if (arx < brx) {
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
    }
    if (arx > brx) {
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
    }
    if (arx !== brx) {
      const ay = ary - aly;
      const ax = arx - alx;
      const by = bry - bly;
      const bx = brx - blx;
      if (ay > ax && by < bx) return 1;
      if (ay < ax && by > bx) return -1;
    }
    if (arx > brx) return 1;
    if (arx < brx) return -1;
    if (ary < bry) return -1;
    if (ary > bry) return 1;
    if (a.id < b.id) return -1;
    if (a.id > b.id) return 1;
    return 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(leftSE, rightSE, rings, windings) {
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  static fromRing(pt1, pt2, ring) {
    let leftPt, rightPt, winding;
    const cmpPts = SweepEvent.comparePoints(pt1, pt2);
    if (cmpPts < 0) {
      leftPt = pt1;
      rightPt = pt2;
      winding = 1;
    } else if (cmpPts > 0) {
      leftPt = pt2;
      rightPt = pt1;
      winding = -1;
    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
    const leftSE = new SweepEvent(leftPt, true);
    const rightSE = new SweepEvent(rightPt, false);
    return new _Segment(leftSE, rightSE, [ring], [winding]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(newRightSE) {
    this.rightSE = newRightSE;
    this.rightSE.segment = this;
    this.rightSE.otherSE = this.leftSE;
    this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const y12 = this.leftSE.point.y;
    const y2 = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: y12 < y2 ? y12 : y2
      },
      ur: {
        x: this.rightSE.point.x,
        y: y12 > y2 ? y12 : y2
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(pt) {
    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(point2) {
    if (this.isAnEndpoint(point2)) return 0;
    const lPt = this.leftSE.point;
    const rPt = this.rightSE.point;
    const v2 = this.vector();
    if (lPt.x === rPt.x) {
      if (point2.x === lPt.x) return 0;
      return point2.x < lPt.x ? 1 : -1;
    }
    const yDist = (point2.y - lPt.y) / v2.y;
    const xFromYDist = lPt.x + yDist * v2.x;
    if (point2.x === xFromYDist) return 0;
    const xDist = (point2.x - lPt.x) / v2.x;
    const yFromXDist = lPt.y + xDist * v2.y;
    if (point2.y === yFromXDist) return 0;
    return point2.y < yFromXDist ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(other) {
    const tBbox = this.bbox();
    const oBbox = other.bbox();
    const bboxOverlap = getBboxOverlap(tBbox, oBbox);
    if (bboxOverlap === null) return null;
    const tlp = this.leftSE.point;
    const trp = this.rightSE.point;
    const olp = other.leftSE.point;
    const orp = other.rightSE.point;
    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
    if (touchesThisLSE && touchesOtherLSE) {
      if (touchesThisRSE && !touchesOtherRSE) return trp;
      if (!touchesThisRSE && touchesOtherRSE) return orp;
      return null;
    }
    if (touchesThisLSE) {
      if (touchesOtherRSE) {
        if (tlp.x === orp.x && tlp.y === orp.y) return null;
      }
      return tlp;
    }
    if (touchesOtherLSE) {
      if (touchesThisRSE) {
        if (trp.x === olp.x && trp.y === olp.y) return null;
      }
      return olp;
    }
    if (touchesThisRSE && touchesOtherRSE) return null;
    if (touchesThisRSE) return trp;
    if (touchesOtherRSE) return orp;
    const pt = intersection$1(tlp, this.vector(), olp, other.vector());
    if (pt === null) return null;
    if (!isInBbox(bboxOverlap, pt)) return null;
    return rounder.round(pt.x, pt.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(point2) {
    const newEvents = [];
    const alreadyLinked = point2.events !== void 0;
    const newLeftSE = new SweepEvent(point2, true);
    const newRightSE = new SweepEvent(point2, false);
    const oldRightSE = this.rightSE;
    this.replaceRightSE(newRightSE);
    newEvents.push(newRightSE);
    newEvents.push(newLeftSE);
    const newSeg = new _Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
      newSeg.swapEvents();
    }
    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
      this.swapEvents();
    }
    if (alreadyLinked) {
      newLeftSE.checkForConsuming();
      newRightSE.checkForConsuming();
    }
    return newEvents;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const tmpEvt = this.rightSE;
    this.rightSE = this.leftSE;
    this.leftSE = tmpEvt;
    this.leftSE.isLeft = true;
    this.rightSE.isLeft = false;
    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
      this.windings[i] *= -1;
    }
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(other) {
    let consumer = this;
    let consumee = other;
    while (consumer.consumedBy) consumer = consumer.consumedBy;
    while (consumee.consumedBy) consumee = consumee.consumedBy;
    const cmp2 = _Segment.compare(consumer, consumee);
    if (cmp2 === 0) return;
    if (cmp2 > 0) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    if (consumer.prev === consumee) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
      const ring = consumee.rings[i];
      const winding = consumee.windings[i];
      const index2 = consumer.rings.indexOf(ring);
      if (index2 === -1) {
        consumer.rings.push(ring);
        consumer.windings.push(winding);
      } else consumer.windings[index2] += winding;
    }
    consumee.rings = null;
    consumee.windings = null;
    consumee.consumedBy = consumer;
    consumee.leftSE.consumedBy = consumer.leftSE;
    consumee.rightSE.consumedBy = consumer.rightSE;
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    if (this._prevInResult !== void 0) return this._prevInResult;
    if (!this.prev) this._prevInResult = null;
    else if (this.prev.isInResult()) this._prevInResult = this.prev;
    else this._prevInResult = this.prev.prevInResult();
    return this._prevInResult;
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const seg = this.prev.consumedBy || this.prev;
      this._beforeState = seg.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const beforeState = this.beforeState();
    this._afterState = {
      rings: beforeState.rings.slice(0),
      windings: beforeState.windings.slice(0),
      multiPolys: []
    };
    const ringsAfter = this._afterState.rings;
    const windingsAfter = this._afterState.windings;
    const mpsAfter = this._afterState.multiPolys;
    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
      const ring = this.rings[i];
      const winding = this.windings[i];
      const index2 = ringsAfter.indexOf(ring);
      if (index2 === -1) {
        ringsAfter.push(ring);
        windingsAfter.push(winding);
      } else windingsAfter[index2] += winding;
    }
    const polysAfter = [];
    const polysExclude = [];
    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
      if (windingsAfter[i] === 0) continue;
      const ring = ringsAfter[i];
      const poly = ring.poly;
      if (polysExclude.indexOf(poly) !== -1) continue;
      if (ring.isExterior) polysAfter.push(poly);
      else {
        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
        const index2 = polysAfter.indexOf(ring.poly);
        if (index2 !== -1) polysAfter.splice(index2, 1);
      }
    }
    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
      const mp = polysAfter[i].multiPoly;
      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return false;
    if (this._isInResult !== void 0) return this._isInResult;
    const mpsBefore = this.beforeState().multiPolys;
    const mpsAfter = this.afterState().multiPolys;
    switch (operation.type) {
      case "union": {
        const noBefores = mpsBefore.length === 0;
        const noAfters = mpsAfter.length === 0;
        this._isInResult = noBefores !== noAfters;
        break;
      }
      case "intersection": {
        let least;
        let most;
        if (mpsBefore.length < mpsAfter.length) {
          least = mpsBefore.length;
          most = mpsAfter.length;
        } else {
          least = mpsAfter.length;
          most = mpsBefore.length;
        }
        this._isInResult = most === operation.numMultiPolys && least < most;
        break;
      }
      case "xor": {
        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
        this._isInResult = diff % 2 === 1;
        break;
      }
      case "difference": {
        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${operation.type}`);
    }
    return this._isInResult;
  }
};
var RingIn = class {
  constructor(geomRing, poly, isExterior) {
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    let prevPoint = firstPoint;
    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      let point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point2.x === prevPoint.x && point2.y === prevPoint.y) continue;
      this.segments.push(Segment2.fromRing(prevPoint, point2, this));
      if (point2.x < this.bbox.ll.x) this.bbox.ll.x = point2.x;
      if (point2.y < this.bbox.ll.y) this.bbox.ll.y = point2.y;
      if (point2.x > this.bbox.ur.x) this.bbox.ur.x = point2.x;
      if (point2.y > this.bbox.ur.y) this.bbox.ur.y = point2.y;
      prevPoint = point2;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment2.fromRing(prevPoint, firstPoint, this));
    }
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
      const segment = this.segments[i];
      sweepEvents.push(segment.leftSE);
      sweepEvents.push(segment.rightSE);
    }
    return sweepEvents;
  }
};
var PolyIn = class {
  constructor(geomPoly, multiPoly) {
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
      const ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  getSweepEvents() {
    const sweepEvents = this.exteriorRing.getSweepEvents();
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringSweepEvents = this.interiorRings[i].getSweepEvents();
      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
        sweepEvents.push(ringSweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var MultiPolyIn = class {
  constructor(geom, isSubject) {
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number") geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let i = 0, iMax = geom.length; i < iMax; i++) {
      const poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polySweepEvents = this.polys[i].getSweepEvents();
      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
        sweepEvents.push(polySweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var RingOut = class _RingOut {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(allSegments) {
    const ringsOut = [];
    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
      const segment = allSegments[i];
      if (!segment.isInResult() || segment.ringOut) continue;
      let prevEvent = null;
      let event = segment.leftSE;
      let nextEvent = segment.rightSE;
      const events = [event];
      const startingPoint = event.point;
      const intersectionLEs = [];
      while (true) {
        prevEvent = event;
        event = nextEvent;
        events.push(event);
        if (event.point === startingPoint) break;
        while (true) {
          const availableLEs = event.getAvailableLinkedEvents();
          if (availableLEs.length === 0) {
            const firstPt = events[0].point;
            const lastPt = events[events.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
          }
          if (availableLEs.length === 1) {
            nextEvent = availableLEs[0].otherSE;
            break;
          }
          let indexLE = null;
          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
            if (intersectionLEs[j].point === event.point) {
              indexLE = j;
              break;
            }
          }
          if (indexLE !== null) {
            const intersectionLE = intersectionLEs.splice(indexLE)[0];
            const ringEvents = events.splice(intersectionLE.index);
            ringEvents.unshift(ringEvents[0].otherSE);
            ringsOut.push(new _RingOut(ringEvents.reverse()));
            continue;
          }
          intersectionLEs.push({
            index: events.length,
            point: event.point
          });
          const comparator = event.getLeftmostComparator(prevEvent);
          nextEvent = availableLEs.sort(comparator)[0].otherSE;
          break;
        }
      }
      ringsOut.push(new _RingOut(events));
    }
    return ringsOut;
  }
  constructor(events) {
    this.events = events;
    for (let i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  getGeom() {
    let prevPt = this.events[0].point;
    const points2 = [prevPt];
    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
      const pt2 = this.events[i].point;
      const nextPt2 = this.events[i + 1].point;
      if (compareVectorAngles(pt2, prevPt, nextPt2) === 0) continue;
      points2.push(pt2);
      prevPt = pt2;
    }
    if (points2.length === 1) return null;
    const pt = points2[0];
    const nextPt = points2[1];
    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points2.shift();
    points2.push(points2[0]);
    const step = this.isExteriorRing() ? 1 : -1;
    const iStart = this.isExteriorRing() ? 0 : points2.length - 1;
    const iEnd = this.isExteriorRing() ? points2.length : -1;
    const orderedPoints = [];
    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points2[i].x, points2[i].y]);
    return orderedPoints;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const enclosing = this.enclosingRing();
      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    if (this._enclosingRing === void 0) {
      this._enclosingRing = this._calcEnclosingRing();
    }
    return this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let leftMostEvt = this.events[0];
    for (let i = 1, iMax = this.events.length; i < iMax; i++) {
      const evt = this.events[i];
      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
    }
    let prevSeg = leftMostEvt.segment.prevInResult();
    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    while (true) {
      if (!prevSeg) return null;
      if (!prevPrevSeg) return prevSeg.ringOut;
      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
          return prevSeg.ringOut;
        } else return prevSeg.ringOut.enclosingRing();
      }
      prevSeg = prevPrevSeg.prevInResult();
      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    }
  }
};
var PolyOut = class {
  constructor(exteriorRing) {
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  addInterior(ring) {
    this.interiorRings.push(ring);
    ring.poly = this;
  }
  getGeom() {
    const geom = [this.exteriorRing.getGeom()];
    if (geom[0] === null) return null;
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringGeom = this.interiorRings[i].getGeom();
      if (ringGeom === null) continue;
      geom.push(ringGeom);
    }
    return geom;
  }
};
var MultiPolyOut = class {
  constructor(rings) {
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  getGeom() {
    const geom = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polyGeom = this.polys[i].getGeom();
      if (polyGeom === null) continue;
      geom.push(polyGeom);
    }
    return geom;
  }
  _composePolys(rings) {
    const polys = [];
    for (let i = 0, iMax = rings.length; i < iMax; i++) {
      const ring = rings[i];
      if (ring.poly) continue;
      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
      else {
        const enclosingRing = ring.enclosingRing();
        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
        enclosingRing.poly.addInterior(ring);
      }
    }
    return polys;
  }
};
var SweepLine = class {
  constructor(queue) {
    let comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment2.compare;
    this.queue = queue;
    this.tree = new splay_esm_default(comparator);
    this.segments = [];
  }
  process(event) {
    const segment = event.segment;
    const newEvents = [];
    if (event.consumedBy) {
      if (event.isLeft) this.queue.remove(event.otherSE);
      else this.tree.remove(segment);
      return newEvents;
    }
    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
    if (!node) throw new Error(`Unable to find segment #${segment.id} [${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> [${segment.rightSE.point.x}, ${segment.rightSE.point.y}] in SweepLine tree.`);
    let prevNode = node;
    let nextNode = node;
    let prevSeg = void 0;
    let nextSeg = void 0;
    while (prevSeg === void 0) {
      prevNode = this.tree.prev(prevNode);
      if (prevNode === null) prevSeg = null;
      else if (prevNode.key.consumedBy === void 0) prevSeg = prevNode.key;
    }
    while (nextSeg === void 0) {
      nextNode = this.tree.next(nextNode);
      if (nextNode === null) nextSeg = null;
      else if (nextNode.key.consumedBy === void 0) nextSeg = nextNode.key;
    }
    if (event.isLeft) {
      let prevMySplitter = null;
      if (prevSeg) {
        const prevInter = prevSeg.getIntersection(segment);
        if (prevInter !== null) {
          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
          if (!prevSeg.isAnEndpoint(prevInter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      let nextMySplitter = null;
      if (nextSeg) {
        const nextInter = nextSeg.getIntersection(segment);
        if (nextInter !== null) {
          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
          if (!nextSeg.isAnEndpoint(nextInter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      if (prevMySplitter !== null || nextMySplitter !== null) {
        let mySplitter = null;
        if (prevMySplitter === null) mySplitter = nextMySplitter;
        else if (nextMySplitter === null) mySplitter = prevMySplitter;
        else {
          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
        }
        this.queue.remove(segment.rightSE);
        newEvents.push(segment.rightSE);
        const newEventsFromSplit = segment.split(mySplitter);
        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
          newEvents.push(newEventsFromSplit[i]);
        }
      }
      if (newEvents.length > 0) {
        this.tree.remove(segment);
        newEvents.push(event);
      } else {
        this.segments.push(segment);
        segment.prev = prevSeg;
      }
    } else {
      if (prevSeg && nextSeg) {
        const inter = prevSeg.getIntersection(nextSeg);
        if (inter !== null) {
          if (!prevSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (!nextSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      this.tree.remove(segment);
    }
    return newEvents;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(seg, pt) {
    this.tree.remove(seg);
    const rightSE = seg.rightSE;
    this.queue.remove(rightSE);
    const newEvents = seg.split(pt);
    newEvents.push(rightSE);
    if (seg.consumedBy === void 0) this.tree.add(seg);
    return newEvents;
  }
};
var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
var Operation = class {
  run(type, geom, moreGeoms) {
    operation.type = type;
    rounder.reset();
    const multipolys = [new MultiPolyIn(geom, true)];
    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
      multipolys.push(new MultiPolyIn(moreGeoms[i], false));
    }
    operation.numMultiPolys = multipolys.length;
    if (operation.type === "difference") {
      const subject = multipolys[0];
      let i = 1;
      while (i < multipolys.length) {
        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
        else multipolys.splice(i, 1);
      }
    }
    if (operation.type === "intersection") {
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const mpA = multipolys[i];
        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
        }
      }
    }
    const queue = new splay_esm_default(SweepEvent.compare);
    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
      const sweepEvents = multipolys[i].getSweepEvents();
      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
        queue.insert(sweepEvents[j]);
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
        }
      }
    }
    const sweepLine = new SweepLine(queue);
    let prevQueueSize = queue.size;
    let node = queue.pop();
    while (node) {
      const evt = node.key;
      if (queue.size === prevQueueSize) {
        const seg = evt.segment;
        throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent [${evt.point.x}, ${evt.point.y}] from segment #${seg.id} [${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> [${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
      }
      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      }
      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      }
      const newEvents = sweepLine.process(evt);
      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
        const evt2 = newEvents[i];
        if (evt2.consumedBy === void 0) queue.insert(evt2);
      }
      prevQueueSize = queue.size;
      node = queue.pop();
    }
    rounder.reset();
    const ringsOut = RingOut.factory(sweepLine.segments);
    const result = new MultiPolyOut(ringsOut);
    return result.getGeom();
  }
};
var operation = new Operation();
var union = function(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
var intersection = function(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
var xor = function(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
var difference = function(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index = {
  union,
  intersection,
  xor,
  difference
};

// ../node_modules/.pnpm/@turf+difference@7.1.0/node_modules/@turf/difference/dist/esm/index.js
function difference2(features) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must have at least two features");
  }
  const properties = features.features[0].properties || {};
  const differenced = index.difference(geoms[0], ...geoms.slice(1));
  if (differenced.length === 0)
    return null;
  if (differenced.length === 1)
    return polygon(differenced[0], properties);
  return multiPolygon(differenced, properties);
}

// ../node_modules/.pnpm/@turf+flatten@7.1.0/node_modules/@turf/flatten/dist/esm/index.js
function flatten(geojson) {
  if (!geojson)
    throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature2) {
    results.push(feature2);
  });
  return featureCollection(results);
}

// ../node_modules/.pnpm/@turf+dissolve@7.1.0/node_modules/@turf/dissolve/dist/esm/index.js
function dissolve2(fc, options = {}) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const { propertyName } = options;
  collectionOf(fc, "Polygon", "dissolve");
  const outFeatures = [];
  if (!propertyName) {
    return flatten(
      multiPolygon(
        index.union.apply(
          null,
          // List of polygons expressed as Position[][][] a.k.a. Geom[]
          fc.features.map(function(f) {
            return f.geometry.coordinates;
          })
        )
      )
    );
  } else {
    const uniquePropertyVals = {};
    featureEach(fc, function(feature2) {
      if (feature2.properties) {
        if (!Object.prototype.hasOwnProperty.call(
          uniquePropertyVals,
          feature2.properties[propertyName]
        )) {
          uniquePropertyVals[feature2.properties[propertyName]] = [];
        }
        uniquePropertyVals[feature2.properties[propertyName]].push(feature2);
      }
    });
    const vals = Object.keys(uniquePropertyVals);
    for (let i = 0; i < vals.length; i++) {
      const mp = multiPolygon(
        index.union.apply(
          null,
          // List of polygons expressed as Position[][][] a.k.a. Geom[]
          uniquePropertyVals[vals[i]].map(function(f) {
            return f.geometry.coordinates;
          })
        )
      );
      if (mp && mp.properties) {
        mp.properties[propertyName] = vals[i];
        outFeatures.push(mp);
      }
    }
  }
  return flatten(featureCollection(outFeatures));
}

// ../node_modules/.pnpm/@turf+distance-weight@7.1.0/node_modules/@turf/distance-weight/dist/esm/index.js
function pNormDistance(feature1, feature2, p = 2) {
  const coordinate1 = getCoord(feature1);
  const coordinate2 = getCoord(feature2);
  const xDiff = coordinate1[0] - coordinate2[0];
  const yDiff = coordinate1[1] - coordinate2[1];
  if (p === 1) {
    return Math.abs(xDiff) + Math.abs(yDiff);
  }
  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
function distanceWeight(fc, options) {
  var _a, _b;
  options = options || {};
  const threshold = options.threshold || 1e4;
  const p = options.p || 2;
  const binary = (_a = options.binary) != null ? _a : false;
  const alpha = options.alpha || -1;
  const rowTransform = (_b = options.standardization) != null ? _b : false;
  const features = [];
  featureEach(fc, (feature2) => {
    features.push(centroid(feature2));
  });
  const weights = [];
  for (let i = 0; i < features.length; i++) {
    weights[i] = [];
  }
  for (let i = 0; i < features.length; i++) {
    for (let j = i; j < features.length; j++) {
      if (i === j) {
        weights[i][j] = 0;
      }
      const dis = pNormDistance(features[i], features[j], p);
      weights[i][j] = dis;
      weights[j][i] = dis;
    }
  }
  for (let i = 0; i < features.length; i++) {
    for (let j = 0; j < features.length; j++) {
      const dis = weights[i][j];
      if (dis === 0) {
        continue;
      }
      if (binary) {
        if (dis <= threshold) {
          weights[i][j] = 1;
        } else {
          weights[i][j] = 0;
        }
      } else {
        if (dis <= threshold) {
          weights[i][j] = Math.pow(dis, alpha);
        } else {
          weights[i][j] = 0;
        }
      }
    }
  }
  if (rowTransform) {
    for (let i = 0; i < features.length; i++) {
      const rowSum = weights[i].reduce((sum3, currentVal) => {
        return sum3 + currentVal;
      }, 0);
      for (let j = 0; j < features.length; j++) {
        weights[i][j] = weights[i][j] / rowSum;
      }
    }
  }
  return weights;
}

// ../node_modules/.pnpm/@turf+rhumb-destination@7.1.0/node_modules/@turf/rhumb-destination/dist/esm/index.js
function rhumbDestination(origin, distance2, bearing2, options = {}) {
  const wasNegativeDistance = distance2 < 0;
  let distanceInMeters = convertLength(
    Math.abs(distance2),
    options.units,
    "meters"
  );
  if (wasNegativeDistance)
    distanceInMeters = -Math.abs(distanceInMeters);
  const coords = getCoord(origin);
  const destination2 = calculateRhumbDestination(
    coords,
    distanceInMeters,
    bearing2
  );
  destination2[0] += destination2[0] - coords[0] > 180 ? -360 : coords[0] - destination2[0] > 180 ? 360 : 0;
  return point(destination2, options.properties);
}
function calculateRhumbDestination(origin, distance2, bearing2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  const delta = distance2 / radius;
  const lambda1 = origin[0] * Math.PI / 180;
  const phi1 = degreesToRadians(origin[1]);
  const theta = degreesToRadians(bearing2);
  const DeltaPhi = delta * Math.cos(theta);
  let phi2 = phi1 + DeltaPhi;
  if (Math.abs(phi2) > Math.PI / 2) {
    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
  }
  const DeltaPsi = Math.log(
    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)
  );
  const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  const DeltaLambda = delta * Math.sin(theta) / q;
  const lambda2 = lambda1 + DeltaLambda;
  return [
    (lambda2 * 180 / Math.PI + 540) % 360 - 180,
    phi2 * 180 / Math.PI
  ];
}

// ../node_modules/.pnpm/@turf+rhumb-distance@7.1.0/node_modules/@turf/rhumb-distance/dist/esm/index.js
function rhumbDistance(from, to, options = {}) {
  const origin = getCoord(from);
  const destination2 = getCoord(to);
  destination2[0] += destination2[0] - origin[0] > 180 ? -360 : origin[0] - destination2[0] > 180 ? 360 : 0;
  const distanceInMeters = calculateRhumbDistance(origin, destination2);
  const distance2 = convertLength(distanceInMeters, "meters", options.units);
  return distance2;
}
function calculateRhumbDistance(origin, destination2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  const R = radius;
  const phi1 = origin[1] * Math.PI / 180;
  const phi2 = destination2[1] * Math.PI / 180;
  const DeltaPhi = phi2 - phi1;
  let DeltaLambda = Math.abs(destination2[0] - origin[0]) * Math.PI / 180;
  if (DeltaLambda > Math.PI) {
    DeltaLambda -= 2 * Math.PI;
  }
  const DeltaPsi = Math.log(
    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)
  );
  const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  const delta = Math.sqrt(
    DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda
  );
  const dist = delta * R;
  return dist;
}

// ../node_modules/.pnpm/@turf+transform-rotate@7.1.0/node_modules/@turf/transform-rotate/dist/esm/index.js
function transformRotate(geojson, angle2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const pivot = options.pivot;
  const mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (angle2 === void 0 || angle2 === null || isNaN(angle2))
    throw new Error("angle is required");
  if (angle2 === 0)
    return geojson;
  const pivotCoord = pivot != null ? pivot : centroid(geojson);
  if (mutate === false || mutate === void 0)
    geojson = clone(geojson);
  coordEach(geojson, function(pointCoords) {
    const initialAngle = rhumbBearing(pivotCoord, pointCoords);
    const finalAngle = initialAngle + angle2;
    const distance2 = rhumbDistance(pivotCoord, pointCoords);
    const newCoords = getCoords(
      rhumbDestination(pivotCoord, distance2, finalAngle)
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
  });
  return geojson;
}

// ../node_modules/.pnpm/@turf+ellipse@7.1.0/node_modules/@turf/ellipse/dist/esm/index.js
function ellipse(center2, xSemiAxis, ySemiAxis, options) {
  options = options || {};
  const steps = options.steps || 64;
  const units = options.units || "kilometers";
  const angle2 = options.angle || 0;
  const pivot = options.pivot || center2;
  const properties = options.properties || {};
  if (!center2)
    throw new Error("center is required");
  if (!xSemiAxis)
    throw new Error("xSemiAxis is required");
  if (!ySemiAxis)
    throw new Error("ySemiAxis is required");
  if (!isObject(options))
    throw new Error("options must be an object");
  if (!isNumber(steps))
    throw new Error("steps must be a number");
  if (!isNumber(angle2))
    throw new Error("angle must be a number");
  const centerCoords = getCoord(center2);
  if (units !== "degrees") {
    const xDest = rhumbDestination(center2, xSemiAxis, 90, { units });
    const yDest = rhumbDestination(center2, ySemiAxis, 0, { units });
    xSemiAxis = getCoord(xDest)[0] - centerCoords[0];
    ySemiAxis = getCoord(yDest)[1] - centerCoords[1];
  }
  const coordinates = [];
  for (let i = 0; i < steps; i += 1) {
    const stepAngle = i * -360 / steps;
    let x2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
    );
    let y2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
    );
    if (stepAngle < -90 && stepAngle >= -270)
      x2 = -x2;
    if (stepAngle < -180 && stepAngle >= -360)
      y2 = -y2;
    if (units === "degrees") {
      const angleRad = degreesToRadians(angle2);
      const newx = x2 * Math.cos(angleRad) + y2 * Math.sin(angleRad);
      const newy = y2 * Math.cos(angleRad) - x2 * Math.sin(angleRad);
      x2 = newx;
      y2 = newy;
    }
    coordinates.push([x2 + centerCoords[0], y2 + centerCoords[1]]);
  }
  coordinates.push(coordinates[0]);
  if (units === "degrees") {
    return polygon([coordinates], properties);
  } else {
    return transformRotate(polygon([coordinates], properties), angle2, {
      pivot
    });
  }
}
function getTanDeg(deg) {
  const rad = deg * Math.PI / 180;
  return Math.tan(rad);
}

// ../node_modules/.pnpm/@turf+envelope@7.1.0/node_modules/@turf/envelope/dist/esm/index.js
function envelope(geojson) {
  return bboxPolygon(bbox(geojson));
}

// ../node_modules/.pnpm/@turf+explode@7.1.0/node_modules/@turf/explode/dist/esm/index.js
function explode2(geojson) {
  const points2 = [];
  if (geojson.type === "FeatureCollection") {
    featureEach(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points2.push(point(coord, feature2.properties));
      });
    });
  } else if (geojson.type === "Feature") {
    coordEach(geojson, function(coord) {
      points2.push(point(coord, geojson.properties));
    });
  } else {
    coordEach(geojson, function(coord) {
      points2.push(point(coord));
    });
  }
  return featureCollection(points2);
}

// ../node_modules/.pnpm/@turf+flip@7.1.0/node_modules/@turf/flip/dist/esm/index.js
function flip(geojson, options) {
  var _a;
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const mutate = (_a = options.mutate) != null ? _a : false;
  if (!geojson)
    throw new Error("geojson is required");
  if (mutate === false || mutate === void 0)
    geojson = clone(geojson);
  coordEach(geojson, function(coord) {
    var x2 = coord[0];
    var y2 = coord[1];
    coord[0] = y2;
    coord[1] = x2;
  });
  return geojson;
}

// ../node_modules/.pnpm/@turf+great-circle@7.1.0/node_modules/@turf/great-circle/dist/esm/index.js
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var Coord = function(lon2, lat2) {
  this.lon = lon2;
  this.lat = lat2;
  this.x = D2R * lon2;
  this.y = D2R * lat2;
};
Coord.prototype.view = function() {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
Coord.prototype.antipode = function() {
  var anti_lat = -1 * this.lat;
  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new Coord(anti_lon, anti_lat);
};
var LineString = function() {
  this.coords = [];
  this.length = 0;
};
LineString.prototype.move_to = function(coord) {
  this.length++;
  this.coords.push(coord);
};
var Arc = function(properties) {
  this.properties = properties || {};
  this.geometries = [];
};
Arc.prototype.json = function() {
  if (this.geometries.length <= 0) {
    return {
      geometry: { type: "LineString", coordinates: null },
      type: "Feature",
      properties: this.properties
    };
  } else if (this.geometries.length === 1) {
    return {
      geometry: { type: "LineString", coordinates: this.geometries[0].coords },
      type: "Feature",
      properties: this.properties
    };
  } else {
    var multiline = [];
    for (var i = 0; i < this.geometries.length; i++) {
      multiline.push(this.geometries[i].coords);
    }
    return {
      geometry: { type: "MultiLineString", coordinates: multiline },
      type: "Feature",
      properties: this.properties
    };
  }
};
Arc.prototype.wkt = function() {
  var wkt_string = "";
  var wkt = "LINESTRING(";
  var collect2 = function(c) {
    wkt += c[0] + " " + c[1] + ",";
  };
  for (var i = 0; i < this.geometries.length; i++) {
    if (this.geometries[i].coords.length === 0) {
      return "LINESTRING(empty)";
    } else {
      var coords = this.geometries[i].coords;
      coords.forEach(collect2);
      wkt_string += wkt.substring(0, wkt.length - 1) + ")";
    }
  }
  return wkt_string;
};
var GreatCircle = function(start, end, properties) {
  if (!start || start.x === void 0 || start.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  if (!end || end.x === void 0 || end.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  this.start = new Coord(start.x, start.y);
  this.end = new Coord(end.x, end.y);
  this.properties = properties || {};
  var w = this.start.x - this.end.x;
  var h = this.start.y - this.end.y;
  var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
  this.g = 2 * Math.asin(Math.sqrt(z));
  if (this.g === Math.PI) {
    throw new Error(
      "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
    );
  } else if (isNaN(this.g)) {
    throw new Error(
      "could not calculate great circle between " + start + " and " + end
    );
  }
};
GreatCircle.prototype.interpolate = function(f) {
  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
  var B3 = Math.sin(f * this.g) / Math.sin(this.g);
  var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B3 * Math.cos(this.end.y) * Math.cos(this.end.x);
  var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B3 * Math.cos(this.end.y) * Math.sin(this.end.x);
  var z = A * Math.sin(this.start.y) + B3 * Math.sin(this.end.y);
  var lat2 = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
  var lon2 = R2D * Math.atan2(y2, x2);
  return [lon2, lat2];
};
GreatCircle.prototype.Arc = function(npoints, options) {
  var first_pass = [];
  if (!npoints || npoints <= 2) {
    first_pass.push([this.start.lon, this.start.lat]);
    first_pass.push([this.end.lon, this.end.lat]);
  } else {
    var delta = 1 / (npoints - 1);
    for (var i = 0; i < npoints; ++i) {
      var step = delta * i;
      var pair2 = this.interpolate(step);
      first_pass.push(pair2);
    }
  }
  var bHasBigDiff = false;
  var dfMaxSmallDiffLong = 0;
  var dfDateLineOffset = options && options.offset ? options.offset : 10;
  var dfLeftBorderX = 180 - dfDateLineOffset;
  var dfRightBorderX = -180 + dfDateLineOffset;
  var dfDiffSpace = 360 - dfDateLineOffset;
  for (var j = 1; j < first_pass.length; ++j) {
    var dfPrevX = first_pass[j - 1][0];
    var dfX = first_pass[j][0];
    var dfDiffLong = Math.abs(dfX - dfPrevX);
    if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
      bHasBigDiff = true;
    } else if (dfDiffLong > dfMaxSmallDiffLong) {
      dfMaxSmallDiffLong = dfDiffLong;
    }
  }
  var poMulti = [];
  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
    var poNewLS = [];
    poMulti.push(poNewLS);
    for (var k = 0; k < first_pass.length; ++k) {
      var dfX0 = parseFloat(first_pass[k][0]);
      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
        var dfX1 = parseFloat(first_pass[k - 1][0]);
        var dfY1 = parseFloat(first_pass[k - 1][1]);
        var dfX2 = parseFloat(first_pass[k][0]);
        var dfY2 = parseFloat(first_pass[k][1]);
        if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
          poNewLS.push([-180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
          poNewLS.push([180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        }
        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
          var tmpX = dfX1;
          dfX1 = dfX2;
          dfX2 = tmpX;
          var tmpY = dfY1;
          dfY1 = dfY2;
          dfY2 = tmpY;
        }
        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
          dfX2 += 360;
        }
        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
            dfY
          ]);
          poNewLS = [];
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
            dfY
          ]);
          poMulti.push(poNewLS);
        } else {
          poNewLS = [];
          poMulti.push(poNewLS);
        }
        poNewLS.push([dfX0, first_pass[k][1]]);
      } else {
        poNewLS.push([first_pass[k][0], first_pass[k][1]]);
      }
    }
  } else {
    var poNewLS0 = [];
    poMulti.push(poNewLS0);
    for (var l = 0; l < first_pass.length; ++l) {
      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
    }
  }
  var arc = new Arc(this.properties);
  for (var m = 0; m < poMulti.length; ++m) {
    var line = new LineString();
    arc.geometries.push(line);
    var points2 = poMulti[m];
    for (var j0 = 0; j0 < points2.length; ++j0) {
      line.move_to(points2[j0]);
    }
  }
  return arc;
};
function greatCircle(start, end, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var properties = options.properties;
  var npoints = options.npoints;
  var offset = options.offset;
  start = getCoord(start);
  end = getCoord(end);
  properties = properties || {};
  npoints = npoints || 100;
  offset = offset || 10;
  var generator = new GreatCircle(
    { x: start[0], y: start[1] },
    { x: end[0], y: end[1] },
    properties
  );
  var line = generator.Arc(npoints, { offset });
  return line.json();
}

// ../node_modules/.pnpm/@turf+intersect@7.1.0/node_modules/@turf/intersect/dist/esm/index.js
function intersect2(features, options = {}) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must specify at least 2 geometries");
  }
  const intersection3 = index.intersection(
    geoms[0],
    ...geoms.slice(1)
  );
  if (intersection3.length === 0)
    return null;
  if (intersection3.length === 1)
    return polygon(intersection3[0], options.properties);
  return multiPolygon(intersection3, options.properties);
}

// ../node_modules/.pnpm/@turf+hex-grid@7.1.0/node_modules/@turf/hex-grid/dist/esm/index.js
function hexGrid(bbox3, cellSide, options = {}) {
  const clonedProperties = JSON.stringify(options.properties || {});
  const [west, south, east, north] = bbox3;
  const centerY = (south + north) / 2;
  const centerX = (west + east) / 2;
  const xFraction = cellSide * 2 / distance([west, centerY], [east, centerY], options);
  const cellWidth = xFraction * (east - west);
  const yFraction = cellSide * 2 / distance([centerX, south], [centerX, north], options);
  const cellHeight = yFraction * (north - south);
  const radius = cellWidth / 2;
  const hex_width = radius * 2;
  const hex_height = Math.sqrt(3) / 2 * cellHeight;
  const box_width = east - west;
  const box_height = north - south;
  const x_interval = 3 / 4 * hex_width;
  const y_interval = hex_height;
  const x_span = (box_width - hex_width) / (hex_width - radius / 2);
  const x_count = Math.floor(x_span);
  const x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
  const y_count = Math.floor((box_height - hex_height) / hex_height);
  let y_adjust = (box_height - y_count * hex_height) / 2;
  const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
  if (hasOffsetY) {
    y_adjust -= hex_height / 4;
  }
  const cosines = [];
  const sines = [];
  for (let i = 0; i < 6; i++) {
    const angle2 = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle2));
    sines.push(Math.sin(angle2));
  }
  const results = [];
  for (let x2 = 0; x2 <= x_count; x2++) {
    for (let y2 = 0; y2 <= y_count; y2++) {
      const isOdd = x2 % 2 === 1;
      if (y2 === 0 && isOdd)
        continue;
      if (y2 === 0 && hasOffsetY)
        continue;
      const center_x = x2 * x_interval + west - x_adjust;
      let center_y = y2 * y_interval + south + y_adjust;
      if (isOdd) {
        center_y -= hex_height / 2;
      }
      if (options.triangles === true) {
        hexTriangles(
          [center_x, center_y],
          cellWidth / 2,
          cellHeight / 2,
          JSON.parse(clonedProperties),
          cosines,
          sines
        ).forEach(function(triangle) {
          if (options.mask) {
            if (intersect2(featureCollection([options.mask, triangle])))
              results.push(triangle);
          } else {
            results.push(triangle);
          }
        });
      } else {
        const hex = hexagon(
          [center_x, center_y],
          cellWidth / 2,
          cellHeight / 2,
          JSON.parse(clonedProperties),
          cosines,
          sines
        );
        if (options.mask) {
          if (intersect2(featureCollection([options.mask, hex])))
            results.push(hex);
        } else {
          results.push(hex);
        }
      }
    }
  }
  return featureCollection(results);
}
function hexagon(center2, rx, ry, properties, cosines, sines) {
  const vertices = [];
  for (let i = 0; i < 6; i++) {
    const x2 = center2[0] + rx * cosines[i];
    const y2 = center2[1] + ry * sines[i];
    vertices.push([x2, y2]);
  }
  vertices.push(vertices[0].slice());
  return polygon([vertices], properties);
}
function hexTriangles(center2, rx, ry, properties, cosines, sines) {
  const triangles = [];
  for (let i = 0; i < 6; i++) {
    const vertices = [];
    vertices.push(center2);
    vertices.push([center2[0] + rx * cosines[i], center2[1] + ry * sines[i]]);
    vertices.push([
      center2[0] + rx * cosines[(i + 1) % 6],
      center2[1] + ry * sines[(i + 1) % 6]
    ]);
    vertices.push(center2);
    triangles.push(polygon([vertices], properties));
  }
  return triangles;
}

// ../node_modules/.pnpm/@turf+point-grid@7.1.0/node_modules/@turf/point-grid/dist/esm/index.js
function pointGrid(bbox3, cellSide, options = {}) {
  if (options.mask && !options.units)
    options.units = "kilometers";
  var results = [];
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  var xFraction = cellSide / distance([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = cellSide / distance([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);
  var bboxWidth = east - west;
  var bboxHeight = north - south;
  var columns = Math.floor(bboxWidth / cellWidth);
  var rows = Math.floor(bboxHeight / cellHeight);
  var deltaX = (bboxWidth - columns * cellWidth) / 2;
  var deltaY = (bboxHeight - rows * cellHeight) / 2;
  var currentX = west + deltaX;
  while (currentX <= east) {
    var currentY = south + deltaY;
    while (currentY <= north) {
      var cellPt = point([currentX, currentY], options.properties);
      if (options.mask) {
        if (booleanWithin(cellPt, options.mask))
          results.push(cellPt);
      } else {
        results.push(cellPt);
      }
      currentY += cellHeight;
    }
    currentX += cellWidth;
  }
  return featureCollection(results);
}

// ../node_modules/.pnpm/@turf+rectangle-grid@7.1.0/node_modules/@turf/rectangle-grid/dist/esm/index.js
function rectangleGrid(bbox3, cellWidth, cellHeight, options = {}) {
  const results = [];
  const west = bbox3[0];
  const south = bbox3[1];
  const east = bbox3[2];
  const north = bbox3[3];
  const bboxWidth = east - west;
  const cellWidthDeg = convertLength(cellWidth, options.units, "degrees");
  const bboxHeight = north - south;
  const cellHeightDeg = convertLength(cellHeight, options.units, "degrees");
  const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);
  const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);
  const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
  const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
  let currentX = west + deltaX;
  for (let column = 0; column < columns; column++) {
    let currentY = south + deltaY;
    for (let row = 0; row < rows; row++) {
      const cellPoly = polygon(
        [
          [
            [currentX, currentY],
            [currentX, currentY + cellHeightDeg],
            [currentX + cellWidthDeg, currentY + cellHeightDeg],
            [currentX + cellWidthDeg, currentY],
            [currentX, currentY]
          ]
        ],
        options.properties
      );
      if (options.mask) {
        if (booleanIntersects(options.mask, cellPoly)) {
          results.push(cellPoly);
        }
      } else {
        results.push(cellPoly);
      }
      currentY += cellHeightDeg;
    }
    currentX += cellWidthDeg;
  }
  return featureCollection(results);
}

// ../node_modules/.pnpm/@turf+square-grid@7.1.0/node_modules/@turf/square-grid/dist/esm/index.js
function squareGrid(bbox3, cellSide, options = {}) {
  return rectangleGrid(bbox3, cellSide, cellSide, options);
}

// ../node_modules/.pnpm/@turf+triangle-grid@7.1.0/node_modules/@turf/triangle-grid/dist/esm/index.js
function triangleGrid(bbox3, cellSide, options = {}) {
  var results = [];
  var xFraction = cellSide / distance([bbox3[0], bbox3[1]], [bbox3[2], bbox3[1]], options);
  var cellWidth = xFraction * (bbox3[2] - bbox3[0]);
  var yFraction = cellSide / distance([bbox3[0], bbox3[1]], [bbox3[0], bbox3[3]], options);
  var cellHeight = yFraction * (bbox3[3] - bbox3[1]);
  var xi = 0;
  var currentX = bbox3[0];
  while (currentX <= bbox3[2]) {
    var yi = 0;
    var currentY = bbox3[1];
    while (currentY <= bbox3[3]) {
      var cellTriangle1 = null;
      var cellTriangle2 = null;
      if (xi % 2 === 0 && yi % 2 === 0) {
        cellTriangle1 = polygon(
          [
            [
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
        cellTriangle2 = polygon(
          [
            [
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY + cellHeight]
            ]
          ],
          options.properties
        );
      } else if (xi % 2 === 0 && yi % 2 === 1) {
        cellTriangle1 = polygon(
          [
            [
              [currentX, currentY],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
        cellTriangle2 = polygon(
          [
            [
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
      } else if (yi % 2 === 0 && xi % 2 === 1) {
        cellTriangle1 = polygon(
          [
            [
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
        cellTriangle2 = polygon(
          [
            [
              [currentX, currentY],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
      } else if (yi % 2 === 1 && xi % 2 === 1) {
        cellTriangle1 = polygon(
          [
            [
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]
          ],
          options.properties
        );
        cellTriangle2 = polygon(
          [
            [
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY + cellHeight]
            ]
          ],
          options.properties
        );
      }
      if (options.mask) {
        if (intersect2(featureCollection([options.mask, cellTriangle1])))
          results.push(cellTriangle1);
        if (intersect2(featureCollection([options.mask, cellTriangle2])))
          results.push(cellTriangle2);
      } else {
        results.push(cellTriangle1);
        results.push(cellTriangle2);
      }
      currentY += cellHeight;
      yi++;
    }
    xi++;
    currentX += cellWidth;
  }
  return featureCollection(results);
}

// ../node_modules/.pnpm/@turf+interpolate@7.1.0/node_modules/@turf/interpolate/dist/esm/index.js
function interpolate(points2, cellSize, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var gridType = options.gridType;
  var property = options.property;
  var weight = options.weight;
  if (!points2)
    throw new Error("points is required");
  collectionOf(points2, "Point", "input must contain Points");
  if (!cellSize)
    throw new Error("cellSize is required");
  if (weight !== void 0 && typeof weight !== "number")
    throw new Error("weight must be a number");
  property = property || "elevation";
  gridType = gridType || "square";
  weight = weight || 1;
  var box = bbox(points2);
  var grid;
  switch (gridType) {
    case "point":
    case "points":
      grid = pointGrid(box, cellSize, options);
      break;
    case "square":
    case "squares":
      grid = squareGrid(box, cellSize, options);
      break;
    case "hex":
    case "hexes":
      grid = hexGrid(box, cellSize, options);
      break;
    case "triangle":
    case "triangles":
      grid = triangleGrid(box, cellSize, options);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var results = [];
  featureEach(grid, function(gridFeature) {
    var zw = 0;
    var sw = 0;
    featureEach(points2, function(point2) {
      var gridPoint = gridType === "point" ? gridFeature : centroid(gridFeature);
      var d = distance(gridPoint, point2, options);
      var zValue;
      if (property !== void 0)
        zValue = point2.properties[property];
      if (zValue === void 0)
        zValue = point2.geometry.coordinates[2];
      if (zValue === void 0)
        throw new Error("zValue is missing");
      if (d === 0)
        zw = zValue;
      var w = 1 / Math.pow(d, weight);
      sw += w;
      zw += w * zValue;
    });
    var newFeature = clone(gridFeature);
    newFeature.properties[property] = zw / sw;
    results.push(newFeature);
  });
  return featureCollection(results);
}

// ../node_modules/.pnpm/marchingsquares@1.3.3/node_modules/marchingsquares/dist/marchingsquares-esm.js
function linear(a, b, v2) {
  if (a < b)
    return (v2 - a) / (b - a);
  return (a - v2) / (a - b);
}
function linear_ab(a, b, v0, v1) {
  var tmp;
  if (v0 > v1) {
    tmp = v0;
    v0 = v1;
    v1 = tmp;
  }
  if (a < b) {
    if (a < v0)
      return (v0 - a) / (b - a);
    else
      return (v1 - a) / (b - a);
  } else if (a > v1) {
    return (a - v1) / (a - b);
  }
  return (a - v0) / (a - b);
}
function linear_a(a, b, minV, maxV) {
  if (a < b)
    return (minV - a) / (b - a);
  return (a - maxV) / (a - b);
}
function linear_b(a, b, minV, maxV) {
  if (a < b)
    return (maxV - a) / (b - a);
  return (a - minV) / (a - b);
}
function Options() {
  this.successCallback = null;
  this.verbose = false;
  this.polygons = false;
  this.polygons_full = false;
  this.linearRing = true;
  this.noQuadTree = false;
  this.noFrame = false;
}
function isoBandOptions(userSettings) {
  var i, key, val, bandOptions, optionKeys;
  bandOptions = new Options();
  userSettings = userSettings ? userSettings : {};
  optionKeys = Object.keys(bandOptions);
  for (i = 0; i < optionKeys.length; i++) {
    key = optionKeys[i];
    val = userSettings[key];
    if (typeof val !== "undefined" && val !== null)
      bandOptions[key] = val;
  }
  bandOptions.polygons_full = !bandOptions.polygons;
  bandOptions.interpolate = linear_ab;
  bandOptions.interpolate_a = linear_a;
  bandOptions.interpolate_b = linear_b;
  return bandOptions;
}
function isoLineOptions(userSettings) {
  var i, key, val, lineOptions, optionKeys;
  lineOptions = new Options();
  userSettings = userSettings ? userSettings : {};
  optionKeys = Object.keys(lineOptions);
  for (i = 0; i < optionKeys.length; i++) {
    key = optionKeys[i];
    val = userSettings[key];
    if (typeof val !== "undefined" && val !== null)
      lineOptions[key] = val;
  }
  lineOptions.polygons_full = !lineOptions.polygons;
  lineOptions.interpolate = linear;
  return lineOptions;
}
function cell2Polygons(cell, x2, y2, settings) {
  var polygons2 = [];
  cell.polygons.forEach(function(p) {
    p.forEach(function(pp) {
      pp[0] += x2;
      pp[1] += y2;
    });
    if (settings.linearRing)
      p.push(p[0]);
    polygons2.push(p);
  });
  return polygons2;
}
function entry_coordinate(x2, y2, mode, path) {
  if (mode === 0) {
    x2 += 1;
    y2 += path[0][1];
  } else if (mode === 1) {
    x2 += path[0][0];
  } else if (mode === 2) {
    y2 += path[0][1];
  } else if (mode === 3) {
    x2 += path[0][0];
    y2 += 1;
  }
  return [x2, y2];
}
function skip_coordinate(x2, y2, mode) {
  if (mode === 0) {
    x2++;
  } else if (mode === 1) ;
  else if (mode === 2) {
    y2++;
  } else if (mode === 3) {
    x2++;
    y2++;
  }
  return [x2, y2];
}
function requireFrame(data, lowerBound, upperBound) {
  var frameRequired, cols, rows, i, j;
  frameRequired = true;
  cols = data[0].length;
  rows = data.length;
  for (j = 0; j < rows; j++) {
    if (data[j][0] < lowerBound || data[j][0] > upperBound || data[j][cols - 1] < lowerBound || data[j][cols - 1] > upperBound) {
      frameRequired = false;
      break;
    }
  }
  if (frameRequired && (data[rows - 1][0] < lowerBound || data[rows - 1][0] > upperBound || data[rows - 1][cols - 1] < lowerBound || data[rows - 1][cols - 1] > upperBound)) {
    frameRequired = false;
  }
  if (frameRequired)
    for (i = 0; i < cols - 1; i++) {
      if (data[0][i] < lowerBound || data[0][i] > upperBound || data[rows - 1][i] < lowerBound || data[rows - 1][i] > upperBound) {
        frameRequired = false;
        break;
      }
    }
  return frameRequired;
}
function requireLineFrame(data, threshold) {
  var frameRequired, cols, rows, i, j;
  frameRequired = true;
  cols = data[0].length;
  rows = data.length;
  for (j = 0; j < rows; j++) {
    if (data[j][0] >= threshold || data[j][cols - 1] >= threshold) {
      frameRequired = false;
      break;
    }
  }
  if (frameRequired && (data[rows - 1][0] >= threshold || data[rows - 1][cols - 1] >= threshold)) {
    frameRequired = false;
  }
  if (frameRequired)
    for (i = 0; i < cols - 1; i++) {
      if (data[0][i] >= threshold || data[rows - 1][i] > threshold) {
        frameRequired = false;
        break;
      }
    }
  return frameRequired;
}
function traceBandPaths(data, cellGrid, settings) {
  var nextedge, path, e, ee, s, ve, enter, x2, y2, finalized, origin, cc2, dir, count, point2, found_entry;
  var polygons2 = [];
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var valid_entries = [
    ["rt", "rb"],
    /* down */
    ["br", "bl"],
    /* left */
    ["lb", "lt"],
    /* up */
    ["tl", "tr"]
    /* right */
  ];
  var add_x = [0, -1, 0, 1];
  var add_y = [-1, 0, 1, 0];
  var available_starts = ["bl", "lb", "lt", "tl", "tr", "rt", "rb", "br"];
  var entry_dir = {
    bl: 1,
    br: 1,
    lb: 2,
    lt: 2,
    tl: 3,
    tr: 3,
    rt: 0,
    rb: 0
  };
  if (requireFrame(data, settings.minV, settings.maxV)) {
    if (settings.linearRing)
      polygons2.push([[0, 0], [0, rows], [cols, rows], [cols, 0], [0, 0]]);
    else
      polygons2.push([[0, 0], [0, rows], [cols, rows], [cols, 0]]);
  }
  cellGrid.forEach(function(a, i) {
    a.forEach(function(cell, j) {
      nextedge = null;
      for (e = 0; e < 8; e++) {
        nextedge = available_starts[e];
        if (typeof cell.edges[nextedge] !== "object")
          continue;
        path = [];
        ee = cell.edges[nextedge];
        enter = nextedge;
        x2 = i;
        y2 = j;
        finalized = false;
        origin = [i + ee.path[0][0], j + ee.path[0][1]];
        path.push(origin);
        while (!finalized) {
          cc2 = cellGrid[x2][y2];
          if (typeof cc2.edges[enter] !== "object")
            break;
          ee = cc2.edges[enter];
          delete cc2.edges[enter];
          point2 = ee.path[1];
          point2[0] += x2;
          point2[1] += y2;
          path.push(point2);
          enter = ee.move.enter;
          x2 = x2 + ee.move.x;
          y2 = y2 + ee.move.y;
          if (typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined") {
            dir = 0;
            count = 0;
            if (x2 === cols) {
              x2--;
              dir = 0;
            } else if (x2 < 0) {
              x2++;
              dir = 2;
            } else if (y2 === rows) {
              y2--;
              dir = 3;
            } else if (y2 < 0) {
              y2++;
              dir = 1;
            } else {
              throw new Error("Left the grid somewhere in the interior!");
            }
            if (x2 === i && y2 === j && dir === entry_dir[nextedge]) {
              finalized = true;
              enter = nextedge;
              break;
            }
            while (1) {
              found_entry = false;
              if (count > 4)
                throw new Error("Direction change counter overflow! This should never happen!");
              if (!(typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined")) {
                cc2 = cellGrid[x2][y2];
                for (s = 0; s < valid_entries[dir].length; s++) {
                  ve = valid_entries[dir][s];
                  if (typeof cc2.edges[ve] === "object") {
                    ee = cc2.edges[ve];
                    path.push(entry_coordinate(x2, y2, dir, ee.path));
                    enter = ve;
                    found_entry = true;
                    break;
                  }
                }
              }
              if (found_entry) {
                break;
              } else {
                path.push(skip_coordinate(x2, y2, dir));
                x2 += add_x[dir];
                y2 += add_y[dir];
                if (typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined") {
                  if (dir === 0 && y2 < 0 || dir === 1 && x2 < 0 || dir === 2 && y2 === rows || dir === 3 && x2 === cols) {
                    x2 -= add_x[dir];
                    y2 -= add_y[dir];
                    dir = (dir + 1) % 4;
                    count++;
                  }
                }
                if (x2 === i && y2 === j && dir === entry_dir[nextedge]) {
                  finalized = true;
                  enter = nextedge;
                  break;
                }
              }
            }
          }
        }
        if (settings.linearRing && (path[path.length - 1][0] !== origin[0] || path[path.length - 1][1] !== origin[1]))
          path.push(origin);
        polygons2.push(path);
      }
    });
  });
  return polygons2;
}
function traceLinePaths(data, cellGrid, settings) {
  var nextedge, e, ee, cc2, path, enter, x2, y2, finalized, origin, point2, dir, count, found_entry, ve;
  var polygons2 = [];
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var valid_entries = [
    "right",
    /* down */
    "bottom",
    /* left */
    "left",
    /* up */
    "top"
    /* right */
  ];
  var add_x = [0, -1, 0, 1];
  var add_y = [-1, 0, 1, 0];
  var entry_dir = {
    bottom: 1,
    left: 2,
    top: 3,
    right: 0
  };
  if (!settings.noFrame) {
    if (requireLineFrame(data, settings.threshold)) {
      if (settings.linearRing)
        polygons2.push([[0, 0], [0, rows], [cols, rows], [cols, 0], [0, 0]]);
      else
        polygons2.push([[0, 0], [0, rows], [cols, rows], [cols, 0]]);
    }
  }
  cellGrid.forEach(function(a, i) {
    a.forEach(function(cell, j) {
      nextedge = null;
      for (e = 0; e < 4; e++) {
        nextedge = valid_entries[e];
        if (typeof cell.edges[nextedge] !== "object")
          continue;
        path = [];
        ee = cell.edges[nextedge];
        enter = nextedge;
        x2 = i;
        y2 = j;
        finalized = false;
        origin = [i + ee.path[0][0], j + ee.path[0][1]];
        path.push(origin);
        while (!finalized) {
          cc2 = cellGrid[x2][y2];
          if (typeof cc2.edges[enter] !== "object")
            break;
          ee = cc2.edges[enter];
          delete cc2.edges[enter];
          point2 = ee.path[1];
          point2[0] += x2;
          point2[1] += y2;
          path.push(point2);
          enter = ee.move.enter;
          x2 = x2 + ee.move.x;
          y2 = y2 + ee.move.y;
          if (typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined") {
            if (!settings.linearRing)
              break;
            dir = 0;
            count = 0;
            if (x2 === cols) {
              x2--;
              dir = 0;
            } else if (x2 < 0) {
              x2++;
              dir = 2;
            } else if (y2 === rows) {
              y2--;
              dir = 3;
            } else if (y2 < 0) {
              y2++;
              dir = 1;
            }
            if (x2 === i && y2 === j && dir === entry_dir[nextedge]) {
              finalized = true;
              enter = nextedge;
              break;
            }
            while (1) {
              found_entry = false;
              if (count > 4)
                throw new Error("Direction change counter overflow! This should never happen!");
              if (!(typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined")) {
                cc2 = cellGrid[x2][y2];
                ve = valid_entries[dir];
                if (typeof cc2.edges[ve] === "object") {
                  ee = cc2.edges[ve];
                  path.push(entry_coordinate(x2, y2, dir, ee.path));
                  enter = ve;
                  found_entry = true;
                  break;
                }
              }
              if (found_entry) {
                break;
              } else {
                path.push(skip_coordinate(x2, y2, dir));
                x2 += add_x[dir];
                y2 += add_y[dir];
                if (typeof cellGrid[x2] === "undefined" || typeof cellGrid[x2][y2] === "undefined") {
                  if (dir === 0 && y2 < 0 || dir === 1 && x2 < 0 || dir === 2 && y2 === rows || dir === 3 && x2 === cols) {
                    x2 -= add_x[dir];
                    y2 -= add_y[dir];
                    dir = (dir + 1) % 4;
                    count++;
                  }
                }
                if (x2 === i && y2 === j && dir === entry_dir[nextedge]) {
                  finalized = true;
                  enter = nextedge;
                  break;
                }
              }
            }
          }
        }
        if (settings.linearRing && (path[path.length - 1][0] !== origin[0] || path[path.length - 1][1] !== origin[1]))
          path.push(origin);
        polygons2.push(path);
      }
    });
  });
  return polygons2;
}
function TreeNode(data, x2, y2, dx, dy) {
  var dx_tmp = dx, dy_tmp = dy, msb_x = 0, msb_y = 0;
  this.x = x2;
  this.y = y2;
  this.lowerBound = null;
  this.upperBound = null;
  this.childA = null;
  this.childB = null;
  this.childC = null;
  this.childD = null;
  if (dx === 1 && dy === 1) {
    this.lowerBound = Math.min(
      data[y2][x2],
      data[y2][x2 + 1],
      data[y2 + 1][x2 + 1],
      data[y2 + 1][x2]
    );
    this.upperBound = Math.max(
      data[y2][x2],
      data[y2][x2 + 1],
      data[y2 + 1][x2 + 1],
      data[y2 + 1][x2]
    );
  } else {
    if (dx > 1) {
      while (dx_tmp !== 0) {
        dx_tmp = dx_tmp >> 1;
        msb_x++;
      }
      if (dx === 1 << msb_x - 1)
        msb_x--;
      dx_tmp = 1 << msb_x - 1;
    }
    if (dy > 1) {
      while (dy_tmp !== 0) {
        dy_tmp = dy_tmp >> 1;
        msb_y++;
      }
      if (dy === 1 << msb_y - 1)
        msb_y--;
      dy_tmp = 1 << msb_y - 1;
    }
    this.childA = new TreeNode(data, x2, y2, dx_tmp, dy_tmp);
    this.lowerBound = this.childA.lowerBound;
    this.upperBound = this.childA.upperBound;
    if (dx - dx_tmp > 0) {
      this.childB = new TreeNode(data, x2 + dx_tmp, y2, dx - dx_tmp, dy_tmp);
      this.lowerBound = Math.min(this.lowerBound, this.childB.lowerBound);
      this.upperBound = Math.max(this.upperBound, this.childB.upperBound);
      if (dy - dy_tmp > 0) {
        this.childC = new TreeNode(data, x2 + dx_tmp, y2 + dy_tmp, dx - dx_tmp, dy - dy_tmp);
        this.lowerBound = Math.min(this.lowerBound, this.childC.lowerBound);
        this.upperBound = Math.max(this.upperBound, this.childC.upperBound);
      }
    }
    if (dy - dy_tmp > 0) {
      this.childD = new TreeNode(data, x2, y2 + dy_tmp, dx_tmp, dy - dy_tmp);
      this.lowerBound = Math.min(this.lowerBound, this.childD.lowerBound);
      this.upperBound = Math.max(this.upperBound, this.childD.upperBound);
    }
  }
}
TreeNode.prototype.cellsInBand = function(lowerBound, upperBound, subsumed) {
  var cells2 = [];
  subsumed = typeof subsumed === "undefined" ? true : subsumed;
  if (this.lowerBound > upperBound || this.upperBound < lowerBound)
    return cells2;
  if (!(this.childA || this.childB || this.childC || this.childD)) {
    if (subsumed || this.lowerBound <= lowerBound || this.upperBound >= upperBound) {
      cells2.push({
        x: this.x,
        y: this.y
      });
    }
  } else {
    if (this.childA)
      cells2 = cells2.concat(this.childA.cellsInBand(lowerBound, upperBound, subsumed));
    if (this.childB)
      cells2 = cells2.concat(this.childB.cellsInBand(lowerBound, upperBound, subsumed));
    if (this.childD)
      cells2 = cells2.concat(this.childD.cellsInBand(lowerBound, upperBound, subsumed));
    if (this.childC)
      cells2 = cells2.concat(this.childC.cellsInBand(lowerBound, upperBound, subsumed));
  }
  return cells2;
};
TreeNode.prototype.cellsBelowThreshold = function(threshold, subsumed) {
  var cells2 = [];
  subsumed = typeof subsumed === "undefined" ? true : subsumed;
  if (this.lowerBound > threshold)
    return cells2;
  if (!(this.childA || this.childB || this.childC || this.childD)) {
    if (subsumed || this.upperBound >= threshold) {
      cells2.push({
        x: this.x,
        y: this.y
      });
    }
  } else {
    if (this.childA)
      cells2 = cells2.concat(this.childA.cellsBelowThreshold(threshold, subsumed));
    if (this.childB)
      cells2 = cells2.concat(this.childB.cellsBelowThreshold(threshold, subsumed));
    if (this.childD)
      cells2 = cells2.concat(this.childD.cellsBelowThreshold(threshold, subsumed));
    if (this.childC)
      cells2 = cells2.concat(this.childC.cellsBelowThreshold(threshold, subsumed));
  }
  return cells2;
};
function QuadTree(data) {
  var i, cols;
  if (!data)
    throw new Error("data is required");
  if (!Array.isArray(data) || !Array.isArray(data[0]))
    throw new Error("data must be scalar field, i.e. array of arrays");
  if (data.length < 2)
    throw new Error("data must contain at least two rows");
  cols = data[0].length;
  if (cols < 2)
    throw new Error("data must contain at least two columns");
  for (i = 1; i < data.length; i++) {
    if (!Array.isArray(data[i]))
      throw new Error("Row " + i + " is not an array");
    if (data[i].length != cols)
      throw new Error("unequal row lengths detected, please provide a regular grid");
  }
  this.data = data;
  this.root = new TreeNode(data, 0, 0, data[0].length - 1, data.length - 1);
}
function isoLines(input, threshold, options) {
  var settings, i, j, useQuadTree = false, multiLine = false, tree = null, root = null, data = null, cellGrid = null, linePolygons = null, ret = [];
  if (!input) throw new Error("data is required");
  if (threshold === void 0 || threshold === null) throw new Error("threshold is required");
  if (!!options && typeof options !== "object") throw new Error("options must be an object");
  settings = isoLineOptions(options);
  if (input instanceof QuadTree) {
    tree = input;
    root = input.root;
    data = input.data;
    if (!settings.noQuadTree)
      useQuadTree = true;
  } else if (Array.isArray(input) && Array.isArray(input[0])) {
    data = input;
  } else {
    throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");
  }
  if (Array.isArray(threshold)) {
    multiLine = true;
    if (!settings.noQuadTree)
      useQuadTree = true;
    for (i = 0; i < threshold.length; i++)
      if (isNaN(+threshold[i]))
        throw new Error("threshold[" + i + "] is not a number");
  } else {
    if (isNaN(+threshold))
      throw new Error("threshold must be a number or array of numbers");
    threshold = [threshold];
  }
  if (useQuadTree && !root) {
    tree = new QuadTree(data);
    root = tree.root;
    data = tree.data;
  }
  if (settings.verbose) {
    if (settings.polygons)
      console.log("MarchingSquaresJS-isoLines: returning single lines (polygons) for each grid cell");
    else
      console.log("MarchingSquaresJS-isoLines: returning line paths (polygons) for entire data grid");
    if (multiLine)
      console.log("MarchingSquaresJS-isoLines: multiple lines requested, returning array of line paths instead of lines for a single threshold");
  }
  threshold.forEach(function(t, i2) {
    linePolygons = [];
    settings.threshold = t;
    if (settings.verbose)
      console.log("MarchingSquaresJS-isoLines: computing iso lines for threshold " + t);
    if (settings.polygons) {
      if (useQuadTree) {
        root.cellsBelowThreshold(settings.threshold, true).forEach(function(c) {
          linePolygons = linePolygons.concat(
            cell2Polygons(
              prepareCell(
                data,
                c.x,
                c.y,
                settings
              ),
              c.x,
              c.y,
              settings
            )
          );
        });
      } else {
        for (j = 0; j < data.length - 1; ++j) {
          for (i2 = 0; i2 < data[0].length - 1; ++i2)
            linePolygons = linePolygons.concat(
              cell2Polygons(
                prepareCell(
                  data,
                  i2,
                  j,
                  settings
                ),
                i2,
                j,
                settings
              )
            );
        }
      }
    } else {
      cellGrid = [];
      for (i2 = 0; i2 < data[0].length - 1; ++i2)
        cellGrid[i2] = [];
      if (useQuadTree) {
        root.cellsBelowThreshold(settings.threshold, false).forEach(function(c) {
          cellGrid[c.x][c.y] = prepareCell(
            data,
            c.x,
            c.y,
            settings
          );
        });
      } else {
        for (i2 = 0; i2 < data[0].length - 1; ++i2) {
          for (j = 0; j < data.length - 1; ++j) {
            cellGrid[i2][j] = prepareCell(
              data,
              i2,
              j,
              settings
            );
          }
        }
      }
      linePolygons = traceLinePaths(data, cellGrid, settings);
    }
    if (multiLine)
      ret.push(linePolygons);
    else
      ret = linePolygons;
    if (typeof settings.successCallback === "function")
      settings.successCallback(ret, t);
  });
  return ret;
}
function prepareCell(grid, x2, y2, settings) {
  var left, right, top, bottom, average, cell;
  var cval = 0;
  var x3 = grid[y2 + 1][x2];
  var x22 = grid[y2 + 1][x2 + 1];
  var x12 = grid[y2][x2 + 1];
  var x02 = grid[y2][x2];
  var threshold = settings.threshold;
  if (isNaN(x02) || isNaN(x12) || isNaN(x22) || isNaN(x3)) {
    return;
  }
  cval |= x3 >= threshold ? 8 : 0;
  cval |= x22 >= threshold ? 4 : 0;
  cval |= x12 >= threshold ? 2 : 0;
  cval |= x02 >= threshold ? 1 : 0;
  cval = +cval;
  cell = {
    cval,
    polygons: [],
    edges: {},
    x0: x02,
    x1: x12,
    x2: x22,
    x3
  };
  switch (cval) {
    case 0:
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]);
      break;
    case 15:
      break;
    case 14:
      left = settings.interpolate(x02, x3, threshold);
      bottom = settings.interpolate(x02, x12, threshold);
      if (settings.polygons_full) {
        cell.edges.left = {
          path: [[0, left], [bottom, 0]],
          move: {
            x: 0,
            y: -1,
            enter: "top"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, left], [bottom, 0]]);
      break;
    case 13:
      bottom = settings.interpolate(x02, x12, threshold);
      right = settings.interpolate(x12, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.bottom = {
          path: [[bottom, 0], [1, right]],
          move: {
            x: 1,
            y: 0,
            enter: "left"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[bottom, 0], [1, right], [1, 0]]);
      break;
    case 11:
      right = settings.interpolate(x12, x22, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.right = {
          path: [[1, right], [top, 1]],
          move: {
            x: 0,
            y: 1,
            enter: "bottom"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[1, right], [top, 1], [1, 1]]);
      break;
    case 7:
      left = settings.interpolate(x02, x3, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.top = {
          path: [[top, 1], [0, left]],
          move: {
            x: -1,
            y: 0,
            enter: "right"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[top, 1], [0, left], [0, 1]]);
      break;
    case 1:
      left = settings.interpolate(x02, x3, threshold);
      bottom = settings.interpolate(x02, x12, threshold);
      if (settings.polygons_full) {
        cell.edges.bottom = {
          path: [[bottom, 0], [0, left]],
          move: {
            x: -1,
            y: 0,
            enter: "right"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[bottom, 0], [0, left], [0, 1], [1, 1], [1, 0]]);
      break;
    case 2:
      bottom = settings.interpolate(x02, x12, threshold);
      right = settings.interpolate(x12, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.right = {
          path: [[1, right], [bottom, 0]],
          move: {
            x: 0,
            y: -1,
            enter: "top"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, right], [bottom, 0]]);
      break;
    case 4:
      right = settings.interpolate(x12, x22, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.top = {
          path: [[top, 1], [1, right]],
          move: {
            x: 1,
            y: 0,
            enter: "left"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, 1], [top, 1], [1, right], [1, 0]]);
      break;
    case 8:
      left = settings.interpolate(x02, x3, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.left = {
          path: [[0, left], [top, 1]],
          move: {
            x: 0,
            y: 1,
            enter: "bottom"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, left], [top, 1], [1, 1], [1, 0]]);
      break;
    case 12:
      left = settings.interpolate(x02, x3, threshold);
      right = settings.interpolate(x12, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.left = {
          path: [[0, left], [1, right]],
          move: {
            x: 1,
            y: 0,
            enter: "left"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, left], [1, right], [1, 0]]);
      break;
    case 9:
      bottom = settings.interpolate(x02, x12, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.bottom = {
          path: [[bottom, 0], [top, 1]],
          move: {
            x: 0,
            y: 1,
            enter: "bottom"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[bottom, 0], [top, 1], [1, 1], [1, 0]]);
      break;
    case 3:
      left = settings.interpolate(x02, x3, threshold);
      right = settings.interpolate(x12, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.right = {
          path: [[1, right], [0, left]],
          move: {
            x: -1,
            y: 0,
            enter: "right"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, left], [0, 1], [1, 1], [1, right]]);
      break;
    case 6:
      bottom = settings.interpolate(x02, x12, threshold);
      top = settings.interpolate(x3, x22, threshold);
      if (settings.polygons_full) {
        cell.edges.top = {
          path: [[top, 1], [bottom, 0]],
          move: {
            x: 0,
            y: -1,
            enter: "top"
          }
        };
      }
      if (settings.polygons)
        cell.polygons.push([[0, 0], [0, 1], [top, 1], [bottom, 0]]);
      break;
    case 10:
      left = settings.interpolate(x02, x3, threshold);
      right = settings.interpolate(x12, x22, threshold);
      bottom = settings.interpolate(x02, x12, threshold);
      top = settings.interpolate(x3, x22, threshold);
      average = (x02 + x12 + x22 + x3) / 4;
      if (settings.polygons_full) {
        if (average < threshold) {
          cell.edges.left = {
            path: [[0, left], [top, 1]],
            move: {
              x: 0,
              y: 1,
              enter: "bottom"
            }
          };
          cell.edges.right = {
            path: [[1, right], [bottom, 0]],
            move: {
              x: 0,
              y: -1,
              enter: "top"
            }
          };
        } else {
          cell.edges.right = {
            path: [[1, right], [top, 1]],
            move: {
              x: 0,
              y: 1,
              enter: "bottom"
            }
          };
          cell.edges.left = {
            path: [[0, left], [bottom, 0]],
            move: {
              x: 0,
              y: -1,
              enter: "top"
            }
          };
        }
      }
      if (settings.polygons) {
        if (average < threshold) {
          cell.polygons.push([[0, 0], [0, left], [top, 1], [1, 1], [1, right], [bottom, 0]]);
        } else {
          cell.polygons.push([[0, 0], [0, left], [bottom, 0]]);
          cell.polygons.push([[top, 1], [1, 1], [1, right]]);
        }
      }
      break;
    case 5:
      left = settings.interpolate(x02, x3, threshold);
      right = settings.interpolate(x12, x22, threshold);
      bottom = settings.interpolate(x02, x12, threshold);
      top = settings.interpolate(x3, x22, threshold);
      average = (x02 + x12 + x22 + x3) / 4;
      if (settings.polygons_full) {
        if (average < threshold) {
          cell.edges.bottom = {
            path: [[bottom, 0], [0, left]],
            move: {
              x: -1,
              y: 0,
              enter: "right"
            }
          };
          cell.edges.top = {
            path: [[top, 1], [1, right]],
            move: {
              x: 1,
              y: 0,
              enter: "left"
            }
          };
        } else {
          cell.edges.top = {
            path: [[top, 1], [0, left]],
            move: {
              x: -1,
              y: 0,
              enter: "right"
            }
          };
          cell.edges.bottom = {
            path: [[bottom, 0], [1, right]],
            move: {
              x: 1,
              y: 0,
              enter: "left"
            }
          };
        }
      }
      if (settings.polygons) {
        if (average < threshold) {
          cell.polygons.push([[0, left], [0, 1], [top, 1], [1, right], [1, 0], [bottom, 0]]);
        } else {
          cell.polygons.push([[0, left], [0, 1], [top, 1]]);
          cell.polygons.push([[bottom, 0], [1, right], [1, 0]]);
        }
      }
      break;
  }
  return cell;
}
var shapeCoordinates = {
  square: function(cell, x02, x12, x2, x3, opt) {
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]);
  },
  triangle_bl: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, leftbottom], [bottomleft, 0], [0, 0]]);
  },
  triangle_br: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [1, rightbottom], [1, 0]]);
  },
  triangle_tr: function(cell, x02, x12, x2, x3, opt) {
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.rt = {
        path: [[1, righttop], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[1, righttop], [topright, 1], [1, 1]]);
  },
  triangle_tl: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tl = {
        path: [[topleft, 1], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1]]);
  },
  tetragon_t: function(cell, x02, x12, x2, x3, opt) {
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.rt = {
        path: [[1, righttop], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, lefttop], [0, 1], [1, 1], [1, righttop]]);
  },
  tetragon_r: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [topright, 1], [1, 1], [1, 0]]);
  },
  tetragon_b: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [1, rightbottom], [1, 0]]);
  },
  tetragon_l: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tl = {
        path: [[topleft, 1], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [bottomleft, 0]]);
  },
  tetragon_bl: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [bottomright, 0]]);
  },
  tetragon_br: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [1, righttop], [1, rightbottom], [bottomright, 0]]);
  },
  tetragon_tr: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.rb = {
        path: [[1, rightbottom], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[1, rightbottom], [topleft, 1], [topright, 1], [1, righttop]]);
  },
  tetragon_tl: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tr = {
        path: [[topright, 1], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[topright, 1], [0, leftbottom], [0, lefttop], [topleft, 1]]);
  },
  tetragon_lr: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lt = {
        path: [[0, lefttop], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, leftbottom], [0, lefttop], [1, righttop], [1, rightbottom]]);
  },
  tetragon_tb: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tr = {
        path: [[topright, 1], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
      cell.edges.bl = {
        path: [[bottomleft, 0], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [topleft, 1], [topright, 1], [bottomright, 0]]);
  },
  pentagon_tr: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tl = {
        path: [[topleft, 1], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [1, rightbottom], [1, 0]]);
  },
  pentagon_tl: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [topright, 1], [1, 1], [1, 0]]);
  },
  pentagon_br: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.rt = {
        path: [[1, righttop], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, righttop], [bottomleft, 0]]);
  },
  pentagon_bl: function(cell, x02, x12, x2, x3, opt) {
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, lefttop], [0, 1], [1, 1], [1, 0], [bottomright, 0]]);
  },
  pentagon_tr_rl: function(cell, x02, x12, x2, x3, opt) {
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tl = {
        path: [[topleft, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom]]);
  },
  pentagon_rb_bt: function(cell, x02, x12, x2, x3, opt) {
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.rt = {
        path: [[1, righttop], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
      cell.edges.bl = {
        path: [[bottomleft, 0], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[topright, 1], [1, 1], [1, righttop], [bottomright, 0], [bottomleft, 0]]);
  },
  pentagon_bl_lr: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [1, rightbottom], [1, 0]]);
  },
  pentagon_lt_tb: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [bottomleft, 0]]);
  },
  pentagon_bl_tb: function(cell, x02, x12, x2, x3, opt) {
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
      cell.edges.tl = {
        path: [[topleft, 1], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1], [bottomright, 0], [bottomleft, 0]]);
  },
  pentagon_lt_rl: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate(x12, x3, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lt = {
        path: [[0, lefttop], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
      cell.edges.rt = {
        path: [[1, righttop], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, righttop]]);
  },
  pentagon_tr_bt: function(cell, x02, x12, x2, x3, opt) {
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[topleft, 1], [topright, 1], [1, rightbottom], [1, 0], [bottomright, 0]]);
  },
  pentagon_rb_lr: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [1, righttop], [1, rightbottom], [bottomleft, 0]]);
  },
  hexagon_lt_tr: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [1, rightbottom], [1, 0]]);
  },
  hexagon_bl_lt: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, 0]]);
  },
  hexagon_bl_rb: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
      cell.edges.rt = {
        path: [[1, righttop], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [0, lefttop], [0, 1], [1, 1], [1, righttop], [bottomright, 0]]);
  },
  hexagon_tr_rb: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.tl = {
        path: [[topleft, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom], [bottomleft, 0]]);
  },
  hexagon_lt_rb: function(cell, x02, x12, x2, x3, opt) {
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
      cell.edges.rt = {
        path: [[1, righttop], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [topright, 1], [1, 1], [1, righttop], [bottomleft, 0]]);
  },
  hexagon_bl_tr: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
      cell.edges.tl = {
        path: [[topleft, 1], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [0, lefttop], [0, 1], [topleft, 1], [1, rightbottom], [1, 0]]);
  },
  heptagon_tr: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [topright, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "br"
        }
      };
      cell.edges.rt = {
        path: [[1, righttop], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, righttop], [bottomright, 0]]);
  },
  heptagon_bl: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.lb = {
        path: [[0, leftbottom], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomleft, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tl"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [1, righttop], [1, rightbottom], [bottomleft, 0]]);
  },
  heptagon_tl: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var lefttop = opt.interpolate(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, lefttop]],
        move: {
          x: -1,
          y: 0,
          enter: "rt"
        }
      };
      cell.edges.tl = {
        path: [[topleft, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [0, lefttop], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom], [bottomright, 0]]);
  },
  heptagon_br: function(cell, x02, x12, x2, x3, opt) {
    var bottomright = opt.interpolate(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.br = {
        path: [[bottomright, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, rightbottom]],
        move: {
          x: 1,
          y: 0,
          enter: "lb"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [topleft, 1], [topright, 1], [1, rightbottom], [1, 0]]);
  },
  octagon: function(cell, x02, x12, x2, x3, opt) {
    var bottomleft = opt.interpolate_a(x02, x12, opt.minV, opt.maxV);
    var bottomright = opt.interpolate_b(x02, x12, opt.minV, opt.maxV);
    var leftbottom = opt.interpolate_a(x02, x3, opt.minV, opt.maxV);
    var lefttop = opt.interpolate_b(x02, x3, opt.minV, opt.maxV);
    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);
    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);
    var righttop = opt.interpolate_b(x12, x2, opt.minV, opt.maxV);
    var rightbottom = opt.interpolate_a(x12, x2, opt.minV, opt.maxV);
    if (opt.polygons_full) {
      cell.edges.bl = {
        path: [[bottomleft, 0], [0, leftbottom]],
        move: {
          x: -1,
          y: 0,
          enter: "rb"
        }
      };
      cell.edges.lt = {
        path: [[0, lefttop], [topleft, 1]],
        move: {
          x: 0,
          y: 1,
          enter: "bl"
        }
      };
      cell.edges.tr = {
        path: [[topright, 1], [1, righttop]],
        move: {
          x: 1,
          y: 0,
          enter: "lt"
        }
      };
      cell.edges.rb = {
        path: [[1, rightbottom], [bottomright, 0]],
        move: {
          x: 0,
          y: -1,
          enter: "tr"
        }
      };
    }
    if (opt.polygons)
      cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [topleft, 1], [topright, 1], [1, righttop], [1, rightbottom], [bottomright, 0]]);
  }
};
function isoBands(input, minV, bandWidth, options) {
  var i, j, settings, useQuadTree = false, tree = null, root = null, data = null, cellGrid = null, multiBand = false, bw = [], bandPolygons = [], ret = [];
  if (!input) throw new Error("data is required");
  if (minV === void 0 || minV === null) throw new Error("lowerBound is required");
  if (bandWidth === void 0 || bandWidth === null) throw new Error("bandWidth is required");
  if (!!options && typeof options !== "object") throw new Error("options must be an object");
  settings = isoBandOptions(options);
  if (input instanceof QuadTree) {
    tree = input;
    root = input.root;
    data = input.data;
    if (!settings.noQuadTree)
      useQuadTree = true;
  } else if (Array.isArray(input) && Array.isArray(input[0])) {
    data = input;
  } else {
    throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");
  }
  if (Array.isArray(minV)) {
    multiBand = true;
    if (!settings.noQuadTree)
      useQuadTree = true;
    for (i = 0; i < minV.length; i++)
      if (isNaN(+minV[i]))
        throw new Error("lowerBound[" + i + "] is not a number");
    if (Array.isArray(bandWidth)) {
      if (minV.length !== bandWidth.length)
        throw new Error("lowerBound and bandWidth have unequal lengths");
      for (i = 0; i < bandWidth.length; i++)
        if (isNaN(+bandWidth[i]))
          throw new Error("bandWidth[" + i + "] is not a number");
    } else {
      if (isNaN(+bandWidth))
        throw new Error("bandWidth must be a number");
      bw = [];
      for (i = 0; i < minV.length; i++) {
        bw.push(bandWidth);
      }
      bandWidth = bw;
    }
  } else {
    if (isNaN(+minV))
      throw new Error("lowerBound must be a number");
    minV = [minV];
    if (isNaN(+bandWidth))
      throw new Error("bandWidth must be a number");
    bandWidth = [bandWidth];
  }
  if (useQuadTree && !root) {
    tree = new QuadTree(data);
    root = tree.root;
    data = tree.data;
  }
  if (settings.verbose) {
    if (settings.polygons)
      console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell");
    else
      console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid");
    if (multiBand)
      console.log("MarchingSquaresJS-isoBands: multiple bands requested, returning array of band polygons instead of polygons for a single band");
  }
  minV.forEach(function(lowerBound, b) {
    bandPolygons = [];
    settings.minV = lowerBound;
    settings.maxV = lowerBound + bandWidth[b];
    if (settings.verbose)
      console.log("MarchingSquaresJS-isoBands: computing isobands for [" + lowerBound + ":" + (lowerBound + bandWidth[b]) + "]");
    if (settings.polygons) {
      if (useQuadTree) {
        root.cellsInBand(settings.minV, settings.maxV, true).forEach(function(c) {
          bandPolygons = bandPolygons.concat(
            cell2Polygons(
              prepareCell$1(
                data,
                c.x,
                c.y,
                settings
              ),
              c.x,
              c.y,
              settings
            )
          );
        });
      } else {
        for (j = 0; j < data.length - 1; ++j) {
          for (i = 0; i < data[0].length - 1; ++i)
            bandPolygons = bandPolygons.concat(
              cell2Polygons(
                prepareCell$1(
                  data,
                  i,
                  j,
                  settings
                ),
                i,
                j,
                settings
              )
            );
        }
      }
    } else {
      cellGrid = [];
      for (i = 0; i < data[0].length - 1; ++i)
        cellGrid[i] = [];
      if (useQuadTree) {
        root.cellsInBand(settings.minV, settings.maxV, false).forEach(function(c) {
          cellGrid[c.x][c.y] = prepareCell$1(
            data,
            c.x,
            c.y,
            settings
          );
        });
      } else {
        for (i = 0; i < data[0].length - 1; ++i) {
          for (j = 0; j < data.length - 1; ++j) {
            cellGrid[i][j] = prepareCell$1(
              data,
              i,
              j,
              settings
            );
          }
        }
      }
      bandPolygons = traceBandPaths(data, cellGrid, settings);
    }
    if (multiBand)
      ret.push(bandPolygons);
    else
      ret = bandPolygons;
    if (typeof settings.successCallback === "function")
      settings.successCallback(ret, lowerBound, bandWidth[b]);
  });
  return ret;
}
function computeCenterAverage(bl, br, tr, tl, minV, maxV) {
  var average = (tl + tr + br + bl) / 4;
  if (average > maxV)
    return 2;
  if (average < minV)
    return 0;
  return 1;
}
function prepareCell$1(grid, x2, y2, opt) {
  var cell, center_avg;
  var cval = 0;
  var x3 = grid[y2 + 1][x2];
  var x22 = grid[y2 + 1][x2 + 1];
  var x12 = grid[y2][x2 + 1];
  var x02 = grid[y2][x2];
  var minV = opt.minV;
  var maxV = opt.maxV;
  if (isNaN(x02) || isNaN(x12) || isNaN(x22) || isNaN(x3)) {
    return;
  }
  cval |= x3 < minV ? 0 : x3 > maxV ? 128 : 64;
  cval |= x22 < minV ? 0 : x22 > maxV ? 32 : 16;
  cval |= x12 < minV ? 0 : x12 > maxV ? 8 : 4;
  cval |= x02 < minV ? 0 : x02 > maxV ? 2 : 1;
  cval = +cval;
  center_avg = 0;
  cell = {
    cval,
    polygons: [],
    edges: {},
    x0: x02,
    x1: x12,
    x2: x22,
    x3,
    x: x2,
    y: y2
  };
  switch (cval) {
    case 85:
      shapeCoordinates.square(cell, x02, x12, x22, x3, opt);
    case 0:
    case 170:
      break;
    case 169:
      shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 166:
      shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
      break;
    case 154:
      shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 106:
      shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 1:
      shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 4:
      shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
      break;
    case 16:
      shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 64:
      shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 168:
      shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 162:
      shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      break;
    case 138:
      shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 42:
      shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 2:
      shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 8:
      shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      break;
    case 32:
      shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 128:
      shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 5:
      shapeCoordinates.tetragon_b(cell, x02, x12, x22, x3, opt);
      break;
    case 20:
      shapeCoordinates.tetragon_r(cell, x02, x12, x22, x3, opt);
      break;
    case 80:
      shapeCoordinates.tetragon_t(cell, x02, x12, x22, x3, opt);
      break;
    case 65:
      shapeCoordinates.tetragon_l(cell, x02, x12, x22, x3, opt);
      break;
    case 165:
      shapeCoordinates.tetragon_b(cell, x02, x12, x22, x3, opt);
      break;
    case 150:
      shapeCoordinates.tetragon_r(cell, x02, x12, x22, x3, opt);
      break;
    case 90:
      shapeCoordinates.tetragon_t(cell, x02, x12, x22, x3, opt);
      break;
    case 105:
      shapeCoordinates.tetragon_l(cell, x02, x12, x22, x3, opt);
      break;
    case 160:
      shapeCoordinates.tetragon_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 130:
      shapeCoordinates.tetragon_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 10:
      shapeCoordinates.tetragon_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 40:
      shapeCoordinates.tetragon_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 101:
      shapeCoordinates.pentagon_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 149:
      shapeCoordinates.pentagon_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 86:
      shapeCoordinates.pentagon_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 89:
      shapeCoordinates.pentagon_br(cell, x02, x12, x22, x3, opt);
      break;
    case 69:
      shapeCoordinates.pentagon_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 21:
      shapeCoordinates.pentagon_tl(cell, x02, x12, x22, x3, opt);
      break;
    case 84:
      shapeCoordinates.pentagon_bl(cell, x02, x12, x22, x3, opt);
      break;
    case 81:
      shapeCoordinates.pentagon_br(cell, x02, x12, x22, x3, opt);
      break;
    case 96:
      shapeCoordinates.pentagon_tr_rl(cell, x02, x12, x22, x3, opt);
      break;
    case 24:
      shapeCoordinates.pentagon_rb_bt(cell, x02, x12, x22, x3, opt);
      break;
    case 6:
      shapeCoordinates.pentagon_bl_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 129:
      shapeCoordinates.pentagon_lt_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 74:
      shapeCoordinates.pentagon_tr_rl(cell, x02, x12, x22, x3, opt);
      break;
    case 146:
      shapeCoordinates.pentagon_rb_bt(cell, x02, x12, x22, x3, opt);
      break;
    case 164:
      shapeCoordinates.pentagon_bl_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 41:
      shapeCoordinates.pentagon_lt_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 66:
      shapeCoordinates.pentagon_bl_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 144:
      shapeCoordinates.pentagon_lt_rl(cell, x02, x12, x22, x3, opt);
      break;
    case 36:
      shapeCoordinates.pentagon_tr_bt(cell, x02, x12, x22, x3, opt);
      break;
    case 9:
      shapeCoordinates.pentagon_rb_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 104:
      shapeCoordinates.pentagon_bl_tb(cell, x02, x12, x22, x3, opt);
      break;
    case 26:
      shapeCoordinates.pentagon_lt_rl(cell, x02, x12, x22, x3, opt);
      break;
    case 134:
      shapeCoordinates.pentagon_tr_bt(cell, x02, x12, x22, x3, opt);
      break;
    case 161:
      shapeCoordinates.pentagon_rb_lr(cell, x02, x12, x22, x3, opt);
      break;
    case 37:
      shapeCoordinates.hexagon_lt_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 148:
      shapeCoordinates.hexagon_bl_lt(cell, x02, x12, x22, x3, opt);
      break;
    case 82:
      shapeCoordinates.hexagon_bl_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 73:
      shapeCoordinates.hexagon_tr_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 133:
      shapeCoordinates.hexagon_lt_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 22:
      shapeCoordinates.hexagon_bl_lt(cell, x02, x12, x22, x3, opt);
      break;
    case 88:
      shapeCoordinates.hexagon_bl_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 97:
      shapeCoordinates.hexagon_tr_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 145:
      shapeCoordinates.hexagon_lt_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 25:
      shapeCoordinates.hexagon_lt_rb(cell, x02, x12, x22, x3, opt);
      break;
    case 70:
      shapeCoordinates.hexagon_bl_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 100:
      shapeCoordinates.hexagon_bl_tr(cell, x02, x12, x22, x3, opt);
      break;
    case 17:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.hexagon_lt_rb(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 68:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.hexagon_bl_tr(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 153:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.hexagon_lt_rb(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 102:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.hexagon_bl_tr(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 152:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_tr(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 137:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_bl(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 98:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_tl(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 38:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 2) {
        shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_br(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 18:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_tr(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_tr(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 33:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_bl(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 72:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_tl(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 132:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.triangle_br(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.heptagon_br(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 136:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      } else if (center_avg === 1) {
        shapeCoordinates.octagon(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      }
      break;
    case 34:
      center_avg = computeCenterAverage(x02, x12, x22, x3, minV, maxV);
      if (center_avg === 0) {
        shapeCoordinates.tetragon_bl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_tr(cell, x02, x12, x22, x3, opt);
      } else if (center_avg === 1) {
        shapeCoordinates.octagon(cell, x02, x12, x22, x3, opt);
      } else {
        shapeCoordinates.tetragon_tl(cell, x02, x12, x22, x3, opt);
        shapeCoordinates.tetragon_br(cell, x02, x12, x22, x3, opt);
      }
      break;
  }
  return cell;
}

// ../node_modules/.pnpm/@turf+isobands@7.1.0/node_modules/@turf/isobands/dist/esm/index.js
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
function gridToMatrix(grid, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip2 = options.flip;
  var flags = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng(grid, flip2);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point2 = pointRow[c];
      if (point2.properties[zProperty])
        row.push(point2.properties[zProperty]);
      else
        row.push(0);
      if (flags === true)
        point2.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng(points2, flip2) {
  var pointsByLatitude = {};
  featureEach(points2, function(point2) {
    var lat2 = getCoords(point2)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point2);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip2)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
function isobands(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const zProperty = options.zProperty || "elevation";
  const commonProperties = options.commonProperties || {};
  const breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks is not an Array");
  if (!isObject(commonProperties))
    throw new Error("commonProperties is not an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties is not an Array");
  const matrix = gridToMatrix(pointGrid2, { zProperty, flip: true });
  let contours = createContourLines(matrix, breaks, zProperty);
  contours = rescaleContours(contours, matrix, pointGrid2);
  const multipolygons = contours.map((contour, index2) => {
    if (breaksProperties[index2] && !isObject(breaksProperties[index2])) {
      throw new Error("Each mappedProperty is required to be an Object");
    }
    const contourProperties = __spreadValues2(__spreadValues2({}, commonProperties), breaksProperties[index2]);
    contourProperties[zProperty] = contour[zProperty];
    const multiP = multiPolygon(
      contour.groupedRings,
      contourProperties
    );
    return multiP;
  });
  return featureCollection(multipolygons);
}
function createContourLines(matrix, breaks, property) {
  const contours = [];
  for (let i = 1; i < breaks.length; i++) {
    const lowerBand = +breaks[i - 1];
    const upperBand = +breaks[i];
    const isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
    const nestedRings = orderByArea(isobandsCoords);
    const groupedRings = groupNestedRings(nestedRings);
    contours.push({
      groupedRings,
      [property]: lowerBand + "-" + upperBand
    });
  }
  return contours;
}
function rescaleContours(contours, matrix, points2) {
  const gridBbox = bbox(points2);
  const originalWidth = gridBbox[2] - gridBbox[0];
  const originalHeigth = gridBbox[3] - gridBbox[1];
  const x02 = gridBbox[0];
  const y02 = gridBbox[1];
  const matrixWidth = matrix[0].length - 1;
  const matrixHeight = matrix.length - 1;
  const scaleX = originalWidth / matrixWidth;
  const scaleY = originalHeigth / matrixHeight;
  return contours.map(function(contour) {
    contour.groupedRings = contour.groupedRings.map(
      function(lineRingSet) {
        return lineRingSet.map(function(lineRing) {
          return lineRing.map((point2) => [
            point2[0] * scaleX + x02,
            point2[1] * scaleY + y02
          ]);
        });
      }
    );
    return contour;
  });
}
function orderByArea(ringsCoords) {
  const ringsWithArea = ringsCoords.map(function(coords) {
    return { ring: coords, area: area(polygon([coords])) };
  });
  ringsWithArea.sort(function(a, b) {
    return b.area - a.area;
  });
  return ringsWithArea.map(function(x2) {
    return x2.ring;
  });
}
function groupNestedRings(orderedLinearRings) {
  const lrList = orderedLinearRings.map((lr) => {
    return { lrCoordinates: lr, grouped: false };
  });
  const groupedLinearRingsCoords = [];
  while (!allGrouped(lrList)) {
    for (let i = 0; i < lrList.length; i++) {
      if (!lrList[i].grouped) {
        const group = [];
        group.push(lrList[i].lrCoordinates);
        lrList[i].grouped = true;
        const outerMostPoly = polygon([lrList[i].lrCoordinates]);
        for (let j = i + 1; j < lrList.length; j++) {
          if (!lrList[j].grouped) {
            const lrPoly = polygon([lrList[j].lrCoordinates]);
            if (isInside(lrPoly, outerMostPoly)) {
              group.push(lrList[j].lrCoordinates);
              lrList[j].grouped = true;
            }
          }
        }
        groupedLinearRingsCoords.push(group);
      }
    }
  }
  return groupedLinearRingsCoords;
}
function isInside(testPolygon, targetPolygon) {
  const points2 = explode2(testPolygon);
  for (let i = 0; i < points2.features.length; i++) {
    if (!booleanPointInPolygon(points2.features[i], targetPolygon)) {
      return false;
    }
  }
  return true;
}
function allGrouped(list) {
  for (let i = 0; i < list.length; i++) {
    if (list[i].grouped === false) {
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/@turf+isolines@7.1.0/node_modules/@turf/isolines/dist/esm/index.js
var __defProp4 = Object.defineProperty;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp3.call(b, prop))
      __defNormalProp3(a, prop, b[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b)) {
      if (__propIsEnum3.call(b, prop))
        __defNormalProp3(a, prop, b[prop]);
    }
  return a;
};
function gridToMatrix2(grid, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip2 = options.flip;
  var flags = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng2(grid, flip2);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point2 = pointRow[c];
      if (point2.properties[zProperty])
        row.push(point2.properties[zProperty]);
      else
        row.push(0);
      if (flags === true)
        point2.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng2(points2, flip2) {
  var pointsByLatitude = {};
  featureEach(points2, function(point2) {
    var lat2 = getCoords(point2)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point2);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip2)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
function isolines(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const zProperty = options.zProperty || "elevation";
  const commonProperties = options.commonProperties || {};
  const breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks must be an Array");
  if (!isObject(commonProperties))
    throw new Error("commonProperties must be an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties must be an Array");
  const matrix = gridToMatrix2(pointGrid2, { zProperty, flip: true });
  const createdIsoLines = createIsoLines(
    matrix,
    breaks,
    zProperty,
    commonProperties,
    breaksProperties
  );
  const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid2);
  return featureCollection(scaledIsolines);
}
function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
  const results = [];
  for (let i = 0; i < breaks.length; i++) {
    const threshold = +breaks[i];
    const properties = __spreadValues3(__spreadValues3({}, commonProperties), breaksProperties[i]);
    properties[zProperty] = threshold;
    const isoline = multiLineString(
      isoLines(matrix, threshold, { linearRing: false, noFrame: true }),
      properties
    );
    results.push(isoline);
  }
  return results;
}
function rescaleIsolines(createdIsoLines, matrix, points2) {
  const gridBbox = bbox(points2);
  const originalWidth = gridBbox[2] - gridBbox[0];
  const originalHeigth = gridBbox[3] - gridBbox[1];
  const x02 = gridBbox[0];
  const y02 = gridBbox[1];
  const matrixWidth = matrix[0].length - 1;
  const matrixHeight = matrix.length - 1;
  const scaleX = originalWidth / matrixWidth;
  const scaleY = originalHeigth / matrixHeight;
  const resize = (point2) => {
    point2[0] = point2[0] * scaleX + x02;
    point2[1] = point2[1] * scaleY + y02;
  };
  createdIsoLines.forEach((isoline) => {
    coordEach(isoline, resize);
  });
  return createdIsoLines;
}

// ../node_modules/.pnpm/@turf+kinks@7.1.0/node_modules/@turf/kinks/dist/esm/index.js
function kinks(featureIn) {
  let coordinates;
  let feature2;
  const results = {
    type: "FeatureCollection",
    features: []
  };
  if (featureIn.type === "Feature") {
    feature2 = featureIn.geometry;
  } else {
    feature2 = featureIn;
  }
  if (feature2.type === "LineString") {
    coordinates = [feature2.coordinates];
  } else if (feature2.type === "MultiLineString") {
    coordinates = feature2.coordinates;
  } else if (feature2.type === "MultiPolygon") {
    coordinates = [].concat(...feature2.coordinates);
  } else if (feature2.type === "Polygon") {
    coordinates = feature2.coordinates;
  } else {
    throw new Error(
      "Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry"
    );
  }
  coordinates.forEach((line1) => {
    coordinates.forEach((line2) => {
      for (let i = 0; i < line1.length - 1; i++) {
        for (let k = i; k < line2.length - 1; k++) {
          if (line1 === line2) {
            if (Math.abs(i - k) === 1) {
              continue;
            }
            if (
              // segments are first and last segment of lineString
              i === 0 && k === line1.length - 2 && // lineString is closed
              line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]
            ) {
              continue;
            }
          }
          const intersection3 = lineIntersects(
            line1[i][0],
            line1[i][1],
            line1[i + 1][0],
            line1[i + 1][1],
            line2[k][0],
            line2[k][1],
            line2[k + 1][0],
            line2[k + 1][1]
          );
          if (intersection3) {
            results.features.push(point([intersection3[0], intersection3[1]]));
          }
        }
      }
    });
  });
  return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  let denominator;
  let a;
  let b;
  let numerator1;
  let numerator2;
  const result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
  if (denominator === 0) {
    if (result.x !== null && result.y !== null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  result.x = line1StartX + a * (line1EndX - line1StartX);
  result.y = line1StartY + a * (line1EndY - line1StartY);
  if (a >= 0 && a <= 1) {
    result.onLine1 = true;
  }
  if (b >= 0 && b <= 1) {
    result.onLine2 = true;
  }
  if (result.onLine1 && result.onLine2) {
    return [result.x, result.y];
  } else {
    return false;
  }
}

// ../node_modules/.pnpm/@turf+length@7.1.0/node_modules/@turf/length/dist/esm/index.js
function length2(geojson, options = {}) {
  return segmentReduce(
    geojson,
    (previousValue, segment) => {
      const coords = segment.geometry.coordinates;
      return previousValue + distance(coords[0], coords[1], options);
    },
    0
  );
}

// ../node_modules/.pnpm/@turf+line-arc@7.1.0/node_modules/@turf/line-arc/dist/esm/index.js
function lineArc(center2, radius, bearing1, bearing2, options = {}) {
  const steps = options.steps || 64;
  const angle1 = convertAngleTo360(bearing1);
  const angle2 = convertAngleTo360(bearing2);
  const properties = !Array.isArray(center2) && center2.type === "Feature" ? center2.properties : {};
  if (angle1 === angle2) {
    return lineString(
      circle2(center2, radius, options).geometry.coordinates[0],
      properties
    );
  }
  const arcStartDegree = angle1;
  const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
  let alpha = arcStartDegree;
  const coordinates = [];
  let i = 0;
  const arcStep = (arcEndDegree - arcStartDegree) / steps;
  while (alpha <= arcEndDegree) {
    coordinates.push(
      destination(center2, radius, alpha, options).geometry.coordinates
    );
    i++;
    alpha = arcStartDegree + i * arcStep;
  }
  return lineString(coordinates, properties);
}
function convertAngleTo360(alpha) {
  let beta = alpha % 360;
  if (beta < 0) {
    beta += 360;
  }
  return beta;
}

// ../node_modules/.pnpm/@turf+line-slice-along@7.1.0/node_modules/@turf/line-slice-along/dist/esm/index.js
function lineSliceAlong(line, startDist, stopDist, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var coords;
  var slice2 = [];
  if (line.type === "Feature")
    coords = line.geometry.coordinates;
  else if (line.type === "LineString")
    coords = line.coordinates;
  else
    throw new Error("input must be a LineString Feature or Geometry");
  var origCoordsLength = coords.length;
  var travelled = 0;
  var overshot, direction, interpolated;
  for (var i = 0; i < coords.length; i++) {
    if (startDist >= travelled && i === coords.length - 1)
      break;
    else if (travelled > startDist && slice2.length === 0) {
      overshot = startDist - travelled;
      if (!overshot) {
        slice2.push(coords[i]);
        return lineString(slice2);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice2.push(interpolated.geometry.coordinates);
    }
    if (travelled >= stopDist) {
      overshot = stopDist - travelled;
      if (!overshot) {
        slice2.push(coords[i]);
        return lineString(slice2);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice2.push(interpolated.geometry.coordinates);
      return lineString(slice2);
    }
    if (travelled >= startDist) {
      slice2.push(coords[i]);
    }
    if (i === coords.length - 1) {
      return lineString(slice2);
    }
    travelled += distance(coords[i], coords[i + 1], options);
  }
  if (travelled < startDist && coords.length === origCoordsLength)
    throw new Error("Start position is beyond line");
  var last = coords[coords.length - 1];
  return lineString([last, last]);
}

// ../node_modules/.pnpm/@turf+line-chunk@7.1.0/node_modules/@turf/line-chunk/dist/esm/index.js
function lineChunk(geojson, segmentLength, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  var reverse2 = options.reverse;
  if (!geojson)
    throw new Error("geojson is required");
  if (segmentLength <= 0)
    throw new Error("segmentLength must be greater than 0");
  var results = [];
  flattenEach(geojson, function(feature2) {
    if (reverse2)
      feature2.geometry.coordinates = feature2.geometry.coordinates.reverse();
    sliceLineSegments(feature2, segmentLength, units, function(segment) {
      results.push(segment);
    });
  });
  return featureCollection(results);
}
function sliceLineSegments(line, segmentLength, units, callback) {
  var lineLength = length2(line, { units });
  if (lineLength <= segmentLength)
    return callback(line);
  var numberOfSegments = lineLength / segmentLength;
  if (!Number.isInteger(numberOfSegments)) {
    numberOfSegments = Math.floor(numberOfSegments) + 1;
  }
  for (var i = 0; i < numberOfSegments; i++) {
    var outline = lineSliceAlong(
      line,
      segmentLength * i,
      segmentLength * (i + 1),
      { units }
    );
    callback(outline, i);
  }
}

// ../node_modules/.pnpm/@turf+line-offset@7.1.0/node_modules/@turf/line-offset/dist/esm/index.js
function ab4(segment) {
  var start = segment[0];
  var end = segment[1];
  return [end[0] - start[0], end[1] - start[1]];
}
function crossProduct2(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function add2(v1, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}
function scalarMult(s, v2) {
  return [s * v2[0], s * v2[1]];
}
function intersectSegments(a, b) {
  var p = a[0];
  var r = ab4(a);
  var q = b[0];
  var s = ab4(b);
  var cross = crossProduct2(r, s);
  var qmp = sub(q, p);
  var numerator = crossProduct2(qmp, s);
  var t = numerator / cross;
  var intersection22 = add2(p, scalarMult(t, r));
  return intersection22;
}
function isParallel2(a, b) {
  var r = ab4(a);
  var s = ab4(b);
  return crossProduct2(r, s) === 0;
}
function intersection2(a, b) {
  if (isParallel2(a, b))
    return false;
  return intersectSegments(a, b);
}
function lineOffset(geojson, distance2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance2 === void 0 || distance2 === null || isNaN(distance2))
    throw new Error("distance is required");
  var type = getType(geojson);
  var properties = geojson.properties;
  switch (type) {
    case "LineString":
      return lineOffsetFeature(geojson, distance2, units);
    case "MultiLineString":
      var coords = [];
      flattenEach(geojson, function(feature2) {
        coords.push(
          lineOffsetFeature(feature2, distance2, units).geometry.coordinates
        );
      });
      return multiLineString(coords, properties);
    default:
      throw new Error("geometry " + type + " is not supported");
  }
}
function lineOffsetFeature(line, distance2, units) {
  var segments = [];
  var offsetDegrees = lengthToDegrees(distance2, units);
  var coords = getCoords(line);
  var finalCoords = [];
  coords.forEach(function(currentCoords, index2) {
    if (index2 !== coords.length - 1) {
      var segment = processSegment(
        currentCoords,
        coords[index2 + 1],
        offsetDegrees
      );
      segments.push(segment);
      if (index2 > 0) {
        var seg2Coords = segments[index2 - 1];
        var intersects2 = intersection2(segment, seg2Coords);
        if (intersects2 !== false) {
          seg2Coords[1] = intersects2;
          segment[0] = intersects2;
        }
        finalCoords.push(seg2Coords[0]);
        if (index2 === coords.length - 2) {
          finalCoords.push(segment[0]);
          finalCoords.push(segment[1]);
        }
      }
      if (coords.length === 2) {
        finalCoords.push(segment[0]);
        finalCoords.push(segment[1]);
      }
    }
  });
  return lineString(finalCoords, line.properties);
}
function processSegment(point1, point2, offset) {
  var L = Math.sqrt(
    (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1])
  );
  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
  return [
    [out1x, out1y],
    [out2x, out2y]
  ];
}

// ../node_modules/.pnpm/@turf+line-slice@7.1.0/node_modules/@turf/line-slice/dist/esm/index.js
function lineSlice(startPt, stopPt, line) {
  var coords = getCoords(line);
  if (getType(line) !== "LineString")
    throw new Error("line must be a LineString");
  var startVertex = nearestPointOnLine(line, startPt);
  var stopVertex = nearestPointOnLine(line, stopPt);
  var ends;
  if (startVertex.properties.index <= stopVertex.properties.index) {
    ends = [startVertex, stopVertex];
  } else {
    ends = [stopVertex, startVertex];
  }
  var clipCoords = [ends[0].geometry.coordinates];
  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
    clipCoords.push(coords[i]);
  }
  clipCoords.push(ends[1].geometry.coordinates);
  return lineString(clipCoords, line.properties);
}

// ../node_modules/.pnpm/@turf+square@7.1.0/node_modules/@turf/square/dist/esm/index.js
function square(bbox3) {
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  var horizontalDistance = distance(bbox3.slice(0, 2), [east, south]);
  var verticalDistance = distance(bbox3.slice(0, 2), [west, north]);
  if (horizontalDistance >= verticalDistance) {
    var verticalMidpoint = (south + north) / 2;
    return [
      west,
      verticalMidpoint - (east - west) / 2,
      east,
      verticalMidpoint + (east - west) / 2
    ];
  } else {
    var horizontalMidpoint = (west + east) / 2;
    return [
      horizontalMidpoint - (north - south) / 2,
      south,
      horizontalMidpoint + (north - south) / 2,
      north
    ];
  }
}

// ../node_modules/.pnpm/@turf+truncate@7.1.0/node_modules/@turf/truncate/dist/esm/index.js
function truncate(geojson, options) {
  options = options != null ? options : {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var precision = options.precision;
  var coordinates = options.coordinates;
  var mutate = options.mutate;
  precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
  coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof precision !== "number")
    throw new Error("<precision> must be a number");
  if (typeof coordinates !== "number")
    throw new Error("<coordinates> must be a number");
  if (mutate === false || mutate === void 0)
    geojson = JSON.parse(JSON.stringify(geojson));
  var factor = Math.pow(10, precision);
  coordEach(geojson, function(coords) {
    truncateCoords(coords, factor, coordinates);
  });
  return geojson;
}
function truncateCoords(coords, factor, coordinates) {
  if (coords.length > coordinates)
    coords.splice(coordinates, coords.length);
  for (var i = 0; i < coords.length; i++) {
    coords[i] = Math.round(coords[i] * factor) / factor;
  }
  return coords;
}

// ../node_modules/.pnpm/@turf+line-split@7.1.0/node_modules/@turf/line-split/dist/esm/index.js
function lineSplit(line, splitter2) {
  if (!line)
    throw new Error("line is required");
  if (!splitter2)
    throw new Error("splitter is required");
  var lineType = getType(line);
  var splitterType = getType(splitter2);
  if (lineType !== "LineString")
    throw new Error("line must be LineString");
  if (splitterType === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (splitterType === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var truncatedSplitter = truncate(splitter2, { precision: 7 });
  switch (splitterType) {
    case "Point":
      return splitLineWithPoint(line, truncatedSplitter);
    case "MultiPoint":
      return splitLineWithPoints(line, truncatedSplitter);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return splitLineWithPoints(
        line,
        lineIntersect(line, truncatedSplitter, {
          ignoreSelfIntersections: true
        })
      );
  }
}
function splitLineWithPoints(line, splitter2) {
  var results = [];
  var tree = geojsonRbush();
  flattenEach(splitter2, function(point2) {
    results.forEach(function(feature2, index2) {
      feature2.id = index2;
    });
    if (!results.length) {
      results = splitLineWithPoint(line, point2).features;
      results.forEach(function(feature2) {
        if (!feature2.bbox)
          feature2.bbox = square(bbox(feature2));
      });
      tree.load(featureCollection(results));
    } else {
      var search = tree.search(point2);
      if (search.features.length) {
        var closestLine = findClosestFeature(point2, search);
        results = results.filter(function(feature2) {
          return feature2.id !== closestLine.id;
        });
        tree.remove(closestLine);
        featureEach(splitLineWithPoint(closestLine, point2), function(line2) {
          results.push(line2);
          tree.insert(line2);
        });
      }
    }
  });
  return featureCollection(results);
}
function splitLineWithPoint(line, splitter2) {
  var results = [];
  var startPoint = getCoords(line)[0];
  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];
  if (pointsEquals(startPoint, getCoord(splitter2)) || pointsEquals(endPoint, getCoord(splitter2)))
    return featureCollection([line]);
  var tree = geojsonRbush();
  var segments = lineSegment(line);
  tree.load(segments);
  var search = tree.search(splitter2);
  if (!search.features.length)
    return featureCollection([line]);
  var closestSegment = findClosestFeature(splitter2, search);
  var initialValue = [startPoint];
  var lastCoords = featureReduce(
    segments,
    function(previous, current, index2) {
      var currentCoords = getCoords(current)[1];
      var splitterCoords = getCoord(splitter2);
      if (index2 === closestSegment.id) {
        previous.push(splitterCoords);
        results.push(lineString(previous));
        if (pointsEquals(splitterCoords, currentCoords))
          return [splitterCoords];
        return [splitterCoords, currentCoords];
      } else {
        previous.push(currentCoords);
        return previous;
      }
    },
    initialValue
  );
  if (lastCoords.length > 1) {
    results.push(lineString(lastCoords));
  }
  return featureCollection(results);
}
function findClosestFeature(point2, lines) {
  if (!lines.features.length)
    throw new Error("lines must contain features");
  if (lines.features.length === 1)
    return lines.features[0];
  var closestFeature;
  var closestDistance = Infinity;
  featureEach(lines, function(segment) {
    var pt = nearestPointOnLine(segment, point2);
    var dist = pt.properties.dist;
    if (dist < closestDistance) {
      closestFeature = segment;
      closestDistance = dist;
    }
  });
  return closestFeature;
}
function pointsEquals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}

// ../node_modules/.pnpm/@turf+line-to-polygon@7.1.0/node_modules/@turf/line-to-polygon/dist/esm/index.js
function lineToPolygon(lines, options = {}) {
  var _a, _b, _c;
  var properties = options.properties;
  var autoComplete = (_a = options.autoComplete) != null ? _a : true;
  var orderCoords = (_b = options.orderCoords) != null ? _b : true;
  var mutate = (_c = options.mutate) != null ? _c : false;
  if (!mutate) {
    lines = clone(lines);
  }
  switch (lines.type) {
    case "FeatureCollection":
      var coords = [];
      lines.features.forEach(function(line) {
        coords.push(
          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))
        );
      });
      return multiPolygon(coords, properties);
    default:
      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
  }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
  properties = properties ? properties : line.type === "Feature" ? line.properties : {};
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var type = geom.type;
  if (!coords.length)
    throw new Error("line must contain coordinates");
  switch (type) {
    case "LineString":
      if (autoComplete)
        coords = autoCompleteCoords(coords);
      return polygon([coords], properties);
    case "MultiLineString":
      var multiCoords = [];
      var largestArea = 0;
      coords.forEach(function(coord) {
        if (autoComplete)
          coord = autoCompleteCoords(coord);
        if (orderCoords) {
          var area2 = calculateArea2(bbox(lineString(coord)));
          if (area2 > largestArea) {
            multiCoords.unshift(coord);
            largestArea = area2;
          } else
            multiCoords.push(coord);
        } else {
          multiCoords.push(coord);
        }
      });
      return polygon(multiCoords, properties);
    default:
      throw new Error("geometry type " + type + " is not supported");
  }
}
function autoCompleteCoords(coords) {
  var first = coords[0];
  var x12 = first[0];
  var y12 = first[1];
  var last = coords[coords.length - 1];
  var x2 = last[0];
  var y2 = last[1];
  if (x12 !== x2 || y12 !== y2) {
    coords.push(first);
  }
  return coords;
}
function calculateArea2(bbox3) {
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  return Math.abs(west - east) * Math.abs(south - north);
}

// ../node_modules/.pnpm/@turf+mask@7.1.0/node_modules/@turf/mask/dist/esm/index.js
function mask(polygon2, mask2, options) {
  var _a;
  const mutate = (_a = options == null ? void 0 : options.mutate) != null ? _a : false;
  let maskTemplate = mask2;
  if (mask2 && mutate === false) {
    maskTemplate = clone(mask2);
  }
  const maskPolygon = createMask(maskTemplate);
  let polygonOuters = null;
  if (polygon2.type === "FeatureCollection") {
    polygonOuters = unionFc(polygon2);
  } else if (polygon2.type === "Feature") {
    polygonOuters = createGeomFromPolygonClippingOutput(
      index.union(polygon2.geometry.coordinates)
    );
  } else {
    polygonOuters = createGeomFromPolygonClippingOutput(
      index.union(polygon2.coordinates)
    );
  }
  polygonOuters.geometry.coordinates.forEach(function(contour) {
    maskPolygon.geometry.coordinates.push(contour[0]);
  });
  return maskPolygon;
}
function unionFc(fc) {
  const unioned = fc.features.length === 2 ? index.union(
    fc.features[0].geometry.coordinates,
    fc.features[1].geometry.coordinates
  ) : index.union.apply(
    index,
    fc.features.map(function(f) {
      return f.geometry.coordinates;
    })
  );
  return createGeomFromPolygonClippingOutput(unioned);
}
function createGeomFromPolygonClippingOutput(unioned) {
  return multiPolygon(unioned);
}
function createMask(mask2) {
  const world = [
    [
      [180, 90],
      [-180, 90],
      [-180, -90],
      [180, -90],
      [180, 90]
    ]
  ];
  let coordinates = world;
  if (mask2) {
    if (mask2.type === "Feature") {
      coordinates = mask2.geometry.coordinates;
    } else {
      coordinates = mask2.coordinates;
    }
  }
  return polygon(coordinates);
}

// ../node_modules/.pnpm/@turf+midpoint@7.1.0/node_modules/@turf/midpoint/dist/esm/index.js
function midpoint(point1, point2) {
  const dist = distance(point1, point2);
  const heading = bearing(point1, point2);
  const midpoint2 = destination(point1, dist / 2, heading);
  return midpoint2;
}

// ../node_modules/.pnpm/@turf+moran-index@7.1.0/node_modules/@turf/moran-index/dist/esm/index.js
function moranIndex(fc, options) {
  var _a, _b;
  const inputField = options.inputField;
  const threshold = options.threshold || 1e5;
  const p = options.p || 2;
  const binary = (_a = options.binary) != null ? _a : false;
  const alpha = options.alpha || -1;
  const standardization = (_b = options.standardization) != null ? _b : true;
  const weight = distanceWeight(fc, {
    alpha,
    binary,
    p,
    standardization,
    threshold
  });
  const y2 = [];
  featureEach(fc, (feature2) => {
    const feaProperties = feature2.properties || {};
    y2.push(feaProperties[inputField]);
  });
  const yMean = mean(y2);
  const yVar = variance(y2);
  let weightSum = 0;
  let s0 = 0;
  let s1 = 0;
  let s2 = 0;
  const n = weight.length;
  for (let i = 0; i < n; i++) {
    let subS2 = 0;
    for (let j = 0; j < n; j++) {
      weightSum += weight[i][j] * (y2[i] - yMean) * (y2[j] - yMean);
      s0 += weight[i][j];
      s1 += Math.pow(weight[i][j] + weight[j][i], 2);
      subS2 += weight[i][j] + weight[j][i];
    }
    s2 += Math.pow(subS2, 2);
  }
  s1 = 0.5 * s1;
  const moranIndex2 = weightSum / s0 / yVar;
  const expectedMoranIndex = -1 / (n - 1);
  const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
  const vDen = (n - 1) * (n + 1) * (s0 * s0);
  const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
  const stdNorm = Math.sqrt(vNorm);
  const zNorm = (moranIndex2 - expectedMoranIndex) / stdNorm;
  return {
    expectedMoranIndex,
    moranIndex: moranIndex2,
    stdNorm,
    zNorm
  };
}
function mean(y2) {
  let sum3 = 0;
  for (const item of y2) {
    sum3 += item;
  }
  return sum3 / y2.length;
}
function variance(y2) {
  const yMean = mean(y2);
  let sum3 = 0;
  for (const item of y2) {
    sum3 += Math.pow(item - yMean, 2);
  }
  return sum3 / y2.length;
}

// ../node_modules/.pnpm/@turf+nearest-point@7.1.0/node_modules/@turf/nearest-point/dist/esm/index.js
var __defProp5 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp4.call(b, prop))
      __defNormalProp4(a, prop, b[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b)) {
      if (__propIsEnum4.call(b, prop))
        __defNormalProp4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
function nearestPoint(targetPoint, points2, options = {}) {
  if (!targetPoint)
    throw new Error("targetPoint is required");
  if (!points2)
    throw new Error("points is required");
  let minDist = Infinity;
  let bestFeatureIndex = 0;
  featureEach(points2, (pt, featureIndex) => {
    const distanceToPoint = distance(targetPoint, pt, options);
    if (distanceToPoint < minDist) {
      bestFeatureIndex = featureIndex;
      minDist = distanceToPoint;
    }
  });
  const nearestPoint2 = clone(points2.features[bestFeatureIndex]);
  return __spreadProps2(__spreadValues4({}, nearestPoint2), {
    properties: __spreadProps2(__spreadValues4({}, nearestPoint2.properties), {
      featureIndex: bestFeatureIndex,
      distanceToPoint: minDist
    })
  });
}

// ../node_modules/.pnpm/@turf+nearest-neighbor-analysis@7.1.0/node_modules/@turf/nearest-neighbor-analysis/dist/esm/index.js
function nearestNeighborAnalysis(dataset, options) {
  options = options || {};
  const studyArea = options.studyArea || bboxPolygon(bbox(dataset));
  const properties = options.properties || {};
  const units = options.units || "kilometers";
  const features = [];
  featureEach(dataset, (feature2) => {
    features.push(centroid(feature2));
  });
  const n = features.length;
  const observedMeanDistance = features.map((feature2, index2) => {
    const otherFeatures = featureCollection(
      features.filter((f, i) => {
        return i !== index2;
      })
    );
    return distance(
      feature2,
      nearestPoint(feature2, otherFeatures).geometry.coordinates,
      { units }
    );
  }).reduce((sum3, value) => {
    return sum3 + value;
  }, 0) / n;
  const populationDensity = n / convertArea(area(studyArea), "meters", units);
  const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));
  const variance2 = 0.26136 / Math.sqrt(n * populationDensity);
  properties.nearestNeighborAnalysis = {
    units,
    arealUnits: units + "²",
    observedMeanDistance,
    expectedMeanDistance,
    nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,
    numberOfPoints: n,
    zScore: (observedMeanDistance - expectedMeanDistance) / variance2
  };
  studyArea.properties = properties;
  return studyArea;
}

// ../node_modules/.pnpm/@turf+point-to-line-distance@7.1.0/node_modules/@turf/point-to-line-distance/dist/esm/index.js
function pointToLineDistance(pt, line, options = {}) {
  if (!options.method) {
    options.method = "geodesic";
  }
  if (!options.units) {
    options.units = "kilometers";
  }
  if (!pt) {
    throw new Error("pt is required");
  }
  if (Array.isArray(pt)) {
    pt = point(pt);
  } else if (pt.type === "Point") {
    pt = feature(pt);
  } else {
    featureOf(pt, "Point", "point");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (Array.isArray(line)) {
    line = lineString(line);
  } else if (line.type === "LineString") {
    line = feature(line);
  } else {
    featureOf(line, "LineString", "line");
  }
  let distance2 = Infinity;
  const p = pt.geometry.coordinates;
  segmentEach(line, (segment) => {
    const a = segment.geometry.coordinates[0];
    const b = segment.geometry.coordinates[1];
    const d = distanceToSegment(p, a, b, options);
    if (d < distance2) {
      distance2 = d;
    }
  });
  return convertLength(distance2, "degrees", options.units);
}
function distanceToSegment(p, a, b, options) {
  const v2 = [b[0] - a[0], b[1] - a[1]];
  const w = [p[0] - a[0], p[1] - a[1]];
  const c1 = dot(w, v2);
  if (c1 <= 0) {
    return calcDistance(p, a, { method: options.method, units: "degrees" });
  }
  const c2 = dot(v2, v2);
  if (c2 <= c1) {
    return calcDistance(p, b, { method: options.method, units: "degrees" });
  }
  const b2 = c1 / c2;
  const Pb = [a[0] + b2 * v2[0], a[1] + b2 * v2[1]];
  return calcDistance(p, Pb, { method: options.method, units: "degrees" });
}
function dot(u4, v2) {
  return u4[0] * v2[0] + u4[1] * v2[1];
}
function calcDistance(a, b, options) {
  return options.method === "planar" ? rhumbDistance(a, b, options) : distance(a, b, options);
}

// ../node_modules/.pnpm/@turf+nearest-point-to-line@7.1.0/node_modules/@turf/nearest-point-to-line/dist/esm/index.js
var __defProp6 = Object.defineProperty;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp5.call(b, prop))
      __defNormalProp5(a, prop, b[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b)) {
      if (__propIsEnum5.call(b, prop))
        __defNormalProp5(a, prop, b[prop]);
    }
  return a;
};
function nearestPointToLine(points2, line, options = {}) {
  const units = options.units;
  const properties = options.properties || {};
  const pts = normalize(points2);
  if (!pts.features.length) {
    throw new Error("points must contain features");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (getType(line) !== "LineString") {
    throw new Error("line must be a LineString");
  }
  let dist = Infinity;
  let pt = null;
  featureEach(pts, (point2) => {
    const d = pointToLineDistance(point2, line, { units });
    if (d < dist) {
      dist = d;
      pt = point2;
    }
  });
  if (pt) {
    pt.properties = __spreadValues5(__spreadValues5(__spreadValues5({}, { dist }), pt.properties), properties);
  }
  return pt;
}
function normalize(points2) {
  const features = [];
  const type = points2.geometry ? points2.geometry.type : points2.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(points2, (geom) => {
        if (geom.type === "Point") {
          features.push({ type: "Feature", properties: {}, geometry: geom });
        }
      });
      return { type: "FeatureCollection", features };
    case "FeatureCollection":
      points2.features = points2.features.filter((feature2) => {
        return feature2.geometry.type === "Point";
      });
      return points2;
    default:
      throw new Error("points must be a Point Collection");
  }
}

// ../node_modules/.pnpm/@turf+planepoint@7.1.0/node_modules/@turf/planepoint/dist/esm/index.js
function planepoint(point2, triangle) {
  const coord = getCoord(point2);
  const geom = getGeom(triangle);
  const coords = geom.coordinates;
  const outer = coords[0];
  if (outer.length < 4)
    throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
  const properties = triangle.type === "Feature" && triangle.properties || {};
  const a = properties.a;
  const b = properties.b;
  const c = properties.c;
  const x2 = coord[0];
  const y2 = coord[1];
  const x12 = outer[0][0];
  const y12 = outer[0][1];
  const z1 = a !== void 0 ? a : outer[0][2];
  const x22 = outer[1][0];
  const y22 = outer[1][1];
  const z2 = b !== void 0 ? b : outer[1][2];
  const x3 = outer[2][0];
  const y3 = outer[2][1];
  const z3 = c !== void 0 ? c : outer[2][2];
  const z = (z3 * (x2 - x12) * (y2 - y22) + z1 * (x2 - x22) * (y2 - y3) + z2 * (x2 - x3) * (y2 - y12) - z2 * (x2 - x12) * (y2 - y3) - z3 * (x2 - x22) * (y2 - y12) - z1 * (x2 - x3) * (y2 - y22)) / ((x2 - x12) * (y2 - y22) + (x2 - x22) * (y2 - y3) + (x2 - x3) * (y2 - y12) - (x2 - x12) * (y2 - y3) - (x2 - x22) * (y2 - y12) - (x2 - x3) * (y2 - y22));
  return z;
}

// ../node_modules/.pnpm/@turf+point-on-feature@7.1.0/node_modules/@turf/point-on-feature/dist/esm/index.js
function pointOnFeature(geojson) {
  const fc = normalize2(geojson);
  const cent = center(fc);
  let onSurface = false;
  let i = 0;
  while (!onSurface && i < fc.features.length) {
    const geom = fc.features[i].geometry;
    let x2, y2, x12, y12, x22, y22;
    let onLine = false;
    if (geom.type === "Point") {
      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
        onSurface = true;
      }
    } else if (geom.type === "MultiPoint") {
      let onMultiPoint = false;
      let k = 0;
      while (!onMultiPoint && k < geom.coordinates.length) {
        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
          onSurface = true;
          onMultiPoint = true;
        }
        k++;
      }
    } else if (geom.type === "LineString") {
      let k = 0;
      while (!onLine && k < geom.coordinates.length - 1) {
        x2 = cent.geometry.coordinates[0];
        y2 = cent.geometry.coordinates[1];
        x12 = geom.coordinates[k][0];
        y12 = geom.coordinates[k][1];
        x22 = geom.coordinates[k + 1][0];
        y22 = geom.coordinates[k + 1][1];
        if (pointOnSegment(x2, y2, x12, y12, x22, y22)) {
          onLine = true;
          onSurface = true;
        }
        k++;
      }
    } else if (geom.type === "MultiLineString") {
      let j = 0;
      while (j < geom.coordinates.length) {
        onLine = false;
        let k = 0;
        const line = geom.coordinates[j];
        while (!onLine && k < line.length - 1) {
          x2 = cent.geometry.coordinates[0];
          y2 = cent.geometry.coordinates[1];
          x12 = line[k][0];
          y12 = line[k][1];
          x22 = line[k + 1][0];
          y22 = line[k + 1][1];
          if (pointOnSegment(x2, y2, x12, y12, x22, y22)) {
            onLine = true;
            onSurface = true;
          }
          k++;
        }
        j++;
      }
    } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
      if (booleanPointInPolygon(cent, geom)) {
        onSurface = true;
      }
    }
    i++;
  }
  if (onSurface) {
    return cent;
  } else {
    const vertices = featureCollection([]);
    for (let f = 0; f < fc.features.length; f++) {
      vertices.features = vertices.features.concat(
        explode2(fc.features[f]).features
      );
    }
    return point(nearestPoint(cent, vertices).geometry.coordinates);
  }
}
function normalize2(geojson) {
  if (geojson.type !== "FeatureCollection") {
    if (geojson.type !== "Feature") {
      return featureCollection([feature(geojson)]);
    }
    return featureCollection([geojson]);
  }
  return geojson;
}
function pointOnSegment(x2, y2, x12, y12, x22, y22) {
  const ab5 = Math.sqrt((x22 - x12) * (x22 - x12) + (y22 - y12) * (y22 - y12));
  const ap = Math.sqrt((x2 - x12) * (x2 - x12) + (y2 - y12) * (y2 - y12));
  const pb = Math.sqrt((x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2));
  return ab5 === ap + pb;
}

// ../node_modules/.pnpm/@turf+points-within-polygon@7.1.0/node_modules/@turf/points-within-polygon/dist/esm/index.js
function pointsWithinPolygon(points2, polygons2) {
  const results = [];
  featureEach(points2, function(point2) {
    let contained = false;
    if (point2.geometry.type === "Point") {
      geomEach(polygons2, function(polygon2) {
        if (booleanPointInPolygon(point2, polygon2)) {
          contained = true;
        }
      });
      if (contained) {
        results.push(point2);
      }
    } else if (point2.geometry.type === "MultiPoint") {
      var pointsWithin = [];
      geomEach(polygons2, function(polygon2) {
        coordEach(point2, function(pointCoord) {
          if (booleanPointInPolygon(pointCoord, polygon2)) {
            contained = true;
            pointsWithin.push(pointCoord);
          }
        });
      });
      if (contained) {
        results.push(
          multiPoint(pointsWithin, point2.properties)
        );
      }
    } else {
      throw new Error("Input geometry must be a Point or MultiPoint");
    }
  });
  return featureCollection(results);
}

// ../node_modules/.pnpm/@turf+polygonize@7.1.0/node_modules/@turf/polygonize/dist/esm/index.js
function mathSign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function orientationIndex(p1, p2, q) {
  const dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
  return mathSign(dx1 * dy2 - dx2 * dy1);
}
function envelopeIsEqual(env1, env2) {
  const envX1 = env1.geometry.coordinates[0].map((c) => c[0]), envY1 = env1.geometry.coordinates[0].map((c) => c[1]), envX2 = env2.geometry.coordinates[0].map((c) => c[0]), envY2 = env2.geometry.coordinates[0].map((c) => c[1]);
  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
}
function envelopeContains(self2, env) {
  return env.geometry.coordinates[0].every(
    (c) => booleanPointInPolygon(point(c), self2)
  );
}
function coordinatesEqual(coord1, coord2) {
  return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}
var Node2 = class _Node {
  static buildId(coordinates) {
    return coordinates.join(",");
  }
  constructor(coordinates) {
    this.id = _Node.buildId(coordinates);
    this.coordinates = coordinates;
    this.innerEdges = [];
    this.outerEdges = [];
    this.outerEdgesSorted = false;
  }
  removeInnerEdge(edge) {
    this.innerEdges = this.innerEdges.filter((e) => e.from.id !== edge.from.id);
  }
  removeOuterEdge(edge) {
    this.outerEdges = this.outerEdges.filter((e) => e.to.id !== edge.to.id);
  }
  /**
   * Outer edges are stored CCW order.
   *
   * @memberof Node
   * @param {Edge} edge - Edge to add as an outerEdge.
   */
  addOuterEdge(edge) {
    this.outerEdges.push(edge);
    this.outerEdgesSorted = false;
  }
  /**
   * Sorts outer edges in CCW way.
   *
   * @memberof Node
   * @private
   */
  sortOuterEdges() {
    if (!this.outerEdgesSorted) {
      this.outerEdges.sort((a, b) => {
        const aNode = a.to, bNode = b.to;
        if (aNode.coordinates[0] - this.coordinates[0] >= 0 && bNode.coordinates[0] - this.coordinates[0] < 0)
          return 1;
        if (aNode.coordinates[0] - this.coordinates[0] < 0 && bNode.coordinates[0] - this.coordinates[0] >= 0)
          return -1;
        if (aNode.coordinates[0] - this.coordinates[0] === 0 && bNode.coordinates[0] - this.coordinates[0] === 0) {
          if (aNode.coordinates[1] - this.coordinates[1] >= 0 || bNode.coordinates[1] - this.coordinates[1] >= 0)
            return aNode.coordinates[1] - bNode.coordinates[1];
          return bNode.coordinates[1] - aNode.coordinates[1];
        }
        const det = orientationIndex(
          this.coordinates,
          aNode.coordinates,
          bNode.coordinates
        );
        if (det < 0)
          return 1;
        if (det > 0)
          return -1;
        const d1 = Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);
        return d1 - d2;
      });
      this.outerEdgesSorted = true;
    }
  }
  /**
   * Retrieves outer edges.
   *
   * They are sorted if they aren't in the CCW order.
   *
   * @memberof Node
   * @returns {Edge[]} - List of outer edges sorted in a CCW order.
   */
  getOuterEdges() {
    this.sortOuterEdges();
    return this.outerEdges;
  }
  getOuterEdge(i) {
    this.sortOuterEdges();
    return this.outerEdges[i];
  }
  addInnerEdge(edge) {
    this.innerEdges.push(edge);
  }
};
var Edge = class _Edge {
  /**
   * Creates or get the symetric Edge.
   *
   * @returns {Edge} - Symetric Edge.
   */
  getSymetric() {
    if (!this.symetric) {
      this.symetric = new _Edge(this.to, this.from);
      this.symetric.symetric = this;
    }
    return this.symetric;
  }
  /**
   * @param {Node} from - start node of the Edge
   * @param {Node} to - end node of the edge
   */
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.next = void 0;
    this.label = void 0;
    this.symetric = void 0;
    this.ring = void 0;
    this.from.addOuterEdge(this);
    this.to.addInnerEdge(this);
  }
  /**
   * Removes edge from from and to nodes.
   */
  deleteEdge() {
    this.from.removeOuterEdge(this);
    this.to.removeInnerEdge(this);
  }
  /**
   * Compares Edge equallity.
   *
   * An edge is equal to another, if the from and to nodes are the same.
   *
   * @param {Edge} edge - Another Edge
   * @returns {boolean} - True if Edges are equal, False otherwise
   */
  isEqual(edge) {
    return this.from.id === edge.from.id && this.to.id === edge.to.id;
  }
  toString() {
    return `Edge { ${this.from.id} -> ${this.to.id} }`;
  }
  /**
   * Returns a LineString representation of the Edge
   *
   * @returns {Feature<LineString>} - LineString representation of the Edge
   */
  toLineString() {
    return lineString([this.from.coordinates, this.to.coordinates]);
  }
  /**
   * Comparator of two edges.
   *
   * Implementation of geos::planargraph::DirectedEdge::compareTo.
   *
   * @param {Edge} edge - Another edge to compare with this one
   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,
   *          0 if the Edges are colinear,
   *          1 otherwise
   */
  compareTo(edge) {
    return orientationIndex(
      edge.from.coordinates,
      edge.to.coordinates,
      this.to.coordinates
    );
  }
};
var EdgeRing = class {
  constructor() {
    this.edges = [];
    this.polygon = void 0;
    this.envelope = void 0;
  }
  /**
   * Add an edge to the ring, inserting it in the last position.
   *
   * @memberof EdgeRing
   * @param {Edge} edge - Edge to be inserted
   */
  push(edge) {
    this.edges.push(edge);
    this.polygon = this.envelope = void 0;
  }
  /**
   * Get Edge.
   *
   * @memberof EdgeRing
   * @param {number} i - Index
   * @returns {Edge} - Edge in the i position
   */
  get(i) {
    return this.edges[i];
  }
  /**
   * Getter of length property.
   *
   * @memberof EdgeRing
   * @returns {number} - Length of the edge ring.
   */
  get length() {
    return this.edges.length;
  }
  /**
   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.forEach
   */
  forEach(f) {
    this.edges.forEach(f);
  }
  /**
   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.map
   * @returns {Array} - The mapped values in the function
   */
  map(f) {
    return this.edges.map(f);
  }
  /**
   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.some
   * @returns {boolean} - True if an Edge check the condition
   */
  some(f) {
    return this.edges.some(f);
  }
  /**
   * Check if the ring is valid in geomtry terms.
   *
   * A ring must have either 0 or 4 or more points. The first and the last must be
   * equal (in 2D)
   * geos::geom::LinearRing::validateConstruction
   *
   * @memberof EdgeRing
   * @returns {boolean} - Validity of the EdgeRing
   */
  isValid() {
    return true;
  }
  /**
   * Tests whether this ring is a hole.
   *
   * A ring is a hole if it is oriented counter-clockwise.
   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
   *
   * @memberof EdgeRing
   * @returns {boolean} - true: if it is a hole
   */
  isHole() {
    const hiIndex = this.edges.reduce((high, edge, i) => {
      if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1])
        high = i;
      return high;
    }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(
      this.edges[iPrev].from.coordinates,
      this.edges[hiIndex].from.coordinates,
      this.edges[iNext].from.coordinates
    );
    if (disc === 0)
      return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
    return disc > 0;
  }
  /**
   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
   *
   * @memberof EdgeRing
   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
   */
  toMultiPoint() {
    return multiPoint(this.edges.map((edge) => edge.from.coordinates));
  }
  /**
   * Creates a Polygon representing the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
   */
  toPolygon() {
    if (this.polygon)
      return this.polygon;
    const coordinates = this.edges.map((edge) => edge.from.coordinates);
    coordinates.push(this.edges[0].from.coordinates);
    return this.polygon = polygon([coordinates]);
  }
  /**
   * Calculates the envelope of the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - envelope
   */
  getEnvelope() {
    if (this.envelope)
      return this.envelope;
    return this.envelope = envelope(this.toPolygon());
  }
  /**
   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
   *
   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
   *
   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
   */
  static findEdgeRingContaining(testEdgeRing, shellList) {
    const testEnvelope = testEdgeRing.getEnvelope();
    let minEnvelope, minShell;
    shellList.forEach((shell) => {
      const tryEnvelope = shell.getEnvelope();
      if (minShell)
        minEnvelope = minShell.getEnvelope();
      if (envelopeIsEqual(tryEnvelope, testEnvelope))
        return;
      if (envelopeContains(tryEnvelope, testEnvelope)) {
        const testEdgeRingCoordinates = testEdgeRing.map(
          (edge) => edge.from.coordinates
        );
        let testPoint;
        for (const pt of testEdgeRingCoordinates) {
          if (!shell.some((edge) => coordinatesEqual(pt, edge.from.coordinates))) {
            testPoint = pt;
          }
        }
        if (testPoint && shell.inside(point(testPoint))) {
          if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
            minShell = shell;
        }
      }
    });
    return minShell;
  }
  /**
   * Checks if the point is inside the edgeRing
   *
   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
   * @returns {boolean} - True if it is inside, False otherwise
   */
  inside(pt) {
    return booleanPointInPolygon(pt, this.toPolygon());
  }
};
function validateGeoJson(geoJson) {
  if (!geoJson)
    throw new Error("No geojson passed");
  if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
    throw new Error(
      `Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`
    );
}
var Graph = class _Graph {
  /**
   * Creates a graph from a GeoJSON.
   *
   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index
   * @returns {Graph} - The newly created graph
   * @throws {Error} if geoJson is invalid.
   */
  static fromGeoJson(geoJson) {
    validateGeoJson(geoJson);
    const graph = new _Graph();
    flattenEach(geoJson, (feature2) => {
      featureOf(feature2, "LineString", "Graph::fromGeoJson");
      coordReduce(feature2, (prev, cur) => {
        if (prev) {
          const start = graph.getNode(prev), end = graph.getNode(cur);
          graph.addEdge(start, end);
        }
        return cur;
      });
    });
    return graph;
  }
  /**
   * Creates or get a Node.
   *
   * @param {number[]} coordinates - Coordinates of the node
   * @returns {Node} - The created or stored node
   */
  getNode(coordinates) {
    const id = Node2.buildId(coordinates);
    let node = this.nodes[id];
    if (!node)
      node = this.nodes[id] = new Node2(coordinates);
    return node;
  }
  /**
   * Adds an Edge and its symetricall.
   *
   * Edges are added symetrically, i.e.: we also add its symetric
   *
   * @param {Node} from - Node which starts the Edge
   * @param {Node} to - Node which ends the Edge
   */
  addEdge(from, to) {
    const edge = new Edge(from, to), symetricEdge = edge.getSymetric();
    this.edges.push(edge);
    this.edges.push(symetricEdge);
  }
  constructor() {
    this.edges = [];
    this.nodes = {};
  }
  /**
   * Removes Dangle Nodes (nodes with grade 1).
   */
  deleteDangles() {
    Object.keys(this.nodes).map((id) => this.nodes[id]).forEach((node) => this._removeIfDangle(node));
  }
  /**
   * Check if node is dangle, if so, remove it.
   *
   * It calls itself recursively, removing a dangling node might cause another dangling node
   *
   * @param {Node} node - Node to check if it's a dangle
   */
  _removeIfDangle(node) {
    if (node.innerEdges.length <= 1) {
      const outerNodes = node.getOuterEdges().map((e) => e.to);
      this.removeNode(node);
      outerNodes.forEach((n) => this._removeIfDangle(n));
    }
  }
  /**
   * Delete cut-edges (bridge edges).
   *
   * The graph will be traversed, all the edges will be labeled according the ring
   * in which they are. (The label is a number incremented by 1). Edges with the same
   * label are cut-edges.
   */
  deleteCutEdges() {
    this._computeNextCWEdges();
    this._findLabeledEdgeRings();
    this.edges.forEach((edge) => {
      if (edge.label === edge.symetric.label) {
        this.removeEdge(edge.symetric);
        this.removeEdge(edge);
      }
    });
  }
  /**
   * Set the `next` property of each Edge.
   *
   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.
   * OuterEdges are sorted CCW.
   *
   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph
   */
  _computeNextCWEdges(node) {
    if (typeof node === "undefined") {
      Object.keys(this.nodes).forEach(
        (id) => this._computeNextCWEdges(this.nodes[id])
      );
    } else {
      node.getOuterEdges().forEach((edge, i) => {
        node.getOuterEdge(
          (i === 0 ? node.getOuterEdges().length : i) - 1
        ).symetric.next = edge;
      });
    }
  }
  /**
   * Computes the next edge pointers going CCW around the given node, for the given edgering label.
   *
   * This algorithm has the effect of converting maximal edgerings into minimal edgerings
   *
   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,
   * could be written in a more javascript way.
   *
   * @param {Node} node - Node
   * @param {number} label - Ring's label
   */
  _computeNextCCWEdges(node, label) {
    const edges2 = node.getOuterEdges();
    let firstOutDE, prevInDE;
    for (let i = edges2.length - 1; i >= 0; --i) {
      let de2 = edges2[i], sym = de2.symetric, outDE, inDE;
      if (de2.label === label)
        outDE = de2;
      if (sym.label === label)
        inDE = sym;
      if (!outDE || !inDE)
        continue;
      if (inDE)
        prevInDE = inDE;
      if (outDE) {
        if (prevInDE) {
          prevInDE.next = outDE;
          prevInDE = void 0;
        }
        if (!firstOutDE)
          firstOutDE = outDE;
      }
    }
    if (prevInDE)
      prevInDE.next = firstOutDE;
  }
  /**
   * Finds rings and labels edges according to which rings are.
   *
   * The label is a number which is increased for each ring.
   *
   * @returns {Edge[]} edges that start rings
   */
  _findLabeledEdgeRings() {
    const edgeRingStarts = [];
    let label = 0;
    this.edges.forEach((edge) => {
      if (edge.label >= 0)
        return;
      edgeRingStarts.push(edge);
      let e = edge;
      do {
        e.label = label;
        e = e.next;
      } while (!edge.isEqual(e));
      label++;
    });
    return edgeRingStarts;
  }
  /**
   * Computes the EdgeRings formed by the edges in this graph.
   *
   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.
   */
  getEdgeRings() {
    this._computeNextCWEdges();
    this.edges.forEach((edge) => {
      edge.label = void 0;
    });
    this._findLabeledEdgeRings().forEach((edge) => {
      this._findIntersectionNodes(edge).forEach((node) => {
        this._computeNextCCWEdges(node, edge.label);
      });
    });
    const edgeRingList = [];
    this.edges.forEach((edge) => {
      if (edge.ring)
        return;
      edgeRingList.push(this._findEdgeRing(edge));
    });
    return edgeRingList;
  }
  /**
   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.
   *
   * @param {Node} startEdge - Start Edge of the Ring
   * @returns {Node[]} - intersection nodes
   */
  _findIntersectionNodes(startEdge) {
    const intersectionNodes = [];
    let edge = startEdge;
    do {
      let degree = 0;
      edge.from.getOuterEdges().forEach((e) => {
        if (e.label === startEdge.label)
          ++degree;
      });
      if (degree > 1)
        intersectionNodes.push(edge.from);
      edge = edge.next;
    } while (!startEdge.isEqual(edge));
    return intersectionNodes;
  }
  /**
   * Get the edge-ring which starts from the provided Edge.
   *
   * @param {Edge} startEdge - starting edge of the edge ring
   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.
   */
  _findEdgeRing(startEdge) {
    let edge = startEdge;
    const edgeRing = new EdgeRing();
    do {
      edgeRing.push(edge);
      edge.ring = edgeRing;
      edge = edge.next;
    } while (!startEdge.isEqual(edge));
    return edgeRing;
  }
  /**
   * Removes a node from the Graph.
   *
   * It also removes edges asociated to that node
   * @param {Node} node - Node to be removed
   */
  removeNode(node) {
    node.getOuterEdges().forEach((edge) => this.removeEdge(edge));
    node.innerEdges.forEach((edge) => this.removeEdge(edge));
    delete this.nodes[node.id];
  }
  /**
   * Remove edge from the graph and deletes the edge.
   *
   * @param {Edge} edge - Edge to be removed
   */
  removeEdge(edge) {
    this.edges = this.edges.filter((e) => !e.isEqual(edge));
    edge.deleteEdge();
  }
};
function polygonize(geoJson) {
  const graph = Graph.fromGeoJson(geoJson);
  graph.deleteDangles();
  graph.deleteCutEdges();
  const holes = [], shells = [];
  graph.getEdgeRings().filter((edgeRing) => edgeRing.isValid()).forEach((edgeRing) => {
    if (edgeRing.isHole())
      holes.push(edgeRing);
    else
      shells.push(edgeRing);
  });
  holes.forEach((hole) => {
    if (EdgeRing.findEdgeRingContaining(hole, shells))
      shells.push(hole);
  });
  return featureCollection(shells.map((shell) => shell.toPolygon()));
}

// ../node_modules/.pnpm/@turf+polygon-smooth@7.1.0/node_modules/@turf/polygon-smooth/dist/esm/index.js
function polygonSmooth(inputPolys, options) {
  options = options || {};
  options.iterations = options.iterations || 1;
  const { iterations } = options;
  const outPolys = [];
  if (!inputPolys)
    throw new Error("inputPolys is required");
  geomEach(inputPolys, function(geom, geomIndex, properties) {
    if (geom.type === "Polygon") {
      let outCoords = [[]];
      for (let i = 0; i < iterations; i++) {
        let tempOutput = [];
        let poly = geom;
        if (i > 0) {
          poly = polygon(outCoords).geometry;
        }
        processPolygon(poly, tempOutput);
        outCoords = tempOutput.slice(0);
      }
      outPolys.push(polygon(outCoords, properties));
    } else if (geom.type === "MultiPolygon") {
      let outCoords = [[[]]];
      for (let y2 = 0; y2 < iterations; y2++) {
        let tempOutput = [];
        let poly = geom;
        if (y2 > 0) {
          poly = multiPolygon(outCoords).geometry;
        }
        processMultiPolygon(poly, tempOutput);
        outCoords = tempOutput.slice(0);
      }
      outPolys.push(multiPolygon(outCoords, properties));
    } else {
      throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
    }
  });
  return featureCollection(outPolys);
}
function processPolygon(poly, tempOutput) {
  var previousCoord;
  var previousGeometryIndex;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (previousGeometryIndex !== geometryIndex) {
        tempOutput.push([]);
      } else {
        var p0x = previousCoord[0];
        var p0y = previousCoord[1];
        var p1x = currentCoord[0];
        var p1y = currentCoord[1];
        tempOutput[geometryIndex].push([
          0.75 * p0x + 0.25 * p1x,
          0.75 * p0y + 0.25 * p1y
        ]);
        tempOutput[geometryIndex].push([
          0.25 * p0x + 0.75 * p1x,
          0.25 * p0y + 0.75 * p1y
        ]);
      }
      previousCoord = currentCoord;
      previousGeometryIndex = geometryIndex;
    },
    false
  );
  tempOutput.forEach(function(ring) {
    ring.push(ring[0]);
  });
}
function processMultiPolygon(poly, tempOutput) {
  let previousCoord;
  let previousMultiFeatureIndex;
  let previousGeometryIndex;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (previousMultiFeatureIndex !== multiFeatureIndex) {
        tempOutput.push([[]]);
      } else if (previousGeometryIndex !== geometryIndex) {
        tempOutput[multiFeatureIndex].push([]);
      } else {
        var p0x = previousCoord[0];
        var p0y = previousCoord[1];
        var p1x = currentCoord[0];
        var p1y = currentCoord[1];
        tempOutput[multiFeatureIndex][geometryIndex].push([
          0.75 * p0x + 0.25 * p1x,
          0.75 * p0y + 0.25 * p1y
        ]);
        tempOutput[multiFeatureIndex][geometryIndex].push([
          0.25 * p0x + 0.75 * p1x,
          0.25 * p0y + 0.75 * p1y
        ]);
      }
      previousCoord = currentCoord;
      previousMultiFeatureIndex = multiFeatureIndex;
      previousGeometryIndex = geometryIndex;
    },
    false
  );
  tempOutput.forEach(function(poly2) {
    poly2.forEach(function(ring) {
      ring.push(ring[0]);
    });
  });
}

// ../node_modules/.pnpm/@turf+polygon-tangents@7.1.0/node_modules/@turf/polygon-tangents/dist/esm/index.js
function polygonTangents(pt, polygon2) {
  const pointCoords = getCoords(pt);
  const polyCoords = getCoords(polygon2);
  let rtan = [];
  let ltan = [];
  let eprev;
  const bbox3 = bbox(polygon2);
  let nearestPtIndex = 0;
  let nearest = null;
  if (pointCoords[0] > bbox3[0] && pointCoords[0] < bbox3[2] && pointCoords[1] > bbox3[1] && pointCoords[1] < bbox3[3]) {
    nearest = nearestPoint(pt, explode2(polygon2));
    nearestPtIndex = nearest.properties.featureIndex;
  }
  const type = getType(polygon2);
  switch (type) {
    case "Polygon":
      rtan = polyCoords[0][nearestPtIndex];
      ltan = polyCoords[0][0];
      if (nearest !== null) {
        if (nearest.geometry.coordinates[1] < pointCoords[1])
          ltan = polyCoords[0][nearestPtIndex];
      }
      eprev = isLeft(
        polyCoords[0][0],
        polyCoords[0][polyCoords[0].length - 1],
        pointCoords
      );
      [rtan, ltan] = processPolygon2(
        polyCoords[0],
        pointCoords,
        eprev,
        rtan,
        ltan
      );
      break;
    case "MultiPolygon":
      var closestFeature = 0;
      var closestVertex = 0;
      var verticesCounted = 0;
      for (var i = 0; i < polyCoords[0].length; i++) {
        closestFeature = i;
        var verticeFound = false;
        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
          closestVertex = i2;
          if (verticesCounted === nearestPtIndex) {
            verticeFound = true;
            break;
          }
          verticesCounted++;
        }
        if (verticeFound)
          break;
      }
      rtan = polyCoords[0][closestFeature][closestVertex];
      ltan = polyCoords[0][closestFeature][closestVertex];
      eprev = isLeft(
        polyCoords[0][0][0],
        polyCoords[0][0][polyCoords[0][0].length - 1],
        pointCoords
      );
      polyCoords.forEach(function(ring) {
        [rtan, ltan] = processPolygon2(ring[0], pointCoords, eprev, rtan, ltan);
      });
      break;
  }
  return featureCollection([point(rtan), point(ltan)]);
}
function processPolygon2(polygonCoords, ptCoords, eprev, rtan, ltan) {
  for (let i = 0; i < polygonCoords.length; i++) {
    const currentCoords = polygonCoords[i];
    let nextCoordPair = polygonCoords[i + 1];
    if (i === polygonCoords.length - 1) {
      nextCoordPair = polygonCoords[0];
    }
    const enext = isLeft(currentCoords, nextCoordPair, ptCoords);
    if (eprev <= 0 && enext > 0) {
      if (!isBelow(ptCoords, currentCoords, rtan)) {
        rtan = currentCoords;
      }
    } else if (eprev > 0 && enext <= 0) {
      if (!isAbove(ptCoords, currentCoords, ltan)) {
        ltan = currentCoords;
      }
    }
    eprev = enext;
  }
  return [rtan, ltan];
}
function isAbove(point1, point2, point3) {
  return isLeft(point1, point2, point3) > 0;
}
function isBelow(point1, point2, point3) {
  return isLeft(point1, point2, point3) < 0;
}
function isLeft(point1, point2, point3) {
  return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);
}

// ../node_modules/.pnpm/@turf+projection@7.1.0/node_modules/@turf/projection/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  toMercator: () => toMercator,
  toWgs84: () => toWgs84
});
function toMercator(geojson, options = {}) {
  return convert(geojson, "mercator", options);
}
function toWgs84(geojson, options = {}) {
  return convert(geojson, "wgs84", options);
}
function convert(geojson, projection2, options = {}) {
  options = options || {};
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (Array.isArray(geojson) && isNumber(geojson[0]))
    geojson = projection2 === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
  else {
    if (mutate !== true)
      geojson = clone(geojson);
    coordEach(geojson, function(coord) {
      var newCoord = projection2 === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
      coord[0] = newCoord[0];
      coord[1] = newCoord[1];
    });
  }
  return geojson;
}
function convertToMercator(lonLat) {
  var D2R2 = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
  var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign2(lonLat[0]) * 360;
  var xy = [
    A * adjusted * D2R2,
    A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R2))
  ];
  if (xy[0] > MAXEXTENT)
    xy[0] = MAXEXTENT;
  if (xy[0] < -MAXEXTENT)
    xy[0] = -MAXEXTENT;
  if (xy[1] > MAXEXTENT)
    xy[1] = MAXEXTENT;
  if (xy[1] < -MAXEXTENT)
    xy[1] = -MAXEXTENT;
  return xy;
}
function convertToWgs84(xy) {
  var R2D2 = 180 / Math.PI;
  var A = 6378137;
  return [
    xy[0] * R2D2 / A,
    (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D2
  ];
}
function sign2(x2) {
  return x2 < 0 ? -1 : x2 > 0 ? 1 : 0;
}

// ../node_modules/.pnpm/@turf+quadrat-analysis@7.1.0/node_modules/@turf/quadrat-analysis/dist/esm/index.js
function quadratAnalysis(pointFeatureSet, options) {
  options = options || {};
  const studyBbox = options.studyBbox || bbox(pointFeatureSet);
  const confidenceLevel = options.confidenceLevel || 20;
  const points2 = pointFeatureSet.features;
  const numOfPoints = points2.length;
  const sizeOfArea = area(bboxPolygon(studyBbox));
  const lengthOfSide = Math.sqrt(sizeOfArea / numOfPoints * 2);
  const grid = squareGrid(studyBbox, lengthOfSide, {
    units: "meters"
  });
  const quadrats = grid.features;
  const quadratIdDict = {};
  for (let i = 0; i < quadrats.length; i++) {
    quadratIdDict[i] = {
      box: bbox(quadrats[i]),
      cnt: 0
    };
  }
  let sumOfPoint = 0;
  for (const pt of points2) {
    for (const key of Object.keys(quadratIdDict)) {
      const box = quadratIdDict[key].box;
      if (inBBox2(getCoord(pt), box)) {
        quadratIdDict[key].cnt += 1;
        sumOfPoint += 1;
        break;
      }
    }
  }
  let maxCnt = 0;
  for (const key of Object.keys(quadratIdDict)) {
    const cnt = quadratIdDict[key].cnt;
    if (cnt > maxCnt) {
      maxCnt = cnt;
    }
  }
  const expectedDistribution = [];
  const numOfQuadrat = Object.keys(quadratIdDict).length;
  const lambda = sumOfPoint / numOfQuadrat;
  let cumulativeProbility = 0;
  for (let x2 = 0; x2 < maxCnt + 1; x2++) {
    cumulativeProbility += Math.exp(-lambda) * Math.pow(lambda, x2) / factorial(x2);
    expectedDistribution.push(cumulativeProbility);
  }
  const observedDistribution = [];
  let cumulativeObservedQuads = 0;
  for (let x2 = 0; x2 < maxCnt + 1; x2++) {
    for (const key of Object.keys(quadratIdDict)) {
      if (quadratIdDict[key].cnt === x2) {
        cumulativeObservedQuads += 1;
      }
    }
    const p = cumulativeObservedQuads / numOfQuadrat;
    observedDistribution.push(p);
  }
  let maxDifference = 0;
  for (let x2 = 0; x2 < maxCnt + 1; x2++) {
    const difference3 = Math.abs(
      expectedDistribution[x2] - observedDistribution[x2]
    );
    if (difference3 > maxDifference) {
      maxDifference = difference3;
    }
  }
  const k = K_TABLE[confidenceLevel];
  const criticalValue = k / Math.sqrt(numOfQuadrat);
  const result = {
    criticalValue,
    isRandom: true,
    maxAbsoluteDifference: maxDifference,
    observedDistribution
  };
  if (maxDifference > criticalValue) {
    result.isRandom = false;
  }
  return result;
}
var K_TABLE = {
  20: 1.07275,
  15: 1.13795,
  10: 1.22385,
  5: 1.3581,
  2: 1.51743,
  1: 1.62762
};
function inBBox2(pt, bbox3) {
  return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
}
function factorial(num) {
  const f = [];
  function inner(n) {
    if (n === 0 || n === 1) {
      return 1;
    }
    if (f[n] > 0) {
      return f[n];
    }
    return f[n] = inner(n - 1) * n;
  }
  return inner(num);
}

// ../node_modules/.pnpm/@turf+random@7.1.0/node_modules/@turf/random/dist/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  randomLineString: () => randomLineString,
  randomPoint: () => randomPoint,
  randomPolygon: () => randomPolygon,
  randomPosition: () => randomPosition
});
function randomPosition(bbox3) {
  checkBBox(bbox3);
  return randomPositionUnchecked(bbox3);
}
function randomPositionUnchecked(bbox3) {
  if (Array.isArray(bbox3)) {
    return coordInBBox(bbox3);
  }
  if (bbox3 && bbox3.bbox) {
    return coordInBBox(bbox3.bbox);
  }
  return [lon(), lat()];
}
function checkBBox(bbox3) {
  if (bbox3 == null) {
    return;
  } else if (Array.isArray(bbox3)) {
    validateBBox(bbox3);
  } else if (bbox3.bbox != null) {
    validateBBox(bbox3.bbox);
  }
}
function randomPoint(count, options = {}) {
  checkBBox(options.bbox);
  if (count === void 0 || count === null) {
    count = 1;
  }
  const features = [];
  for (let i = 0; i < count; i++) {
    features.push(point(randomPositionUnchecked(options.bbox)));
  }
  return featureCollection(features);
}
function randomPolygon(count, options = {}) {
  checkBBox(options.bbox);
  if (count === void 0 || count === null) {
    count = 1;
  }
  if (options.bbox === void 0 || options.bbox === null) {
    options.bbox = [-180, -90, 180, 90];
  }
  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {
    options.num_vertices = 10;
  }
  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {
    options.max_radial_length = 10;
  }
  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);
  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);
  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);
  if (options.max_radial_length > maxRadius) {
    throw new Error("max_radial_length is greater than the radius of the bbox");
  }
  const paddedBbox = [
    options.bbox[0] + options.max_radial_length,
    options.bbox[1] + options.max_radial_length,
    options.bbox[2] - options.max_radial_length,
    options.bbox[3] - options.max_radial_length
  ];
  const features = [];
  for (let i = 0; i < count; i++) {
    let vertices = [];
    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);
    circleOffsets.forEach((cur, index2, arr) => {
      arr[index2] = index2 > 0 ? cur + arr[index2 - 1] : cur;
    });
    circleOffsets.forEach((cur) => {
      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
      const radialScaler = Math.random();
      vertices.push([
        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
        radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
      ]);
    });
    vertices[vertices.length - 1] = vertices[0];
    vertices = vertices.map(
      vertexToCoordinate(randomPositionUnchecked(paddedBbox))
    );
    features.push(polygon([vertices]));
  }
  return featureCollection(features);
}
function randomLineString(count, options = {}) {
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  const bbox3 = options.bbox;
  checkBBox(bbox3);
  let num_vertices = options.num_vertices;
  let max_length = options.max_length;
  let max_rotation = options.max_rotation;
  if (count === void 0 || count === null) {
    count = 1;
  }
  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
    num_vertices = 10;
  }
  if (!isNumber(max_length) || max_length === void 0) {
    max_length = 1e-4;
  }
  if (!isNumber(max_rotation) || max_rotation === void 0) {
    max_rotation = Math.PI / 8;
  }
  const features = [];
  for (let i = 0; i < count; i++) {
    const startingPoint = randomPositionUnchecked(bbox3);
    const vertices = [startingPoint];
    for (let j = 0; j < num_vertices - 1; j++) {
      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan(
        (vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0])
      );
      const angle2 = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
      const distance2 = Math.random() * max_length;
      vertices.push([
        vertices[j][0] + distance2 * Math.cos(angle2),
        vertices[j][1] + distance2 * Math.sin(angle2)
      ]);
    }
    features.push(lineString(vertices));
  }
  return featureCollection(features);
}
function vertexToCoordinate(hub) {
  return (cur) => {
    return [cur[0] + hub[0], cur[1] + hub[1]];
  };
}
function rnd() {
  return Math.random() - 0.5;
}
function lon() {
  return rnd() * 360;
}
function lat() {
  return rnd() * 180;
}
function coordInBBox(bbox3) {
  return [
    Math.random() * (bbox3[2] - bbox3[0]) + bbox3[0],
    Math.random() * (bbox3[3] - bbox3[1]) + bbox3[1]
  ];
}

// ../node_modules/.pnpm/@turf+rewind@7.1.0/node_modules/@turf/rewind/dist/esm/index.js
function rewind(geojson, options = {}) {
  var _a, _b;
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const mutate = (_a = options.mutate) != null ? _a : false;
  const reverse2 = (_b = options.reverse) != null ? _b : false;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof reverse2 !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (!mutate && geojson.type !== "Point" && geojson.type !== "MultiPoint") {
    geojson = clone(geojson);
  }
  const results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse2);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        const rewoundFeature = rewindFeature(feature2, reverse2);
        featureEach(rewoundFeature, function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse2);
}
function rewindFeature(geojson, reverse2) {
  const type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse2);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse2);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse2);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse2);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse2);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse2) {
  if (booleanClockwise(coords) === reverse2)
    coords.reverse();
}
function rewindPolygon(coords, reverse2) {
  if (booleanClockwise(coords[0]) !== reverse2) {
    coords[0].reverse();
  }
  for (let i = 1; i < coords.length; i++) {
    if (booleanClockwise(coords[i]) === reverse2) {
      coords[i].reverse();
    }
  }
}

// ../node_modules/.pnpm/@turf+sample@7.1.0/node_modules/@turf/sample/dist/esm/index.js
function sample(fc, num) {
  if (!fc)
    throw new Error("fc is required");
  if (num === null || num === void 0)
    throw new Error("num is required");
  if (typeof num !== "number")
    throw new Error("num must be a number");
  var outFC = featureCollection(getRandomSubarray(fc.features, num));
  return outFC;
}
function getRandomSubarray(arr, size) {
  var shuffled = arr.slice(0), i = arr.length, min = i - size, temp2, index2;
  while (i-- > min) {
    index2 = Math.floor((i + 1) * Math.random());
    temp2 = shuffled[index2];
    shuffled[index2] = shuffled[i];
    shuffled[i] = temp2;
  }
  return shuffled.slice(min);
}

// ../node_modules/.pnpm/@turf+sector@7.1.0/node_modules/@turf/sector/dist/esm/index.js
function sector(center2, radius, bearing1, bearing2, options = {}) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const properties = options.properties;
  if (!center2)
    throw new Error("center is required");
  if (bearing1 === void 0 || bearing1 === null)
    throw new Error("bearing1 is required");
  if (bearing2 === void 0 || bearing2 === null)
    throw new Error("bearing2 is required");
  if (!radius)
    throw new Error("radius is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (convertAngleTo3602(bearing1) === convertAngleTo3602(bearing2)) {
    return circle2(center2, radius, options);
  }
  const coords = getCoords(center2);
  const arc = lineArc(center2, radius, bearing1, bearing2, options);
  const sliceCoords = [[coords]];
  coordEach(arc, function(currentCoords) {
    sliceCoords[0].push(currentCoords);
  });
  sliceCoords[0].push(coords);
  return polygon(sliceCoords, properties);
}
function convertAngleTo3602(alpha) {
  let beta = alpha % 360;
  if (beta < 0) {
    beta += 360;
  }
  return beta;
}

// ../node_modules/.pnpm/@turf+transform-scale@7.1.0/node_modules/@turf/transform-scale/dist/esm/index.js
function transformScale(geojson, factor, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const origin = options.origin || "centroid";
  const mutate = options.mutate || false;
  if (!geojson)
    throw new Error("geojson required");
  if (typeof factor !== "number" || factor <= 0)
    throw new Error("invalid factor");
  const originIsPoint = Array.isArray(origin) || typeof origin === "object";
  if (mutate !== true)
    geojson = clone(geojson);
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    featureEach(geojson, function(feature2, index2) {
      geojson.features[index2] = scale2(
        feature2,
        factor,
        origin
      );
    });
    return geojson;
  }
  return scale2(geojson, factor, origin);
}
function scale2(feature2, factor, origin) {
  const isPoint = getType(feature2) === "Point";
  const originCoord = defineOrigin(feature2, origin);
  if (factor === 1 || isPoint)
    return feature2;
  coordEach(feature2, function(coord) {
    const originalDistance = rhumbDistance(originCoord, coord);
    const bearing2 = rhumbBearing(originCoord, coord);
    const newDistance = originalDistance * factor;
    const newCoord = getCoords(
      rhumbDestination(originCoord, newDistance, bearing2)
    );
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3)
      coord[2] *= factor;
  });
  delete feature2.bbox;
  return feature2;
}
function defineOrigin(geojson, origin) {
  if (origin === void 0 || origin === null)
    origin = "centroid";
  if (Array.isArray(origin) || typeof origin === "object")
    return getCoord(origin);
  const bbox3 = geojson.bbox ? geojson.bbox : bbox(geojson, { recompute: true });
  const west = bbox3[0];
  const south = bbox3[1];
  const east = bbox3[2];
  const north = bbox3[3];
  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return point([east, north]);
    case "center":
      return center(geojson);
    case void 0:
    case null:
    case "centroid":
      return centroid(geojson);
    default:
      throw new Error("invalid origin");
  }
}

// ../node_modules/.pnpm/@turf+shortest-path@7.1.0/node_modules/@turf/shortest-path/dist/esm/index.js
function pathTo(node) {
  var curr = node, path = [];
  while (curr.parent) {
    path.unshift(curr);
    curr = curr.parent;
  }
  return path;
}
function getHeap() {
  return new BinaryHeap(function(node) {
    return node.f;
  });
}
var astar = {
  /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */
  search: function(graph, start, end, options) {
    var _a;
    graph.cleanDirty();
    options = options || {};
    var heuristic = options.heuristic || astar.heuristics.manhattan, closest = (_a = options.closest) != null ? _a : false;
    var openHeap = getHeap(), closestNode = start;
    start.h = heuristic(start, end);
    openHeap.push(start);
    while (openHeap.size() > 0) {
      var currentNode = openHeap.pop();
      if (currentNode === end) {
        return pathTo(currentNode);
      }
      currentNode.closed = true;
      var neighbors = graph.neighbors(currentNode);
      for (var i = 0, il = neighbors.length; i < il; ++i) {
        var neighbor = neighbors[i];
        if (neighbor.closed || neighbor.isWall()) {
          continue;
        }
        var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
        if (!beenVisited || gScore < neighbor.g) {
          neighbor.visited = true;
          neighbor.parent = currentNode;
          neighbor.h = neighbor.h || heuristic(neighbor, end);
          neighbor.g = gScore;
          neighbor.f = neighbor.g + neighbor.h;
          graph.markDirty(neighbor);
          if (closest) {
            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
              closestNode = neighbor;
            }
          }
          if (!beenVisited) {
            openHeap.push(neighbor);
          } else {
            openHeap.rescoreElement(neighbor);
          }
        }
      }
    }
    if (closest) {
      return pathTo(closestNode);
    }
    return [];
  },
  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
  heuristics: {
    manhattan: function(pos0, pos1) {
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return d1 + d2;
    },
    diagonal: function(pos0, pos1) {
      var D2 = 1;
      var D22 = Math.sqrt(2);
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return D2 * (d1 + d2) + (D22 - 2 * D2) * Math.min(d1, d2);
    }
  },
  cleanNode: function(node) {
    node.f = 0;
    node.g = 0;
    node.h = 0;
    node.visited = false;
    node.closed = false;
    node.parent = null;
  }
};
function Graph2(gridIn, options) {
  options = options || {};
  this.nodes = [];
  this.diagonal = !!options.diagonal;
  this.grid = [];
  for (var x2 = 0; x2 < gridIn.length; x2++) {
    this.grid[x2] = [];
    for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
      var node = new GridNode(x2, y2, row[y2]);
      this.grid[x2][y2] = node;
      this.nodes.push(node);
    }
  }
  this.init();
}
Graph2.prototype.init = function() {
  this.dirtyNodes = [];
  for (var i = 0; i < this.nodes.length; i++) {
    astar.cleanNode(this.nodes[i]);
  }
};
Graph2.prototype.cleanDirty = function() {
  for (var i = 0; i < this.dirtyNodes.length; i++) {
    astar.cleanNode(this.dirtyNodes[i]);
  }
  this.dirtyNodes = [];
};
Graph2.prototype.markDirty = function(node) {
  this.dirtyNodes.push(node);
};
Graph2.prototype.neighbors = function(node) {
  var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
  if (grid[x2 - 1] && grid[x2 - 1][y2]) {
    ret.push(grid[x2 - 1][y2]);
  }
  if (grid[x2 + 1] && grid[x2 + 1][y2]) {
    ret.push(grid[x2 + 1][y2]);
  }
  if (grid[x2] && grid[x2][y2 - 1]) {
    ret.push(grid[x2][y2 - 1]);
  }
  if (grid[x2] && grid[x2][y2 + 1]) {
    ret.push(grid[x2][y2 + 1]);
  }
  if (this.diagonal) {
    if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
      ret.push(grid[x2 - 1][y2 - 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
      ret.push(grid[x2 + 1][y2 - 1]);
    }
    if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
      ret.push(grid[x2 - 1][y2 + 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
      ret.push(grid[x2 + 1][y2 + 1]);
    }
  }
  return ret;
};
Graph2.prototype.toString = function() {
  var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
  for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
    rowDebug = [];
    row = nodes[x2];
    for (y2 = 0, l = row.length; y2 < l; y2++) {
      rowDebug.push(row[y2].weight);
    }
    graphString.push(rowDebug.join(" "));
  }
  return graphString.join("\n");
};
function GridNode(x2, y2, weight) {
  this.x = x2;
  this.y = y2;
  this.weight = weight;
}
GridNode.prototype.toString = function() {
  return "[" + this.x + " " + this.y + "]";
};
GridNode.prototype.getCost = function(fromNeighbor) {
  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
    return this.weight * 1.41421;
  }
  return this.weight;
};
GridNode.prototype.isWall = function() {
  return this.weight === 0;
};
function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.sinkDown(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
    }
    return result;
  },
  remove: function(node) {
    var i = this.content.indexOf(node);
    var end = this.content.pop();
    if (i !== this.content.length - 1) {
      this.content[i] = end;
      if (this.scoreFunction(end) < this.scoreFunction(node)) {
        this.sinkDown(i);
      } else {
        this.bubbleUp(i);
      }
    }
  },
  size: function() {
    return this.content.length;
  },
  rescoreElement: function(node) {
    this.sinkDown(this.content.indexOf(node));
  },
  sinkDown: function(n) {
    var element = this.content[n];
    while (n > 0) {
      var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  },
  bubbleUp: function(n) {
    var length3 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
    while (true) {
      var child2N = n + 1 << 1, child1N = child2N - 1;
      var swap2 = null, child1Score;
      if (child1N < length3) {
        var child1 = this.content[child1N];
        child1Score = this.scoreFunction(child1);
        if (child1Score < elemScore) {
          swap2 = child1N;
        }
      }
      if (child2N < length3) {
        var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
        if (child2Score < (swap2 === null ? elemScore : child1Score)) {
          swap2 = child2N;
        }
      }
      if (swap2 !== null) {
        this.content[n] = this.content[swap2];
        this.content[swap2] = element;
        n = swap2;
      } else {
        break;
      }
    }
  }
};
function shortestPath(start, end, options = {}) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  let obstacles = options.obstacles || featureCollection([]);
  let resolution = options.resolution || 100;
  if (!start)
    throw new Error("start is required");
  if (!end)
    throw new Error("end is required");
  if (resolution && (!isNumber(resolution) || resolution <= 0))
    throw new Error("options.resolution must be a number, greater than 0");
  const startCoord = getCoord(start);
  const endCoord = getCoord(end);
  start = point(startCoord);
  end = point(endCoord);
  if (obstacles.type === "FeatureCollection") {
    if (obstacles.features.length === 0) {
      return lineString([startCoord, endCoord]);
    }
  } else if (obstacles.type === "Polygon") {
    obstacles = featureCollection([feature(getGeom(obstacles))]);
  } else {
    throw new Error("invalid obstacles");
  }
  const collection = obstacles;
  collection.features.push(start);
  collection.features.push(end);
  const box = bbox(transformScale(bboxPolygon(bbox(collection)), 1.15));
  const [west, south, east, north] = box;
  const width = distance([west, south], [east, south], options);
  const division = width / resolution;
  collection.features.pop();
  collection.features.pop();
  const xFraction = division / distance([west, south], [east, south], options);
  const cellWidth = xFraction * (east - west);
  const yFraction = division / distance([west, south], [west, north], options);
  const cellHeight = yFraction * (north - south);
  const bboxHorizontalSide = east - west;
  const bboxVerticalSide = north - south;
  const columns = Math.floor(bboxHorizontalSide / cellWidth);
  const rows = Math.floor(bboxVerticalSide / cellHeight);
  const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
  const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
  const pointMatrix = [];
  const matrix = [];
  let closestToStart;
  let closestToEnd;
  let minDistStart = Infinity;
  let minDistEnd = Infinity;
  let currentY = north - deltaY;
  let r = 0;
  while (currentY >= south) {
    const matrixRow = [];
    const pointMatrixRow = [];
    let currentX = west + deltaX;
    let c = 0;
    while (currentX <= east) {
      const pt = point([currentX, currentY]);
      const isInsideObstacle = isInside2(pt, obstacles);
      matrixRow.push(isInsideObstacle ? 0 : 1);
      pointMatrixRow.push(currentX + "|" + currentY);
      const distStart = distance(pt, start);
      if (!isInsideObstacle && distStart < minDistStart) {
        minDistStart = distStart;
        closestToStart = { x: c, y: r };
      }
      const distEnd = distance(pt, end);
      if (!isInsideObstacle && distEnd < minDistEnd) {
        minDistEnd = distEnd;
        closestToEnd = { x: c, y: r };
      }
      currentX += cellWidth;
      c++;
    }
    matrix.push(matrixRow);
    pointMatrix.push(pointMatrixRow);
    currentY -= cellHeight;
    r++;
  }
  const graph = new Graph2(matrix, { diagonal: true });
  const startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
  const endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
  const result = astar.search(graph, startOnMatrix, endOnMatrix);
  const path = [startCoord];
  result.forEach(function(coord) {
    const coords = pointMatrix[coord.x][coord.y].split("|");
    path.push([+coords[0], +coords[1]]);
  });
  path.push(endCoord);
  return cleanCoords(lineString(path));
}
function isInside2(pt, polygons2) {
  for (let i = 0; i < polygons2.features.length; i++) {
    if (booleanPointInPolygon(pt, polygons2.features[i])) {
      return true;
    }
  }
  return false;
}

// ../node_modules/.pnpm/@turf+simplify@7.1.0/node_modules/@turf/simplify/dist/esm/index.js
function getSqDist(p1, p2) {
  var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
  var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
  if (dx !== 0 || dy !== 0) {
    var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x2 = p2[0];
      y2 = p2[1];
    } else if (t > 0) {
      x2 += dx * t;
      y2 += dy * t;
    }
  }
  dx = p[0] - x2;
  dy = p[1] - y2;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points2, sqTolerance) {
  var prevPoint = points2[0], newPoints = [prevPoint], point2;
  for (var i = 1, len = points2.length; i < len; i++) {
    point2 = points2[i];
    if (getSqDist(point2, prevPoint) > sqTolerance) {
      newPoints.push(point2);
      prevPoint = point2;
    }
  }
  if (prevPoint !== point2)
    newPoints.push(point2);
  return newPoints;
}
function simplifyDPStep(points2, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance, index2;
  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points2[i], points2[first], points2[last]);
    if (sqDist > maxSqDist) {
      index2 = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index2 - first > 1)
      simplifyDPStep(points2, first, index2, sqTolerance, simplified);
    simplified.push(points2[index2]);
    if (last - index2 > 1)
      simplifyDPStep(points2, index2, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points2, sqTolerance) {
  var last = points2.length - 1;
  var simplified = [points2[0]];
  simplifyDPStep(points2, 0, last, sqTolerance, simplified);
  simplified.push(points2[last]);
  return simplified;
}
function simplify(points2, tolerance, highestQuality) {
  if (points2.length <= 2)
    return points2;
  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points2 = highestQuality ? points2 : simplifyRadialDist(points2, sqTolerance);
  points2 = simplifyDouglasPeucker(points2, sqTolerance);
  return points2;
}
function simplify2(geojson, options = {}) {
  var _a, _b, _c;
  options = options != null ? options : {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const tolerance = (_a = options.tolerance) != null ? _a : 1;
  const highQuality = (_b = options.highQuality) != null ? _b : false;
  const mutate = (_c = options.mutate) != null ? _c : false;
  if (!geojson)
    throw new Error("geojson is required");
  if (tolerance && tolerance < 0)
    throw new Error("invalid tolerance");
  if (mutate !== true)
    geojson = clone(geojson);
  geomEach(geojson, function(geom) {
    simplifyGeom(geom, tolerance, highQuality);
  });
  return geojson;
}
function simplifyGeom(geometry2, tolerance, highQuality) {
  const type = geometry2.type;
  if (type === "Point" || type === "MultiPoint")
    return geometry2;
  cleanCoords(geometry2, { mutate: true });
  if (type !== "GeometryCollection") {
    switch (type) {
      case "LineString":
        geometry2.coordinates = simplify(
          geometry2.coordinates,
          tolerance,
          highQuality
        );
        break;
      case "MultiLineString":
        geometry2.coordinates = geometry2.coordinates.map(
          (lines) => simplify(lines, tolerance, highQuality)
        );
        break;
      case "Polygon":
        geometry2.coordinates = simplifyPolygon(
          geometry2.coordinates,
          tolerance,
          highQuality
        );
        break;
      case "MultiPolygon":
        geometry2.coordinates = geometry2.coordinates.map(
          (rings) => simplifyPolygon(rings, tolerance, highQuality)
        );
    }
  }
  return geometry2;
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
  return coordinates.map(function(ring) {
    if (ring.length < 4) {
      throw new Error("invalid polygon");
    }
    let ringTolerance = tolerance;
    let simpleRing = simplify(ring, ringTolerance, highQuality);
    while (!checkValidity(simpleRing)) {
      ringTolerance -= ringTolerance * 0.01;
      simpleRing = simplify(ring, ringTolerance, highQuality);
    }
    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
      simpleRing.push(simpleRing[0]);
    }
    return simpleRing;
  });
}
function checkValidity(ring) {
  if (ring.length < 3)
    return false;
  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}

// ../node_modules/.pnpm/@turf+standard-deviational-ellipse@7.1.0/node_modules/@turf/standard-deviational-ellipse/dist/esm/index.js
function standardDeviationalEllipse(points2, options) {
  var _a;
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const steps = options.steps || 64;
  const weightTerm = options.weight;
  const properties = options.properties || {};
  if (!isNumber(steps))
    throw new Error("steps must be a number");
  if (!isObject(properties))
    throw new Error("properties must be a number");
  const numberOfFeatures = coordAll(points2).length;
  const meanCenter = centerMean(points2, { weight: weightTerm });
  let xDeviationSquaredSum = 0;
  let yDeviationSquaredSum = 0;
  let xyDeviationSum = 0;
  featureEach(points2, function(point2) {
    var _a2;
    const weight = weightTerm ? ((_a2 = point2.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
    const deviation = getDeviations(getCoords(point2), getCoords(meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });
  const bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  const bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  const bigC = 2 * xyDeviationSum;
  const theta = Math.atan((bigA + bigB) / bigC);
  const thetaDeg = theta * 180 / Math.PI;
  let sigmaXsum = 0;
  let sigmaYsum = 0;
  let weightsum = 0;
  featureEach(points2, function(point2) {
    var _a2;
    const weight = weightTerm ? ((_a2 = point2.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
    const deviation = getDeviations(getCoords(point2), getCoords(meanCenter));
    sigmaXsum += Math.pow(
      deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
      2
    ) * weight;
    sigmaYsum += Math.pow(
      deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
      2
    ) * weight;
    weightsum += weight;
  });
  const sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
  const sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
  const theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps,
    properties
  });
  const pointsWithinEllipse = pointsWithinPolygon(
    points2,
    featureCollection([theEllipse])
  );
  const standardDeviationalEllipseProperties = {
    meanCenterCoordinates: getCoords(meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures
  };
  theEllipse.properties = (_a = theEllipse.properties) != null ? _a : {};
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
  return theEllipse;
}
function getDeviations(coordinates, center2) {
  return {
    x: coordinates[0] - center2[0],
    y: coordinates[1] - center2[1]
  };
}

// ../node_modules/.pnpm/@turf+tag@7.1.0/node_modules/@turf/tag/dist/esm/index.js
function tag(points2, polygons2, field, outField) {
  points2 = clone(points2);
  polygons2 = clone(polygons2);
  featureEach(points2, function(pt) {
    if (!pt.properties)
      pt.properties = {};
    featureEach(polygons2, function(poly) {
      if (pt.properties && poly.properties) {
        if (pt.properties[outField] === void 0) {
          if (booleanPointInPolygon(pt, poly))
            pt.properties[outField] = poly.properties[field];
        }
      }
    });
  });
  return points2;
}

// ../node_modules/.pnpm/@turf+tesselate@7.1.0/node_modules/@turf/tesselate/dist/esm/index.js
var import_earcut = __toESM(require_earcut());
function tesselate(poly) {
  if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
    throw new Error("input must be a Polygon or MultiPolygon");
  }
  const fc = {
    type: "FeatureCollection",
    features: []
  };
  if (poly.geometry.type === "Polygon") {
    fc.features = processPolygon3(poly.geometry.coordinates);
  } else {
    poly.geometry.coordinates.forEach(function(coordinates) {
      fc.features = fc.features.concat(processPolygon3(coordinates));
    });
  }
  return fc;
}
function processPolygon3(coordinates) {
  const data = flattenCoords(coordinates);
  const dim = 2;
  const result = (0, import_earcut.default)(data.vertices, data.holes, dim);
  const features = [];
  const vertices = [];
  result.forEach(function(vert, i2) {
    const index2 = result[i2];
    vertices.push([data.vertices[index2 * dim], data.vertices[index2 * dim + 1]]);
  });
  for (var i = 0; i < vertices.length; i += 3) {
    const coords = vertices.slice(i, i + 3);
    coords.push(vertices[i]);
    features.push(polygon([coords]));
  }
  return features;
}
function flattenCoords(data) {
  const dim = data[0][0].length, result = {
    vertices: [],
    holes: [],
    dimensions: dim
  };
  let holeIndex = 0;
  for (let i = 0; i < data.length; i++) {
    for (let j = 0; j < data[i].length; j++) {
      for (let d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
}

// ../node_modules/.pnpm/@turf+transform-translate@7.1.0/node_modules/@turf/transform-translate/dist/esm/index.js
function transformTranslate(geojson, distance2, direction, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  var zTranslation = options.zTranslation;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance2 === void 0 || distance2 === null || isNaN(distance2))
    throw new Error("distance is required");
  if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
    throw new Error("zTranslation is not a number");
  zTranslation = zTranslation !== void 0 ? zTranslation : 0;
  if (distance2 === 0 && zTranslation === 0)
    return geojson;
  if (direction === void 0 || direction === null || isNaN(direction))
    throw new Error("direction is required");
  if (distance2 < 0) {
    distance2 = -distance2;
    direction = direction + 180;
  }
  if (mutate === false || mutate === void 0)
    geojson = clone(geojson);
  coordEach(geojson, function(pointCoords) {
    var newCoords = getCoords(
      rhumbDestination(pointCoords, distance2, direction, { units })
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
    if (zTranslation && pointCoords.length === 3)
      pointCoords[2] += zTranslation;
  });
  return geojson;
}

// ../node_modules/.pnpm/@turf+union@7.1.0/node_modules/@turf/union/dist/esm/index.js
function union2(features, options = {}) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must have at least 2 geometries");
  }
  const unioned = index.union(geoms[0], ...geoms.slice(1));
  if (unioned.length === 0)
    return null;
  if (unioned.length === 1)
    return polygon(unioned[0], options.properties);
  else
    return multiPolygon(unioned, options.properties);
}

// ../node_modules/.pnpm/@turf+unkink-polygon@7.1.0/node_modules/@turf/unkink-polygon/dist/esm/index.js
function geojsonPolygonSelfIntersections(feature2, filterFn, useSpatialIndex) {
  if (feature2.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  if (useSpatialIndex === void 0)
    useSpatialIndex = 1;
  var coord = feature2.geometry.coordinates;
  var output = [];
  var seen = {};
  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
      }
    }
    var tree = new RBush();
    tree.load(allEdgesAsRbushTreeItems);
  }
  for (var ringA = 0; ringA < coord.length; ringA++) {
    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
        bboxOverlaps.forEach(function(bboxIsect) {
          var ring12 = bboxIsect.ring;
          var edge12 = bboxIsect.edge;
          ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
        });
      } else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
          }
        }
      }
    }
  }
  if (!filterFn)
    output = {
      type: "Feature",
      geometry: { type: "MultiPoint", coordinates: output }
    };
  return output;
  function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
    var start0 = coord[ring02][edge02];
    var end0 = coord[ring02][edge02 + 1];
    var start1 = coord[ring12][edge12];
    var end1 = coord[ring12][edge12 + 1];
    var isect = intersect3(start0, end0, start1, end1);
    if (isect === null)
      return;
    var frac0;
    var frac1;
    if (end0[0] !== start0[0]) {
      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
    } else {
      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
    }
    if (end1[0] !== start1[0]) {
      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
    } else {
      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
    }
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0)
      return;
    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }
    if (filterFn) {
      output.push(
        filterFn(
          isect,
          ring02,
          edge02,
          start0,
          end0,
          frac0,
          ring12,
          edge12,
          start1,
          end1,
          frac1,
          unique
        )
      );
    } else {
      output.push(isect);
    }
  }
  function rbushTreeItem(ring, edge) {
    var start = coord[ring][edge];
    var end = coord[ring][edge + 1];
    var minX;
    var maxX;
    var minY;
    var maxY;
    if (start[0] < end[0]) {
      minX = start[0];
      maxX = end[0];
    } else {
      minX = end[0];
      maxX = start[0];
    }
    if (start[1] < end[1]) {
      minY = start[1];
      maxY = end[1];
    } else {
      minY = end[1];
      maxY = start[1];
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      ring,
      edge
    };
  }
}
function intersect3(start0, end0, start1, end1) {
  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))
    return null;
  var x02 = start0[0], y02 = start0[1], x12 = end0[0], y12 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
  var denom = (x02 - x12) * (y2 - y3) - (y02 - y12) * (x2 - x3);
  if (denom === 0)
    return null;
  var x4 = ((x02 * y12 - y02 * x12) * (x2 - x3) - (x02 - x12) * (x2 * y3 - y2 * x3)) / denom;
  var y4 = ((x02 * y12 - y02 * x12) * (y2 - y3) - (y02 - y12) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}
function equalArrays(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length !== array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays(array1[i], array2[i]))
        return false;
    } else if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function simplepolygon(feature2) {
  if (feature2.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (feature2.geometry === void 0 || feature2.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (feature2.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  var numRings = feature2.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature2.geometry.coordinates[i];
    if (!equalArrays2(ring[0], ring[ring.length - 1])) {
      ring.push(ring[0]);
    }
    for (var j = 0; j < ring.length - 1; j++) {
      vertices.push(ring[j]);
    }
  }
  if (!isUnique(vertices))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var numvertices = vertices.length;
  var selfIsectsData = geojsonPolygonSelfIntersections(
    feature2,
    function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
      return [
        isect,
        ring0,
        edge0,
        start0,
        end0,
        frac0,
        ring1,
        edge1,
        start1,
        end1,
        frac1,
        unique
      ];
    }
  );
  var numSelfIsect = selfIsectsData.length;
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for (var i = 0; i < numRings; i++) {
      outputFeatureArray.push(
        polygon([feature2.geometry.coordinates[i]], {
          parent: -1,
          winding: windingOfRing(feature2.geometry.coordinates[i])
        })
      );
    }
    var output = featureCollection(outputFeatureArray);
    determineParents();
    setNetWinding();
    return output;
  }
  var pseudoVtxListByRingAndEdge = [];
  var isectList = [];
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature2.geometry.coordinates[i].length - 1; j++) {
      pseudoVtxListByRingAndEdge[i].push([
        new PseudoVtx(
          feature2.geometry.coordinates[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          1,
          [i, j],
          [i, modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          void 0
        )
      ]);
      isectList.push(
        new Isect(
          feature2.geometry.coordinates[i][j],
          [i, modulo(j - 1, feature2.geometry.coordinates[i].length - 1)],
          [i, j],
          void 0,
          void 0,
          false,
          true
        )
      );
    }
  }
  for (var i = 0; i < numSelfIsect; i++) {
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
      new PseudoVtx(
        selfIsectsData[i][0],
        selfIsectsData[i][5],
        [selfIsectsData[i][1], selfIsectsData[i][2]],
        [selfIsectsData[i][6], selfIsectsData[i][7]],
        void 0
      )
    );
    if (selfIsectsData[i][11])
      isectList.push(
        new Isect(
          selfIsectsData[i][0],
          [selfIsectsData[i][1], selfIsectsData[i][2]],
          [selfIsectsData[i][6], selfIsectsData[i][7]],
          void 0,
          void 0,
          true,
          true
        )
      );
  }
  var numIsect = isectList.length;
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
        return a.param < b.param ? -1 : 1;
      });
    }
  }
  var allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({
      minX: isectList[i].coord[0],
      minY: isectList[i].coord[1],
      maxX: isectList[i].coord[0],
      maxY: isectList[i].coord[1],
      index: i
    });
  }
  var isectRbushTree = new RBush();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
      }
    }
  }
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) {
          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else {
          if (equalArrays2(
            isectList[l].ringAndEdge1,
            pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
          )) {
            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  var queue = [];
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature2.geometry.coordinates[j].length - 1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
        var isectBeforeLeftIsect = k;
        break;
      }
    }
    var windingAtIsect = isConvex(
      [
        isectList[isectBeforeLeftIsect].coord,
        isectList[leftIsect].coord,
        isectList[isectAfterLeftIsect].coord
      ],
      true
    ) ? 1 : -1;
    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
  }
  queue.sort(function(a, b) {
    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
  });
  var outputFeatureArray = [];
  while (queue.length > 0) {
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    while (!equalArrays2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      var nxtIsectInQueue = void 0;
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].isect == nxtIsect) {
          nxtIsectInQueue = i;
          break;
        }
      }
      if (nxtIsectInQueue != void 0) {
        queue.splice(nxtIsectInQueue, 1);
      }
      if (equalArrays2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
    }
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    outputFeatureArray.push(
      polygon([currentOutputRingCoords], {
        index: currentOutputRing,
        parent: currentOutputRingParent,
        winding: currentOutputRingWinding,
        netWinding: void 0
      })
    );
  }
  var output = featureCollection(outputFeatureArray);
  determineParents();
  setNetWinding();
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1)
        featuresWithoutParent.push(i2);
    }
    if (featuresWithoutParent.length > 1) {
      for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j2 = 0; j2 < output.features.length; j2++) {
          if (featuresWithoutParent[i2] == j2)
            continue;
          if (booleanPointInPolygon(
            output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],
            output.features[j2],
            { ignoreBoundary: true }
          )) {
            if (area(output.features[j2]) < parentArea) {
              parent = j2;
            }
          }
        }
        output.features[featuresWithoutParent[i2]].properties.parent = parent;
      }
    }
  }
  function setNetWinding() {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1) {
        var netWinding = output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  function setNetWindingOfChildren(parent, ParentNetWinding) {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == parent) {
        var netWinding = ParentNetWinding + output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
  this.coord = coord;
  this.param = param;
  this.ringAndEdgeIn = ringAndEdgeIn;
  this.ringAndEdgeOut = ringAndEdgeOut;
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
  this.coord = coord;
  this.ringAndEdge1 = ringAndEdge1;
  this.ringAndEdge2 = ringAndEdge2;
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
  this.ringAndEdge1Walkable = ringAndEdge1Walkable;
  this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
  if (typeof righthanded === "undefined")
    righthanded = true;
  if (pts.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return d >= 0 == righthanded;
}
function windingOfRing(ring) {
  var leftVtx = 0;
  for (var i = 0; i < ring.length - 1; i++) {
    if (ring[i][0] < ring[leftVtx][0])
      leftVtx = i;
  }
  if (isConvex(
    [
      ring[modulo(leftVtx - 1, ring.length - 1)],
      ring[leftVtx],
      ring[modulo(leftVtx + 1, ring.length - 1)]
    ],
    true
  )) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding;
}
function equalArrays2(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length != array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays2(array1[i], array2[i]))
        return false;
    } else if (array1[i] != array2[i]) {
      return false;
    }
  }
  return true;
}
function modulo(n, m) {
  return (n % m + m) % m;
}
function isUnique(array2) {
  var u4 = {};
  var isUnique2 = 1;
  for (var i = 0, l = array2.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(u4, array2[i])) {
      isUnique2 = 0;
      break;
    }
    u4[array2[i]] = 1;
  }
  return isUnique2;
}
function unkinkPolygon(geojson) {
  var features = [];
  flattenEach(geojson, function(feature2) {
    if (feature2.geometry.type !== "Polygon")
      return;
    featureEach(simplepolygon(feature2), function(poly) {
      features.push(polygon(poly.geometry.coordinates, feature2.properties));
    });
  });
  return featureCollection(features);
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/constant.js
function constant_default3(x2) {
  return function() {
    return x2;
  };
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/point.js
function x(d) {
  return d[0];
}
function y(d) {
  return d[1];
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null;
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function(after, node) {
    var parent, grandpa, uncle;
    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },
  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U, sibling, left = node.L, right = node.R, next, red;
    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);
    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }
    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }
    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) {
      node.C = false;
      return;
    }
    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);
    if (node) node.C = false;
  }
};
function RedBlackRotateLeft(tree, node) {
  var p = node, q = node.R, parent = p.U;
  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}
function RedBlackRotateRight(tree, node) {
  var p = node, q = node.L, parent = p.U;
  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}
function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}
var RedBlackTree_default = RedBlackTree;

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/Edge.js
function createEdge(left, right, v0, v1) {
  var edge = [null, null], index2 = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index2);
  cells[right.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x02, y02, x12, y12) {
  var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  if (!(t0 > 0) && !(t1 < 1)) return true;
  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}
function connectEdge(edge, x02, y02, x12, y12) {
  var v1 = edge[1];
  if (v1) return true;
  var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x02 || fx >= x12) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y02];
      else if (v0[1] >= y12) return;
      v1 = [fx, y12];
    } else {
      if (!v0) v0 = [fx, y12];
      else if (v0[1] < y02) return;
      v1 = [fx, y02];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y02 - fb) / fm, y02];
        else if (v0[1] >= y12) return;
        v1 = [(y12 - fb) / fm, y12];
      } else {
        if (!v0) v0 = [(y12 - fb) / fm, y12];
        else if (v0[1] < y02) return;
        v1 = [(y02 - fb) / fm, y02];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x02, fm * x02 + fb];
        else if (v0[0] >= x12) return;
        v1 = [x12, fm * x12 + fb];
      } else {
        if (!v0) v0 = [x12, fm * x12 + fb];
        else if (v0[0] < x02) return;
        v1 = [x02, fm * x02 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v1;
  return true;
}
function clipEdges(x02, y02, x12, y12) {
  var i = edges.length, edge;
  while (i--) {
    if (!connectEdge(edge = edges[i], x02, y02, x12, y12) || !clipEdge(edge, x02, y02, x12, y12) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon5 || Math.abs(edge[0][1] - edge[1][1]) > epsilon5)) {
      delete edges[i];
    }
  }
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/Cell.js
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m), array2 = new Array(m);
      for (j = 0; j < m; ++j) index2[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index2.sort(function(i2, j2) {
        return array2[j2] - array2[i2];
      });
      for (j = 0; j < m; ++j) array2[j] = halfedges[index2[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array2[j];
    }
  }
}
function clipCells(x02, y02, x12, y12) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon5 || Math.abs(endY - startY) > epsilon5) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
            site,
            end,
            Math.abs(endX - x02) < epsilon5 && y12 - endY > epsilon5 ? [x02, Math.abs(startX - x02) < epsilon5 ? startY : y12] : Math.abs(endY - y12) < epsilon5 && x12 - endX > epsilon5 ? [Math.abs(startY - y12) < epsilon5 ? startX : x12, y12] : Math.abs(endX - x12) < epsilon5 && endY - y02 > epsilon5 ? [x12, Math.abs(startX - x12) < epsilon5 ? startY : y02] : Math.abs(endY - y02) < epsilon5 && endX - x02 > epsilon5 ? [Math.abs(startY - y02) < epsilon5 ? startX : x02, y02] : null
          )) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges) cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x02;
        dy = site[1] - y02;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x02, y02], v01 = [x02, y12], v11 = [x12, y12], v10 = [x12, y02];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/Circle.js
var circlePool = [];
var firstCircle;
function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
  var lArc = arc.P, rArc = arc.N;
  if (!lArc || !rArc) return;
  var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
  if (lSite === rSite) return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon22) return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
  var circle3 = circlePool.pop() || new Circle();
  circle3.arc = arc;
  circle3.site = cSite;
  circle3.x = x2 + bx;
  circle3.y = (circle3.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
  arc.circle = circle3;
  var before = null, node = circles._;
  while (node) {
    if (circle3.y < node.y || circle3.y === node.y && circle3.x <= node.x) {
      if (node.L) node = node.L;
      else {
        before = node.P;
        break;
      }
    } else {
      if (node.R) node = node.R;
      else {
        before = node;
        break;
      }
    }
  }
  circles.insert(before, circle3);
  if (!before) firstCircle = circle3;
}
function detachCircle(arc) {
  var circle3 = arc.circle;
  if (circle3) {
    if (!circle3.P) firstCircle = circle3.N;
    circles.remove(circle3);
    circlePool.push(circle3);
    RedBlackNode(circle3);
    arc.circle = null;
  }
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/Beach.js
var beachPool = [];
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle3 = beach.circle, x2 = circle3.x, y2 = circle3.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon5 && Math.abs(y2 - lArc.circle.cy) < epsilon5) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next;
  while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon5 && Math.abs(y2 - rArc.circle.cy) < epsilon5) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
  while (node) {
    dxl = leftBreakPoint(node, directrix) - x2;
    if (dxl > epsilon5) node = node.L;
    else {
      dxr = x2 - rightBreakPoint(node, directrix);
      if (dxr > epsilon5) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon5) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon5) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc) return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc, directrix) {
  var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2) return rfocx;
  var lArc = arc.P;
  if (!lArc) return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2) return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/Diagram.js
var epsilon5 = 1e-6;
var epsilon22 = 1e-12;
var beaches;
var cells;
var circles;
var edges;
function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}
function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}
function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(), x2, y2, circle3;
  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree_default();
  circles = new RedBlackTree_default();
  while (true) {
    circle3 = firstCircle;
    if (site && (!circle3 || site[1] < circle3.y || site[1] === circle3.y && site[0] < circle3.x)) {
      if (site[0] !== x2 || site[1] !== y2) {
        addBeach(site);
        x2 = site[0], y2 = site[1];
      }
      site = sites.pop();
    } else if (circle3) {
      removeBeach(circle3.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent) {
    var x02 = +extent[0][0], y02 = +extent[0][1], x12 = +extent[1][0], y12 = +extent[1][1];
    clipEdges(x02, y02, x12, y12);
    clipCells(x02, y02, x12, y12);
  }
  this.edges = edges;
  this.cells = cells;
  beaches = circles = edges = cells = null;
}
Diagram.prototype = {
  constructor: Diagram,
  polygons: function() {
    var edges2 = this.edges;
    return this.cells.map(function(cell) {
      var polygon2 = cell.halfedges.map(function(i) {
        return cellHalfedgeStart(cell, edges2[i]);
      });
      polygon2.data = cell.site.data;
      return polygon2;
    });
  },
  triangles: function() {
    var triangles = [], edges2 = this.edges;
    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
      while (++j < m) {
        s0 = s1;
        e1 = edges2[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function(x2, y2, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v2 = edge.left;
        if ((v2 === cell.site || !v2) && !(v2 = edge.right)) return;
        var vx = x2 - v2[0], vy = y2 - v2[1], v22 = vx * vx + vy * vy;
        if (v22 < d2) d2 = v22, i1 = v2.index;
      });
    } while (i1 !== null);
    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

// ../node_modules/.pnpm/d3-voronoi@1.1.2/node_modules/d3-voronoi/src/voronoi.js
function voronoi_default() {
  var x2 = x, y2 = y, extent = null;
  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x2(d, i, data) / epsilon5) * epsilon5, Math.round(y2(d, i, data) / epsilon5) * epsilon5];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }
  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };
  voronoi.links = function(data) {
    return voronoi(data).links();
  };
  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };
  voronoi.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default3(+_), voronoi) : x2;
  };
  voronoi.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default3(+_), voronoi) : y2;
  };
  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };
  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };
  return voronoi;
}

// ../node_modules/.pnpm/@turf+voronoi@7.1.0/node_modules/@turf/voronoi/dist/esm/index.js
function coordsToPolygon(coords) {
  coords = coords.slice();
  coords.push(coords[0]);
  return polygon([coords]);
}
function voronoi2(points2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const bbox3 = options.bbox || [-180, -85, 180, 85];
  if (!points2)
    throw new Error("points is required");
  if (!Array.isArray(bbox3))
    throw new Error("bbox is invalid");
  collectionOf(points2, "Point", "points");
  return featureCollection(
    voronoi_default().x((feature2) => feature2.geometry.coordinates[0]).y((feature2) => feature2.geometry.coordinates[1]).extent([
      [bbox3[0], bbox3[1]],
      [bbox3[2], bbox3[3]]
    ]).polygons(points2.features).map(function(coords, index2) {
      return Object.assign(coordsToPolygon(coords), {
        properties: cloneProperties(points2.features[index2].properties)
      });
    })
  );
}

export {
  earthRadius,
  factors,
  areaFactors,
  feature,
  geometry,
  point,
  points,
  polygon,
  polygons,
  lineString,
  lineStrings,
  featureCollection,
  multiLineString,
  multiPoint,
  multiPolygon,
  geometryCollection,
  round,
  radiansToLength,
  lengthToRadians,
  lengthToDegrees,
  bearingToAzimuth,
  azimuthToBearing,
  radiansToDegrees,
  degreesToRadians,
  convertLength,
  convertArea,
  isNumber,
  isObject,
  validateBBox,
  validateId,
  esm_exports,
  getCoord,
  getCoords,
  containsNumber,
  geojsonType,
  featureOf,
  collectionOf,
  getGeom,
  getType,
  esm_exports2,
  bearing,
  destination,
  distance,
  along,
  rhumbBearing,
  angle,
  coordEach,
  coordReduce,
  propEach,
  propReduce,
  featureEach,
  featureReduce,
  coordAll,
  geomEach,
  geomReduce,
  flattenEach,
  flattenReduce,
  segmentEach,
  segmentReduce,
  lineEach,
  lineReduce,
  findSegment,
  findPoint,
  esm_exports3,
  area,
  bbox,
  bboxClip,
  bboxPolygon,
  bezierSpline,
  booleanClockwise,
  booleanConcave,
  booleanPointInPolygon,
  booleanPointOnLine,
  booleanContains,
  lineIntersect,
  polygonToLine,
  booleanCrosses,
  booleanDisjoint,
  cleanCoords,
  booleanEqual,
  booleanIntersects,
  geojsonRbush,
  lineSegment,
  nearestPointOnLine,
  lineOverlap,
  booleanOverlap,
  booleanParallel,
  booleanTouches,
  booleanValid,
  booleanWithin,
  center,
  buffer,
  centerMean,
  centroid,
  centerMedian,
  convex,
  centerOfMass,
  circle2 as circle,
  clone,
  cloneProperties,
  getCluster,
  clusterEach,
  clusterReduce,
  createBins,
  applyFilter,
  propertiesContainsFilter,
  filterProperties,
  esm_exports4,
  clustersDbscan,
  clustersKmeans,
  collect,
  combine,
  tin,
  concave,
  difference2 as difference,
  flatten,
  dissolve2 as dissolve,
  distanceWeight,
  rhumbDestination,
  rhumbDistance,
  transformRotate,
  ellipse,
  envelope,
  explode2 as explode,
  flip,
  greatCircle,
  intersect2 as intersect,
  hexGrid,
  pointGrid,
  rectangleGrid,
  squareGrid,
  triangleGrid,
  interpolate,
  isobands,
  isolines,
  kinks,
  length2 as length,
  lineArc,
  lineSliceAlong,
  lineChunk,
  lineOffset,
  lineSlice,
  square,
  truncate,
  lineSplit,
  lineToPolygon,
  mask,
  midpoint,
  moranIndex,
  nearestPoint,
  nearestNeighborAnalysis,
  pointToLineDistance,
  nearestPointToLine,
  planepoint,
  pointOnFeature,
  pointsWithinPolygon,
  polygonize,
  polygonSmooth,
  polygonTangents,
  toMercator,
  toWgs84,
  esm_exports5,
  quadratAnalysis,
  randomPosition,
  randomPoint,
  randomPolygon,
  randomLineString,
  esm_exports6,
  rewind,
  sample,
  sector,
  transformScale,
  shortestPath,
  simplify2,
  standardDeviationalEllipse,
  tag,
  tesselate,
  transformTranslate,
  union2 as union,
  unkinkPolygon,
  voronoi2
};
/*! Bundled license information:

splaytree/dist/splay.esm.js:
  (**
   * splaytree v3.1.2
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@turf/great-circle/dist/esm/index.js:
  (*!
   * Copyright (c) 2019, Dane Springmeyer
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *     * Redistributions of source code must retain the above copyright
   *       notice, this list of conditions and the following disclaimer.
   *     * Redistributions in binary form must reproduce the above copyright
   *       notice, this list of conditions and the following disclaimer in
   *       the documentation and/or other materials provided with the
   *       distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
   * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
   * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

marchingsquares/dist/marchingsquares-esm.js:
  (*!
  * MarchingSquaresJS
  * version 1.3.3
  * https://github.com/RaumZeit/MarchingSquares.js
  *
  * @license GNU Affero General Public License.
  * Copyright (c) 2015-2019 Ronny Lorenz <ronny@tbi.univie.ac.at>
  *)
*/
//# sourceMappingURL=chunk-ZUHWOTBE.js.map
